
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Destination
 * 
 */
export type Destination = $Result.DefaultSelection<Prisma.$DestinationPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model ContactInquiry
 * 
 */
export type ContactInquiry = $Result.DefaultSelection<Prisma.$ContactInquiryPayload>
/**
 * Model NewsletterSubscription
 * 
 */
export type NewsletterSubscription = $Result.DefaultSelection<Prisma.$NewsletterSubscriptionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model CustomPackage
 * 
 */
export type CustomPackage = $Result.DefaultSelection<Prisma.$CustomPackagePayload>
/**
 * Model PackageBundle
 * 
 */
export type PackageBundle = $Result.DefaultSelection<Prisma.$PackageBundlePayload>
/**
 * Model PackageBundleItem
 * 
 */
export type PackageBundleItem = $Result.DefaultSelection<Prisma.$PackageBundleItemPayload>
/**
 * Model CMSImage
 * 
 */
export type CMSImage = $Result.DefaultSelection<Prisma.$CMSImagePayload>
/**
 * Model HeroSlide
 * 
 */
export type HeroSlide = $Result.DefaultSelection<Prisma.$HeroSlidePayload>
/**
 * Model CMSDestination
 * 
 */
export type CMSDestination = $Result.DefaultSelection<Prisma.$CMSDestinationPayload>
/**
 * Model SiteSettings
 * 
 */
export type SiteSettings = $Result.DefaultSelection<Prisma.$SiteSettingsPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model CMSAuditLog
 * 
 */
export type CMSAuditLog = $Result.DefaultSelection<Prisma.$CMSAuditLogPayload>
/**
 * Model ExperienceSection
 * 
 */
export type ExperienceSection = $Result.DefaultSelection<Prisma.$ExperienceSectionPayload>
/**
 * Model TourGuideSection
 * 
 */
export type TourGuideSection = $Result.DefaultSelection<Prisma.$TourGuideSectionPayload>
/**
 * Model VideoSection
 * 
 */
export type VideoSection = $Result.DefaultSelection<Prisma.$VideoSectionPayload>
/**
 * Model PackagesHero
 * 
 */
export type PackagesHero = $Result.DefaultSelection<Prisma.$PackagesHeroPayload>
/**
 * Model DestinationsHero
 * 
 */
export type DestinationsHero = $Result.DefaultSelection<Prisma.$DestinationsHeroPayload>
/**
 * Model DestinationsCTA
 * 
 */
export type DestinationsCTA = $Result.DefaultSelection<Prisma.$DestinationsCTAPayload>
/**
 * Model AboutStorySection
 * 
 */
export type AboutStorySection = $Result.DefaultSelection<Prisma.$AboutStorySectionPayload>
/**
 * Model AboutCommunitySection
 * 
 */
export type AboutCommunitySection = $Result.DefaultSelection<Prisma.$AboutCommunitySectionPayload>
/**
 * Model AboutStats
 * 
 */
export type AboutStats = $Result.DefaultSelection<Prisma.$AboutStatsPayload>
/**
 * Model AboutValue
 * 
 */
export type AboutValue = $Result.DefaultSelection<Prisma.$AboutValuePayload>
/**
 * Model AboutHero
 * 
 */
export type AboutHero = $Result.DefaultSelection<Prisma.$AboutHeroPayload>
/**
 * Model AboutCTA
 * 
 */
export type AboutCTA = $Result.DefaultSelection<Prisma.$AboutCTAPayload>
/**
 * Model ContactHero
 * 
 */
export type ContactHero = $Result.DefaultSelection<Prisma.$ContactHeroPayload>
/**
 * Model ContactInfo
 * 
 */
export type ContactInfo = $Result.DefaultSelection<Prisma.$ContactInfoPayload>
/**
 * Model ContactResource
 * 
 */
export type ContactResource = $Result.DefaultSelection<Prisma.$ContactResourcePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PARTIAL: 'PARTIAL',
  PAID: 'PAID',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const InquiryStatus: {
  NEW: 'NEW',
  RESPONDED: 'RESPONDED',
  RESOLVED: 'RESOLVED'
};

export type InquiryStatus = (typeof InquiryStatus)[keyof typeof InquiryStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  UNSUBSCRIBED: 'UNSUBSCRIBED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const DifficultyLevel: {
  EASY: 'EASY',
  MODERATE: 'MODERATE',
  CHALLENGING: 'CHALLENGING'
};

export type DifficultyLevel = (typeof DifficultyLevel)[keyof typeof DifficultyLevel]


export const BookingType: {
  PACKAGE: 'PACKAGE',
  DESTINATION: 'DESTINATION'
};

export type BookingType = (typeof BookingType)[keyof typeof BookingType]


export const CustomPackageStatus: {
  PENDING: 'PENDING',
  QUOTED: 'QUOTED',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type CustomPackageStatus = (typeof CustomPackageStatus)[keyof typeof CustomPackageStatus]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]

}

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type InquiryStatus = $Enums.InquiryStatus

export const InquiryStatus: typeof $Enums.InquiryStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type DifficultyLevel = $Enums.DifficultyLevel

export const DifficultyLevel: typeof $Enums.DifficultyLevel

export type BookingType = $Enums.BookingType

export const BookingType: typeof $Enums.BookingType

export type CustomPackageStatus = $Enums.CustomPackageStatus

export const CustomPackageStatus: typeof $Enums.CustomPackageStatus

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Destinations
 * const destinations = await prisma.destination.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Destinations
   * const destinations = await prisma.destination.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.destination`: Exposes CRUD operations for the **Destination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinations
    * const destinations = await prisma.destination.findMany()
    * ```
    */
  get destination(): Prisma.DestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactInquiry`: Exposes CRUD operations for the **ContactInquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInquiries
    * const contactInquiries = await prisma.contactInquiry.findMany()
    * ```
    */
  get contactInquiry(): Prisma.ContactInquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletterSubscription`: Exposes CRUD operations for the **NewsletterSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterSubscriptions
    * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
    * ```
    */
  get newsletterSubscription(): Prisma.NewsletterSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customPackage`: Exposes CRUD operations for the **CustomPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomPackages
    * const customPackages = await prisma.customPackage.findMany()
    * ```
    */
  get customPackage(): Prisma.CustomPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageBundle`: Exposes CRUD operations for the **PackageBundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageBundles
    * const packageBundles = await prisma.packageBundle.findMany()
    * ```
    */
  get packageBundle(): Prisma.PackageBundleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageBundleItem`: Exposes CRUD operations for the **PackageBundleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageBundleItems
    * const packageBundleItems = await prisma.packageBundleItem.findMany()
    * ```
    */
  get packageBundleItem(): Prisma.PackageBundleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cMSImage`: Exposes CRUD operations for the **CMSImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CMSImages
    * const cMSImages = await prisma.cMSImage.findMany()
    * ```
    */
  get cMSImage(): Prisma.CMSImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroSlide`: Exposes CRUD operations for the **HeroSlide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroSlides
    * const heroSlides = await prisma.heroSlide.findMany()
    * ```
    */
  get heroSlide(): Prisma.HeroSlideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cMSDestination`: Exposes CRUD operations for the **CMSDestination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CMSDestinations
    * const cMSDestinations = await prisma.cMSDestination.findMany()
    * ```
    */
  get cMSDestination(): Prisma.CMSDestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteSettings`: Exposes CRUD operations for the **SiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSettings.findMany()
    * ```
    */
  get siteSettings(): Prisma.SiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cMSAuditLog`: Exposes CRUD operations for the **CMSAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CMSAuditLogs
    * const cMSAuditLogs = await prisma.cMSAuditLog.findMany()
    * ```
    */
  get cMSAuditLog(): Prisma.CMSAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experienceSection`: Exposes CRUD operations for the **ExperienceSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExperienceSections
    * const experienceSections = await prisma.experienceSection.findMany()
    * ```
    */
  get experienceSection(): Prisma.ExperienceSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tourGuideSection`: Exposes CRUD operations for the **TourGuideSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourGuideSections
    * const tourGuideSections = await prisma.tourGuideSection.findMany()
    * ```
    */
  get tourGuideSection(): Prisma.TourGuideSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoSection`: Exposes CRUD operations for the **VideoSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoSections
    * const videoSections = await prisma.videoSection.findMany()
    * ```
    */
  get videoSection(): Prisma.VideoSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packagesHero`: Exposes CRUD operations for the **PackagesHero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackagesHeroes
    * const packagesHeroes = await prisma.packagesHero.findMany()
    * ```
    */
  get packagesHero(): Prisma.PackagesHeroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destinationsHero`: Exposes CRUD operations for the **DestinationsHero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DestinationsHeroes
    * const destinationsHeroes = await prisma.destinationsHero.findMany()
    * ```
    */
  get destinationsHero(): Prisma.DestinationsHeroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destinationsCTA`: Exposes CRUD operations for the **DestinationsCTA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DestinationsCTAS
    * const destinationsCTAS = await prisma.destinationsCTA.findMany()
    * ```
    */
  get destinationsCTA(): Prisma.DestinationsCTADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutStorySection`: Exposes CRUD operations for the **AboutStorySection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutStorySections
    * const aboutStorySections = await prisma.aboutStorySection.findMany()
    * ```
    */
  get aboutStorySection(): Prisma.AboutStorySectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutCommunitySection`: Exposes CRUD operations for the **AboutCommunitySection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutCommunitySections
    * const aboutCommunitySections = await prisma.aboutCommunitySection.findMany()
    * ```
    */
  get aboutCommunitySection(): Prisma.AboutCommunitySectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutStats`: Exposes CRUD operations for the **AboutStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutStats
    * const aboutStats = await prisma.aboutStats.findMany()
    * ```
    */
  get aboutStats(): Prisma.AboutStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutValue`: Exposes CRUD operations for the **AboutValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutValues
    * const aboutValues = await prisma.aboutValue.findMany()
    * ```
    */
  get aboutValue(): Prisma.AboutValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutHero`: Exposes CRUD operations for the **AboutHero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutHeroes
    * const aboutHeroes = await prisma.aboutHero.findMany()
    * ```
    */
  get aboutHero(): Prisma.AboutHeroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aboutCTA`: Exposes CRUD operations for the **AboutCTA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutCTAS
    * const aboutCTAS = await prisma.aboutCTA.findMany()
    * ```
    */
  get aboutCTA(): Prisma.AboutCTADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactHero`: Exposes CRUD operations for the **ContactHero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactHeroes
    * const contactHeroes = await prisma.contactHero.findMany()
    * ```
    */
  get contactHero(): Prisma.ContactHeroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactInfo`: Exposes CRUD operations for the **ContactInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInfos
    * const contactInfos = await prisma.contactInfo.findMany()
    * ```
    */
  get contactInfo(): Prisma.ContactInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactResource`: Exposes CRUD operations for the **ContactResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactResources
    * const contactResources = await prisma.contactResource.findMany()
    * ```
    */
  get contactResource(): Prisma.ContactResourceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Destination: 'Destination',
    Booking: 'Booking',
    ContactInquiry: 'ContactInquiry',
    NewsletterSubscription: 'NewsletterSubscription',
    User: 'User',
    UserFavorite: 'UserFavorite',
    Package: 'Package',
    CustomPackage: 'CustomPackage',
    PackageBundle: 'PackageBundle',
    PackageBundleItem: 'PackageBundleItem',
    CMSImage: 'CMSImage',
    HeroSlide: 'HeroSlide',
    CMSDestination: 'CMSDestination',
    SiteSettings: 'SiteSettings',
    TeamMember: 'TeamMember',
    FAQ: 'FAQ',
    CMSAuditLog: 'CMSAuditLog',
    ExperienceSection: 'ExperienceSection',
    TourGuideSection: 'TourGuideSection',
    VideoSection: 'VideoSection',
    PackagesHero: 'PackagesHero',
    DestinationsHero: 'DestinationsHero',
    DestinationsCTA: 'DestinationsCTA',
    AboutStorySection: 'AboutStorySection',
    AboutCommunitySection: 'AboutCommunitySection',
    AboutStats: 'AboutStats',
    AboutValue: 'AboutValue',
    AboutHero: 'AboutHero',
    AboutCTA: 'AboutCTA',
    ContactHero: 'ContactHero',
    ContactInfo: 'ContactInfo',
    ContactResource: 'ContactResource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "destination" | "booking" | "contactInquiry" | "newsletterSubscription" | "user" | "userFavorite" | "package" | "customPackage" | "packageBundle" | "packageBundleItem" | "cMSImage" | "heroSlide" | "cMSDestination" | "siteSettings" | "teamMember" | "fAQ" | "cMSAuditLog" | "experienceSection" | "tourGuideSection" | "videoSection" | "packagesHero" | "destinationsHero" | "destinationsCTA" | "aboutStorySection" | "aboutCommunitySection" | "aboutStats" | "aboutValue" | "aboutHero" | "aboutCTA" | "contactHero" | "contactInfo" | "contactResource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Destination: {
        payload: Prisma.$DestinationPayload<ExtArgs>
        fields: Prisma.DestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findFirst: {
            args: Prisma.DestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findMany: {
            args: Prisma.DestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          create: {
            args: Prisma.DestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          createMany: {
            args: Prisma.DestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          delete: {
            args: Prisma.DestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          update: {
            args: Prisma.DestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          deleteMany: {
            args: Prisma.DestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          upsert: {
            args: Prisma.DestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          aggregate: {
            args: Prisma.DestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestination>
          }
          groupBy: {
            args: Prisma.DestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      ContactInquiry: {
        payload: Prisma.$ContactInquiryPayload<ExtArgs>
        fields: Prisma.ContactInquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          findFirst: {
            args: Prisma.ContactInquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          findMany: {
            args: Prisma.ContactInquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>[]
          }
          create: {
            args: Prisma.ContactInquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          createMany: {
            args: Prisma.ContactInquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactInquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>[]
          }
          delete: {
            args: Prisma.ContactInquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          update: {
            args: Prisma.ContactInquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          deleteMany: {
            args: Prisma.ContactInquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactInquiryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>[]
          }
          upsert: {
            args: Prisma.ContactInquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInquiryPayload>
          }
          aggregate: {
            args: Prisma.ContactInquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactInquiry>
          }
          groupBy: {
            args: Prisma.ContactInquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactInquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactInquiryCountArgs<ExtArgs>
            result: $Utils.Optional<ContactInquiryCountAggregateOutputType> | number
          }
        }
      }
      NewsletterSubscription: {
        payload: Prisma.$NewsletterSubscriptionPayload<ExtArgs>
        fields: Prisma.NewsletterSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.NewsletterSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findMany: {
            args: Prisma.NewsletterSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          create: {
            args: Prisma.NewsletterSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          createMany: {
            args: Prisma.NewsletterSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.NewsletterSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          update: {
            args: Prisma.NewsletterSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.NewsletterSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.NewsletterSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterSubscription>
          }
          groupBy: {
            args: Prisma.NewsletterSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      CustomPackage: {
        payload: Prisma.$CustomPackagePayload<ExtArgs>
        fields: Prisma.CustomPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          findFirst: {
            args: Prisma.CustomPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          findMany: {
            args: Prisma.CustomPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>[]
          }
          create: {
            args: Prisma.CustomPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          createMany: {
            args: Prisma.CustomPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>[]
          }
          delete: {
            args: Prisma.CustomPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          update: {
            args: Prisma.CustomPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          deleteMany: {
            args: Prisma.CustomPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomPackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>[]
          }
          upsert: {
            args: Prisma.CustomPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPackagePayload>
          }
          aggregate: {
            args: Prisma.CustomPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomPackage>
          }
          groupBy: {
            args: Prisma.CustomPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomPackageCountArgs<ExtArgs>
            result: $Utils.Optional<CustomPackageCountAggregateOutputType> | number
          }
        }
      }
      PackageBundle: {
        payload: Prisma.$PackageBundlePayload<ExtArgs>
        fields: Prisma.PackageBundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageBundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageBundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          findFirst: {
            args: Prisma.PackageBundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageBundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          findMany: {
            args: Prisma.PackageBundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>[]
          }
          create: {
            args: Prisma.PackageBundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          createMany: {
            args: Prisma.PackageBundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageBundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>[]
          }
          delete: {
            args: Prisma.PackageBundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          update: {
            args: Prisma.PackageBundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          deleteMany: {
            args: Prisma.PackageBundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageBundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageBundleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>[]
          }
          upsert: {
            args: Prisma.PackageBundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundlePayload>
          }
          aggregate: {
            args: Prisma.PackageBundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageBundle>
          }
          groupBy: {
            args: Prisma.PackageBundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageBundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageBundleCountArgs<ExtArgs>
            result: $Utils.Optional<PackageBundleCountAggregateOutputType> | number
          }
        }
      }
      PackageBundleItem: {
        payload: Prisma.$PackageBundleItemPayload<ExtArgs>
        fields: Prisma.PackageBundleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageBundleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageBundleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          findFirst: {
            args: Prisma.PackageBundleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageBundleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          findMany: {
            args: Prisma.PackageBundleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>[]
          }
          create: {
            args: Prisma.PackageBundleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          createMany: {
            args: Prisma.PackageBundleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageBundleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>[]
          }
          delete: {
            args: Prisma.PackageBundleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          update: {
            args: Prisma.PackageBundleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          deleteMany: {
            args: Prisma.PackageBundleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageBundleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageBundleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>[]
          }
          upsert: {
            args: Prisma.PackageBundleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageBundleItemPayload>
          }
          aggregate: {
            args: Prisma.PackageBundleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageBundleItem>
          }
          groupBy: {
            args: Prisma.PackageBundleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageBundleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageBundleItemCountArgs<ExtArgs>
            result: $Utils.Optional<PackageBundleItemCountAggregateOutputType> | number
          }
        }
      }
      CMSImage: {
        payload: Prisma.$CMSImagePayload<ExtArgs>
        fields: Prisma.CMSImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CMSImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CMSImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          findFirst: {
            args: Prisma.CMSImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CMSImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          findMany: {
            args: Prisma.CMSImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>[]
          }
          create: {
            args: Prisma.CMSImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          createMany: {
            args: Prisma.CMSImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CMSImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>[]
          }
          delete: {
            args: Prisma.CMSImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          update: {
            args: Prisma.CMSImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          deleteMany: {
            args: Prisma.CMSImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CMSImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CMSImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>[]
          }
          upsert: {
            args: Prisma.CMSImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSImagePayload>
          }
          aggregate: {
            args: Prisma.CMSImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCMSImage>
          }
          groupBy: {
            args: Prisma.CMSImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CMSImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CMSImageCountArgs<ExtArgs>
            result: $Utils.Optional<CMSImageCountAggregateOutputType> | number
          }
        }
      }
      HeroSlide: {
        payload: Prisma.$HeroSlidePayload<ExtArgs>
        fields: Prisma.HeroSlideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroSlideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroSlideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          findFirst: {
            args: Prisma.HeroSlideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroSlideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          findMany: {
            args: Prisma.HeroSlideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
          }
          create: {
            args: Prisma.HeroSlideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          createMany: {
            args: Prisma.HeroSlideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroSlideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
          }
          delete: {
            args: Prisma.HeroSlideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          update: {
            args: Prisma.HeroSlideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          deleteMany: {
            args: Prisma.HeroSlideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroSlideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HeroSlideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
          }
          upsert: {
            args: Prisma.HeroSlideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>
          }
          aggregate: {
            args: Prisma.HeroSlideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroSlide>
          }
          groupBy: {
            args: Prisma.HeroSlideGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroSlideGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroSlideCountArgs<ExtArgs>
            result: $Utils.Optional<HeroSlideCountAggregateOutputType> | number
          }
        }
      }
      CMSDestination: {
        payload: Prisma.$CMSDestinationPayload<ExtArgs>
        fields: Prisma.CMSDestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CMSDestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CMSDestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          findFirst: {
            args: Prisma.CMSDestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CMSDestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          findMany: {
            args: Prisma.CMSDestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>[]
          }
          create: {
            args: Prisma.CMSDestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          createMany: {
            args: Prisma.CMSDestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CMSDestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>[]
          }
          delete: {
            args: Prisma.CMSDestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          update: {
            args: Prisma.CMSDestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          deleteMany: {
            args: Prisma.CMSDestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CMSDestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CMSDestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>[]
          }
          upsert: {
            args: Prisma.CMSDestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSDestinationPayload>
          }
          aggregate: {
            args: Prisma.CMSDestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCMSDestination>
          }
          groupBy: {
            args: Prisma.CMSDestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CMSDestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CMSDestinationCountArgs<ExtArgs>
            result: $Utils.Optional<CMSDestinationCountAggregateOutputType> | number
          }
        }
      }
      SiteSettings: {
        payload: Prisma.$SiteSettingsPayload<ExtArgs>
        fields: Prisma.SiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findMany: {
            args: Prisma.SiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          create: {
            args: Prisma.SiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          createMany: {
            args: Prisma.SiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          delete: {
            args: Prisma.SiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          update: {
            args: Prisma.SiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSettings>
          }
          groupBy: {
            args: Prisma.SiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      CMSAuditLog: {
        payload: Prisma.$CMSAuditLogPayload<ExtArgs>
        fields: Prisma.CMSAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CMSAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CMSAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          findFirst: {
            args: Prisma.CMSAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CMSAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          findMany: {
            args: Prisma.CMSAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>[]
          }
          create: {
            args: Prisma.CMSAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          createMany: {
            args: Prisma.CMSAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CMSAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>[]
          }
          delete: {
            args: Prisma.CMSAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          update: {
            args: Prisma.CMSAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.CMSAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CMSAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CMSAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.CMSAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CMSAuditLogPayload>
          }
          aggregate: {
            args: Prisma.CMSAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCMSAuditLog>
          }
          groupBy: {
            args: Prisma.CMSAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CMSAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CMSAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<CMSAuditLogCountAggregateOutputType> | number
          }
        }
      }
      ExperienceSection: {
        payload: Prisma.$ExperienceSectionPayload<ExtArgs>
        fields: Prisma.ExperienceSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          findFirst: {
            args: Prisma.ExperienceSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          findMany: {
            args: Prisma.ExperienceSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>[]
          }
          create: {
            args: Prisma.ExperienceSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          createMany: {
            args: Prisma.ExperienceSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperienceSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>[]
          }
          delete: {
            args: Prisma.ExperienceSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          update: {
            args: Prisma.ExperienceSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          deleteMany: {
            args: Prisma.ExperienceSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExperienceSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>[]
          }
          upsert: {
            args: Prisma.ExperienceSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceSectionPayload>
          }
          aggregate: {
            args: Prisma.ExperienceSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperienceSection>
          }
          groupBy: {
            args: Prisma.ExperienceSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperienceSectionCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceSectionCountAggregateOutputType> | number
          }
        }
      }
      TourGuideSection: {
        payload: Prisma.$TourGuideSectionPayload<ExtArgs>
        fields: Prisma.TourGuideSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourGuideSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourGuideSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          findFirst: {
            args: Prisma.TourGuideSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourGuideSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          findMany: {
            args: Prisma.TourGuideSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>[]
          }
          create: {
            args: Prisma.TourGuideSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          createMany: {
            args: Prisma.TourGuideSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourGuideSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>[]
          }
          delete: {
            args: Prisma.TourGuideSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          update: {
            args: Prisma.TourGuideSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          deleteMany: {
            args: Prisma.TourGuideSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourGuideSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TourGuideSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>[]
          }
          upsert: {
            args: Prisma.TourGuideSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourGuideSectionPayload>
          }
          aggregate: {
            args: Prisma.TourGuideSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourGuideSection>
          }
          groupBy: {
            args: Prisma.TourGuideSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGuideSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourGuideSectionCountArgs<ExtArgs>
            result: $Utils.Optional<TourGuideSectionCountAggregateOutputType> | number
          }
        }
      }
      VideoSection: {
        payload: Prisma.$VideoSectionPayload<ExtArgs>
        fields: Prisma.VideoSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          findFirst: {
            args: Prisma.VideoSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          findMany: {
            args: Prisma.VideoSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>[]
          }
          create: {
            args: Prisma.VideoSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          createMany: {
            args: Prisma.VideoSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>[]
          }
          delete: {
            args: Prisma.VideoSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          update: {
            args: Prisma.VideoSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          deleteMany: {
            args: Prisma.VideoSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>[]
          }
          upsert: {
            args: Prisma.VideoSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSectionPayload>
          }
          aggregate: {
            args: Prisma.VideoSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoSection>
          }
          groupBy: {
            args: Prisma.VideoSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoSectionCountArgs<ExtArgs>
            result: $Utils.Optional<VideoSectionCountAggregateOutputType> | number
          }
        }
      }
      PackagesHero: {
        payload: Prisma.$PackagesHeroPayload<ExtArgs>
        fields: Prisma.PackagesHeroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackagesHeroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackagesHeroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          findFirst: {
            args: Prisma.PackagesHeroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackagesHeroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          findMany: {
            args: Prisma.PackagesHeroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>[]
          }
          create: {
            args: Prisma.PackagesHeroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          createMany: {
            args: Prisma.PackagesHeroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackagesHeroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>[]
          }
          delete: {
            args: Prisma.PackagesHeroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          update: {
            args: Prisma.PackagesHeroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          deleteMany: {
            args: Prisma.PackagesHeroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackagesHeroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackagesHeroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>[]
          }
          upsert: {
            args: Prisma.PackagesHeroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagesHeroPayload>
          }
          aggregate: {
            args: Prisma.PackagesHeroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackagesHero>
          }
          groupBy: {
            args: Prisma.PackagesHeroGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagesHeroGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackagesHeroCountArgs<ExtArgs>
            result: $Utils.Optional<PackagesHeroCountAggregateOutputType> | number
          }
        }
      }
      DestinationsHero: {
        payload: Prisma.$DestinationsHeroPayload<ExtArgs>
        fields: Prisma.DestinationsHeroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationsHeroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationsHeroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          findFirst: {
            args: Prisma.DestinationsHeroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationsHeroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          findMany: {
            args: Prisma.DestinationsHeroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>[]
          }
          create: {
            args: Prisma.DestinationsHeroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          createMany: {
            args: Prisma.DestinationsHeroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationsHeroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>[]
          }
          delete: {
            args: Prisma.DestinationsHeroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          update: {
            args: Prisma.DestinationsHeroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          deleteMany: {
            args: Prisma.DestinationsHeroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationsHeroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationsHeroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>[]
          }
          upsert: {
            args: Prisma.DestinationsHeroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsHeroPayload>
          }
          aggregate: {
            args: Prisma.DestinationsHeroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestinationsHero>
          }
          groupBy: {
            args: Prisma.DestinationsHeroGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationsHeroGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationsHeroCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationsHeroCountAggregateOutputType> | number
          }
        }
      }
      DestinationsCTA: {
        payload: Prisma.$DestinationsCTAPayload<ExtArgs>
        fields: Prisma.DestinationsCTAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationsCTAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationsCTAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          findFirst: {
            args: Prisma.DestinationsCTAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationsCTAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          findMany: {
            args: Prisma.DestinationsCTAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>[]
          }
          create: {
            args: Prisma.DestinationsCTACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          createMany: {
            args: Prisma.DestinationsCTACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationsCTACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>[]
          }
          delete: {
            args: Prisma.DestinationsCTADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          update: {
            args: Prisma.DestinationsCTAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          deleteMany: {
            args: Prisma.DestinationsCTADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationsCTAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationsCTAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>[]
          }
          upsert: {
            args: Prisma.DestinationsCTAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationsCTAPayload>
          }
          aggregate: {
            args: Prisma.DestinationsCTAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestinationsCTA>
          }
          groupBy: {
            args: Prisma.DestinationsCTAGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationsCTAGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationsCTACountArgs<ExtArgs>
            result: $Utils.Optional<DestinationsCTACountAggregateOutputType> | number
          }
        }
      }
      AboutStorySection: {
        payload: Prisma.$AboutStorySectionPayload<ExtArgs>
        fields: Prisma.AboutStorySectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutStorySectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutStorySectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          findFirst: {
            args: Prisma.AboutStorySectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutStorySectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          findMany: {
            args: Prisma.AboutStorySectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>[]
          }
          create: {
            args: Prisma.AboutStorySectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          createMany: {
            args: Prisma.AboutStorySectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutStorySectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>[]
          }
          delete: {
            args: Prisma.AboutStorySectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          update: {
            args: Prisma.AboutStorySectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          deleteMany: {
            args: Prisma.AboutStorySectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutStorySectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutStorySectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>[]
          }
          upsert: {
            args: Prisma.AboutStorySectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStorySectionPayload>
          }
          aggregate: {
            args: Prisma.AboutStorySectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutStorySection>
          }
          groupBy: {
            args: Prisma.AboutStorySectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutStorySectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutStorySectionCountArgs<ExtArgs>
            result: $Utils.Optional<AboutStorySectionCountAggregateOutputType> | number
          }
        }
      }
      AboutCommunitySection: {
        payload: Prisma.$AboutCommunitySectionPayload<ExtArgs>
        fields: Prisma.AboutCommunitySectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutCommunitySectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutCommunitySectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          findFirst: {
            args: Prisma.AboutCommunitySectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutCommunitySectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          findMany: {
            args: Prisma.AboutCommunitySectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>[]
          }
          create: {
            args: Prisma.AboutCommunitySectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          createMany: {
            args: Prisma.AboutCommunitySectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutCommunitySectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>[]
          }
          delete: {
            args: Prisma.AboutCommunitySectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          update: {
            args: Prisma.AboutCommunitySectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          deleteMany: {
            args: Prisma.AboutCommunitySectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutCommunitySectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutCommunitySectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>[]
          }
          upsert: {
            args: Prisma.AboutCommunitySectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCommunitySectionPayload>
          }
          aggregate: {
            args: Prisma.AboutCommunitySectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutCommunitySection>
          }
          groupBy: {
            args: Prisma.AboutCommunitySectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutCommunitySectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutCommunitySectionCountArgs<ExtArgs>
            result: $Utils.Optional<AboutCommunitySectionCountAggregateOutputType> | number
          }
        }
      }
      AboutStats: {
        payload: Prisma.$AboutStatsPayload<ExtArgs>
        fields: Prisma.AboutStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          findFirst: {
            args: Prisma.AboutStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          findMany: {
            args: Prisma.AboutStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>[]
          }
          create: {
            args: Prisma.AboutStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          createMany: {
            args: Prisma.AboutStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>[]
          }
          delete: {
            args: Prisma.AboutStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          update: {
            args: Prisma.AboutStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          deleteMany: {
            args: Prisma.AboutStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>[]
          }
          upsert: {
            args: Prisma.AboutStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutStatsPayload>
          }
          aggregate: {
            args: Prisma.AboutStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutStats>
          }
          groupBy: {
            args: Prisma.AboutStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutStatsCountArgs<ExtArgs>
            result: $Utils.Optional<AboutStatsCountAggregateOutputType> | number
          }
        }
      }
      AboutValue: {
        payload: Prisma.$AboutValuePayload<ExtArgs>
        fields: Prisma.AboutValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          findFirst: {
            args: Prisma.AboutValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          findMany: {
            args: Prisma.AboutValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>[]
          }
          create: {
            args: Prisma.AboutValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          createMany: {
            args: Prisma.AboutValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>[]
          }
          delete: {
            args: Prisma.AboutValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          update: {
            args: Prisma.AboutValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          deleteMany: {
            args: Prisma.AboutValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>[]
          }
          upsert: {
            args: Prisma.AboutValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutValuePayload>
          }
          aggregate: {
            args: Prisma.AboutValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutValue>
          }
          groupBy: {
            args: Prisma.AboutValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutValueCountArgs<ExtArgs>
            result: $Utils.Optional<AboutValueCountAggregateOutputType> | number
          }
        }
      }
      AboutHero: {
        payload: Prisma.$AboutHeroPayload<ExtArgs>
        fields: Prisma.AboutHeroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutHeroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutHeroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          findFirst: {
            args: Prisma.AboutHeroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutHeroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          findMany: {
            args: Prisma.AboutHeroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>[]
          }
          create: {
            args: Prisma.AboutHeroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          createMany: {
            args: Prisma.AboutHeroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutHeroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>[]
          }
          delete: {
            args: Prisma.AboutHeroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          update: {
            args: Prisma.AboutHeroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          deleteMany: {
            args: Prisma.AboutHeroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutHeroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutHeroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>[]
          }
          upsert: {
            args: Prisma.AboutHeroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutHeroPayload>
          }
          aggregate: {
            args: Prisma.AboutHeroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutHero>
          }
          groupBy: {
            args: Prisma.AboutHeroGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutHeroGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutHeroCountArgs<ExtArgs>
            result: $Utils.Optional<AboutHeroCountAggregateOutputType> | number
          }
        }
      }
      AboutCTA: {
        payload: Prisma.$AboutCTAPayload<ExtArgs>
        fields: Prisma.AboutCTAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AboutCTAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutCTAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          findFirst: {
            args: Prisma.AboutCTAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutCTAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          findMany: {
            args: Prisma.AboutCTAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>[]
          }
          create: {
            args: Prisma.AboutCTACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          createMany: {
            args: Prisma.AboutCTACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AboutCTACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>[]
          }
          delete: {
            args: Prisma.AboutCTADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          update: {
            args: Prisma.AboutCTAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          deleteMany: {
            args: Prisma.AboutCTADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AboutCTAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AboutCTAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>[]
          }
          upsert: {
            args: Prisma.AboutCTAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AboutCTAPayload>
          }
          aggregate: {
            args: Prisma.AboutCTAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutCTA>
          }
          groupBy: {
            args: Prisma.AboutCTAGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutCTAGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutCTACountArgs<ExtArgs>
            result: $Utils.Optional<AboutCTACountAggregateOutputType> | number
          }
        }
      }
      ContactHero: {
        payload: Prisma.$ContactHeroPayload<ExtArgs>
        fields: Prisma.ContactHeroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactHeroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactHeroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          findFirst: {
            args: Prisma.ContactHeroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactHeroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          findMany: {
            args: Prisma.ContactHeroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>[]
          }
          create: {
            args: Prisma.ContactHeroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          createMany: {
            args: Prisma.ContactHeroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactHeroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>[]
          }
          delete: {
            args: Prisma.ContactHeroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          update: {
            args: Prisma.ContactHeroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          deleteMany: {
            args: Prisma.ContactHeroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactHeroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactHeroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>[]
          }
          upsert: {
            args: Prisma.ContactHeroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactHeroPayload>
          }
          aggregate: {
            args: Prisma.ContactHeroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactHero>
          }
          groupBy: {
            args: Prisma.ContactHeroGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactHeroGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactHeroCountArgs<ExtArgs>
            result: $Utils.Optional<ContactHeroCountAggregateOutputType> | number
          }
        }
      }
      ContactInfo: {
        payload: Prisma.$ContactInfoPayload<ExtArgs>
        fields: Prisma.ContactInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findFirst: {
            args: Prisma.ContactInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findMany: {
            args: Prisma.ContactInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          create: {
            args: Prisma.ContactInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          createMany: {
            args: Prisma.ContactInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          delete: {
            args: Prisma.ContactInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          update: {
            args: Prisma.ContactInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          deleteMany: {
            args: Prisma.ContactInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          upsert: {
            args: Prisma.ContactInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          aggregate: {
            args: Prisma.ContactInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactInfo>
          }
          groupBy: {
            args: Prisma.ContactInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactInfoCountArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoCountAggregateOutputType> | number
          }
        }
      }
      ContactResource: {
        payload: Prisma.$ContactResourcePayload<ExtArgs>
        fields: Prisma.ContactResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          findFirst: {
            args: Prisma.ContactResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          findMany: {
            args: Prisma.ContactResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>[]
          }
          create: {
            args: Prisma.ContactResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          createMany: {
            args: Prisma.ContactResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>[]
          }
          delete: {
            args: Prisma.ContactResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          update: {
            args: Prisma.ContactResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          deleteMany: {
            args: Prisma.ContactResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>[]
          }
          upsert: {
            args: Prisma.ContactResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactResourcePayload>
          }
          aggregate: {
            args: Prisma.ContactResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactResource>
          }
          groupBy: {
            args: Prisma.ContactResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ContactResourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    destination?: DestinationOmit
    booking?: BookingOmit
    contactInquiry?: ContactInquiryOmit
    newsletterSubscription?: NewsletterSubscriptionOmit
    user?: UserOmit
    userFavorite?: UserFavoriteOmit
    package?: PackageOmit
    customPackage?: CustomPackageOmit
    packageBundle?: PackageBundleOmit
    packageBundleItem?: PackageBundleItemOmit
    cMSImage?: CMSImageOmit
    heroSlide?: HeroSlideOmit
    cMSDestination?: CMSDestinationOmit
    siteSettings?: SiteSettingsOmit
    teamMember?: TeamMemberOmit
    fAQ?: FAQOmit
    cMSAuditLog?: CMSAuditLogOmit
    experienceSection?: ExperienceSectionOmit
    tourGuideSection?: TourGuideSectionOmit
    videoSection?: VideoSectionOmit
    packagesHero?: PackagesHeroOmit
    destinationsHero?: DestinationsHeroOmit
    destinationsCTA?: DestinationsCTAOmit
    aboutStorySection?: AboutStorySectionOmit
    aboutCommunitySection?: AboutCommunitySectionOmit
    aboutStats?: AboutStatsOmit
    aboutValue?: AboutValueOmit
    aboutHero?: AboutHeroOmit
    aboutCTA?: AboutCTAOmit
    contactHero?: ContactHeroOmit
    contactInfo?: ContactInfoOmit
    contactResource?: ContactResourceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DestinationCountOutputType
   */

  export type DestinationCountOutputType = {
    bookings: number
    favorites: number
  }

  export type DestinationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | DestinationCountOutputTypeCountBookingsArgs
    favorites?: boolean | DestinationCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationCountOutputType
     */
    select?: DestinationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    favorites: number
    customPackages: number
    packageBundles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    customPackages?: boolean | UserCountOutputTypeCountCustomPackagesArgs
    packageBundles?: boolean | UserCountOutputTypeCountPackageBundlesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPackageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPackageBundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageBundleWhereInput
  }


  /**
   * Count Type PackageCountOutputType
   */

  export type PackageCountOutputType = {
    bookings: number
    bundleItems: number
  }

  export type PackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PackageCountOutputTypeCountBookingsArgs
    bundleItems?: boolean | PackageCountOutputTypeCountBundleItemsArgs
  }

  // Custom InputTypes
  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCountOutputType
     */
    select?: PackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountBundleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageBundleItemWhereInput
  }


  /**
   * Count Type PackageBundleCountOutputType
   */

  export type PackageBundleCountOutputType = {
    packages: number
  }

  export type PackageBundleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packages?: boolean | PackageBundleCountOutputTypeCountPackagesArgs
  }

  // Custom InputTypes
  /**
   * PackageBundleCountOutputType without action
   */
  export type PackageBundleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleCountOutputType
     */
    select?: PackageBundleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageBundleCountOutputType without action
   */
  export type PackageBundleCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageBundleItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Destination
   */

  export type AggregateDestination = {
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  export type DestinationAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    rating: number | null
    groupSize: number | null
    minTravelers: number | null
    maxTravelers: number | null
  }

  export type DestinationSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    rating: number | null
    groupSize: number | null
    minTravelers: number | null
    maxTravelers: number | null
  }

  export type DestinationMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    country: string | null
    region: string | null
    price: Decimal | null
    rating: number | null
    duration: string | null
    groupSize: number | null
    minTravelers: number | null
    maxTravelers: number | null
    description: string | null
    image: string | null
    featured: boolean | null
    historyTitle: string | null
    geographyDescription: string | null
    geographyClimate: string | null
    wildlifeDescription: string | null
    cultureDescription: string | null
    bestTimeDescription: string | null
    drySeasonTitle: string | null
    drySeasonDescription: string | null
    wetSeasonTitle: string | null
    wetSeasonDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    country: string | null
    region: string | null
    price: Decimal | null
    rating: number | null
    duration: string | null
    groupSize: number | null
    minTravelers: number | null
    maxTravelers: number | null
    description: string | null
    image: string | null
    featured: boolean | null
    historyTitle: string | null
    geographyDescription: string | null
    geographyClimate: string | null
    wildlifeDescription: string | null
    cultureDescription: string | null
    bestTimeDescription: string | null
    drySeasonTitle: string | null
    drySeasonDescription: string | null
    wetSeasonTitle: string | null
    wetSeasonDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationCountAggregateOutputType = {
    id: number
    name: number
    category: number
    country: number
    region: number
    price: number
    rating: number
    duration: number
    groupSize: number
    minTravelers: number
    maxTravelers: number
    description: number
    image: number
    images: number
    gallery2Images: number
    featured: number
    historyTitle: number
    historyContent: number
    geographyDescription: number
    geographyClimate: number
    wildlifeDescription: number
    wildlifeMammals: number
    wildlifeBirds: number
    wildlifeFlora: number
    cultureDescription: number
    cultureExperiences: number
    bestTimeDescription: number
    drySeasonTitle: number
    drySeasonDescription: number
    wetSeasonTitle: number
    wetSeasonDescription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationAvgAggregateInputType = {
    id?: true
    price?: true
    rating?: true
    groupSize?: true
    minTravelers?: true
    maxTravelers?: true
  }

  export type DestinationSumAggregateInputType = {
    id?: true
    price?: true
    rating?: true
    groupSize?: true
    minTravelers?: true
    maxTravelers?: true
  }

  export type DestinationMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    country?: true
    region?: true
    price?: true
    rating?: true
    duration?: true
    groupSize?: true
    minTravelers?: true
    maxTravelers?: true
    description?: true
    image?: true
    featured?: true
    historyTitle?: true
    geographyDescription?: true
    geographyClimate?: true
    wildlifeDescription?: true
    cultureDescription?: true
    bestTimeDescription?: true
    drySeasonTitle?: true
    drySeasonDescription?: true
    wetSeasonTitle?: true
    wetSeasonDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    country?: true
    region?: true
    price?: true
    rating?: true
    duration?: true
    groupSize?: true
    minTravelers?: true
    maxTravelers?: true
    description?: true
    image?: true
    featured?: true
    historyTitle?: true
    geographyDescription?: true
    geographyClimate?: true
    wildlifeDescription?: true
    cultureDescription?: true
    bestTimeDescription?: true
    drySeasonTitle?: true
    drySeasonDescription?: true
    wetSeasonTitle?: true
    wetSeasonDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    country?: true
    region?: true
    price?: true
    rating?: true
    duration?: true
    groupSize?: true
    minTravelers?: true
    maxTravelers?: true
    description?: true
    image?: true
    images?: true
    gallery2Images?: true
    featured?: true
    historyTitle?: true
    historyContent?: true
    geographyDescription?: true
    geographyClimate?: true
    wildlifeDescription?: true
    wildlifeMammals?: true
    wildlifeBirds?: true
    wildlifeFlora?: true
    cultureDescription?: true
    cultureExperiences?: true
    bestTimeDescription?: true
    drySeasonTitle?: true
    drySeasonDescription?: true
    wetSeasonTitle?: true
    wetSeasonDescription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destination to aggregate.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinations
    **/
    _count?: true | DestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationMaxAggregateInputType
  }

  export type GetDestinationAggregateType<T extends DestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestination[P]>
      : GetScalarType<T[P], AggregateDestination[P]>
  }




  export type DestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithAggregationInput | DestinationOrderByWithAggregationInput[]
    by: DestinationScalarFieldEnum[] | DestinationScalarFieldEnum
    having?: DestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationCountAggregateInputType | true
    _avg?: DestinationAvgAggregateInputType
    _sum?: DestinationSumAggregateInputType
    _min?: DestinationMinAggregateInputType
    _max?: DestinationMaxAggregateInputType
  }

  export type DestinationGroupByOutputType = {
    id: number
    name: string
    category: string
    country: string
    region: string | null
    price: Decimal
    rating: number
    duration: string
    groupSize: number
    minTravelers: number | null
    maxTravelers: number | null
    description: string
    image: string
    images: string[]
    gallery2Images: string[]
    featured: boolean
    historyTitle: string | null
    historyContent: string[]
    geographyDescription: string | null
    geographyClimate: string | null
    wildlifeDescription: string | null
    wildlifeMammals: string[]
    wildlifeBirds: string[]
    wildlifeFlora: string[]
    cultureDescription: string | null
    cultureExperiences: string[]
    bestTimeDescription: string | null
    drySeasonTitle: string | null
    drySeasonDescription: string | null
    wetSeasonTitle: string | null
    wetSeasonDescription: string | null
    createdAt: Date
    updatedAt: Date
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  type GetDestinationGroupByPayload<T extends DestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationGroupByOutputType[P]>
        }
      >
    >


  export type DestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    country?: boolean
    region?: boolean
    price?: boolean
    rating?: boolean
    duration?: boolean
    groupSize?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    description?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    featured?: boolean
    historyTitle?: boolean
    historyContent?: boolean
    geographyDescription?: boolean
    geographyClimate?: boolean
    wildlifeDescription?: boolean
    wildlifeMammals?: boolean
    wildlifeBirds?: boolean
    wildlifeFlora?: boolean
    cultureDescription?: boolean
    cultureExperiences?: boolean
    bestTimeDescription?: boolean
    drySeasonTitle?: boolean
    drySeasonDescription?: boolean
    wetSeasonTitle?: boolean
    wetSeasonDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Destination$bookingsArgs<ExtArgs>
    favorites?: boolean | Destination$favoritesArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    country?: boolean
    region?: boolean
    price?: boolean
    rating?: boolean
    duration?: boolean
    groupSize?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    description?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    featured?: boolean
    historyTitle?: boolean
    historyContent?: boolean
    geographyDescription?: boolean
    geographyClimate?: boolean
    wildlifeDescription?: boolean
    wildlifeMammals?: boolean
    wildlifeBirds?: boolean
    wildlifeFlora?: boolean
    cultureDescription?: boolean
    cultureExperiences?: boolean
    bestTimeDescription?: boolean
    drySeasonTitle?: boolean
    drySeasonDescription?: boolean
    wetSeasonTitle?: boolean
    wetSeasonDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    country?: boolean
    region?: boolean
    price?: boolean
    rating?: boolean
    duration?: boolean
    groupSize?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    description?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    featured?: boolean
    historyTitle?: boolean
    historyContent?: boolean
    geographyDescription?: boolean
    geographyClimate?: boolean
    wildlifeDescription?: boolean
    wildlifeMammals?: boolean
    wildlifeBirds?: boolean
    wildlifeFlora?: boolean
    cultureDescription?: boolean
    cultureExperiences?: boolean
    bestTimeDescription?: boolean
    drySeasonTitle?: boolean
    drySeasonDescription?: boolean
    wetSeasonTitle?: boolean
    wetSeasonDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    country?: boolean
    region?: boolean
    price?: boolean
    rating?: boolean
    duration?: boolean
    groupSize?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    description?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    featured?: boolean
    historyTitle?: boolean
    historyContent?: boolean
    geographyDescription?: boolean
    geographyClimate?: boolean
    wildlifeDescription?: boolean
    wildlifeMammals?: boolean
    wildlifeBirds?: boolean
    wildlifeFlora?: boolean
    cultureDescription?: boolean
    cultureExperiences?: boolean
    bestTimeDescription?: boolean
    drySeasonTitle?: boolean
    drySeasonDescription?: boolean
    wetSeasonTitle?: boolean
    wetSeasonDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "country" | "region" | "price" | "rating" | "duration" | "groupSize" | "minTravelers" | "maxTravelers" | "description" | "image" | "images" | "gallery2Images" | "featured" | "historyTitle" | "historyContent" | "geographyDescription" | "geographyClimate" | "wildlifeDescription" | "wildlifeMammals" | "wildlifeBirds" | "wildlifeFlora" | "cultureDescription" | "cultureExperiences" | "bestTimeDescription" | "drySeasonTitle" | "drySeasonDescription" | "wetSeasonTitle" | "wetSeasonDescription" | "createdAt" | "updatedAt", ExtArgs["result"]["destination"]>
  export type DestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Destination$bookingsArgs<ExtArgs>
    favorites?: boolean | Destination$favoritesArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DestinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Destination"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      favorites: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      country: string
      region: string | null
      price: Prisma.Decimal
      rating: number
      duration: string
      groupSize: number
      minTravelers: number | null
      maxTravelers: number | null
      description: string
      image: string
      images: string[]
      gallery2Images: string[]
      featured: boolean
      historyTitle: string | null
      historyContent: string[]
      geographyDescription: string | null
      geographyClimate: string | null
      wildlifeDescription: string | null
      wildlifeMammals: string[]
      wildlifeBirds: string[]
      wildlifeFlora: string[]
      cultureDescription: string | null
      cultureExperiences: string[]
      bestTimeDescription: string | null
      drySeasonTitle: string | null
      drySeasonDescription: string | null
      wetSeasonTitle: string | null
      wetSeasonDescription: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destination"]>
    composites: {}
  }

  type DestinationGetPayload<S extends boolean | null | undefined | DestinationDefaultArgs> = $Result.GetResult<Prisma.$DestinationPayload, S>

  type DestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationCountAggregateInputType | true
    }

  export interface DestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Destination'], meta: { name: 'Destination' } }
    /**
     * Find zero or one Destination that matches the filter.
     * @param {DestinationFindUniqueArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationFindUniqueArgs>(args: SelectSubset<T, DestinationFindUniqueArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Destination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationFindUniqueOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationFindFirstArgs>(args?: SelectSubset<T, DestinationFindFirstArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Destinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinations
     * const destinations = await prisma.destination.findMany()
     * 
     * // Get first 10 Destinations
     * const destinations = await prisma.destination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationWithIdOnly = await prisma.destination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationFindManyArgs>(args?: SelectSubset<T, DestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Destination.
     * @param {DestinationCreateArgs} args - Arguments to create a Destination.
     * @example
     * // Create one Destination
     * const Destination = await prisma.destination.create({
     *   data: {
     *     // ... data to create a Destination
     *   }
     * })
     * 
     */
    create<T extends DestinationCreateArgs>(args: SelectSubset<T, DestinationCreateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Destinations.
     * @param {DestinationCreateManyArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationCreateManyArgs>(args?: SelectSubset<T, DestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Destinations and returns the data saved in the database.
     * @param {DestinationCreateManyAndReturnArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Destination.
     * @param {DestinationDeleteArgs} args - Arguments to delete one Destination.
     * @example
     * // Delete one Destination
     * const Destination = await prisma.destination.delete({
     *   where: {
     *     // ... filter to delete one Destination
     *   }
     * })
     * 
     */
    delete<T extends DestinationDeleteArgs>(args: SelectSubset<T, DestinationDeleteArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Destination.
     * @param {DestinationUpdateArgs} args - Arguments to update one Destination.
     * @example
     * // Update one Destination
     * const destination = await prisma.destination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationUpdateArgs>(args: SelectSubset<T, DestinationUpdateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Destinations.
     * @param {DestinationDeleteManyArgs} args - Arguments to filter Destinations to delete.
     * @example
     * // Delete a few Destinations
     * const { count } = await prisma.destination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationDeleteManyArgs>(args?: SelectSubset<T, DestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationUpdateManyArgs>(args: SelectSubset<T, DestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations and returns the data updated in the database.
     * @param {DestinationUpdateManyAndReturnArgs} args - Arguments to update many Destinations.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Destination.
     * @param {DestinationUpsertArgs} args - Arguments to update or create a Destination.
     * @example
     * // Update or create a Destination
     * const destination = await prisma.destination.upsert({
     *   create: {
     *     // ... data to create a Destination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destination we want to update
     *   }
     * })
     */
    upsert<T extends DestinationUpsertArgs>(args: SelectSubset<T, DestinationUpsertArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationCountArgs} args - Arguments to filter Destinations to count.
     * @example
     * // Count the number of Destinations
     * const count = await prisma.destination.count({
     *   where: {
     *     // ... the filter for the Destinations we want to count
     *   }
     * })
    **/
    count<T extends DestinationCountArgs>(
      args?: Subset<T, DestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationAggregateArgs>(args: Subset<T, DestinationAggregateArgs>): Prisma.PrismaPromise<GetDestinationAggregateType<T>>

    /**
     * Group by Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationGroupByArgs['orderBy'] }
        : { orderBy?: DestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Destination model
   */
  readonly fields: DestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Destination$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Destination$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Destination$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Destination$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Destination model
   */
  interface DestinationFieldRefs {
    readonly id: FieldRef<"Destination", 'Int'>
    readonly name: FieldRef<"Destination", 'String'>
    readonly category: FieldRef<"Destination", 'String'>
    readonly country: FieldRef<"Destination", 'String'>
    readonly region: FieldRef<"Destination", 'String'>
    readonly price: FieldRef<"Destination", 'Decimal'>
    readonly rating: FieldRef<"Destination", 'Int'>
    readonly duration: FieldRef<"Destination", 'String'>
    readonly groupSize: FieldRef<"Destination", 'Int'>
    readonly minTravelers: FieldRef<"Destination", 'Int'>
    readonly maxTravelers: FieldRef<"Destination", 'Int'>
    readonly description: FieldRef<"Destination", 'String'>
    readonly image: FieldRef<"Destination", 'String'>
    readonly images: FieldRef<"Destination", 'String[]'>
    readonly gallery2Images: FieldRef<"Destination", 'String[]'>
    readonly featured: FieldRef<"Destination", 'Boolean'>
    readonly historyTitle: FieldRef<"Destination", 'String'>
    readonly historyContent: FieldRef<"Destination", 'String[]'>
    readonly geographyDescription: FieldRef<"Destination", 'String'>
    readonly geographyClimate: FieldRef<"Destination", 'String'>
    readonly wildlifeDescription: FieldRef<"Destination", 'String'>
    readonly wildlifeMammals: FieldRef<"Destination", 'String[]'>
    readonly wildlifeBirds: FieldRef<"Destination", 'String[]'>
    readonly wildlifeFlora: FieldRef<"Destination", 'String[]'>
    readonly cultureDescription: FieldRef<"Destination", 'String'>
    readonly cultureExperiences: FieldRef<"Destination", 'String[]'>
    readonly bestTimeDescription: FieldRef<"Destination", 'String'>
    readonly drySeasonTitle: FieldRef<"Destination", 'String'>
    readonly drySeasonDescription: FieldRef<"Destination", 'String'>
    readonly wetSeasonTitle: FieldRef<"Destination", 'String'>
    readonly wetSeasonDescription: FieldRef<"Destination", 'String'>
    readonly createdAt: FieldRef<"Destination", 'DateTime'>
    readonly updatedAt: FieldRef<"Destination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Destination findUnique
   */
  export type DestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findUniqueOrThrow
   */
  export type DestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findFirst
   */
  export type DestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findFirstOrThrow
   */
  export type DestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findMany
   */
  export type DestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destinations to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination create
   */
  export type DestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Destination.
     */
    data: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
  }

  /**
   * Destination createMany
   */
  export type DestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination createManyAndReturn
   */
  export type DestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination update
   */
  export type DestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Destination.
     */
    data: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
    /**
     * Choose, which Destination to update.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination updateMany
   */
  export type DestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination updateManyAndReturn
   */
  export type DestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination upsert
   */
  export type DestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Destination to update in case it exists.
     */
    where: DestinationWhereUniqueInput
    /**
     * In case the Destination found by the `where` argument doesn't exist, create a new Destination with this data.
     */
    create: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
    /**
     * In case the Destination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
  }

  /**
   * Destination delete
   */
  export type DestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter which Destination to delete.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination deleteMany
   */
  export type DestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destinations to delete
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to delete.
     */
    limit?: number
  }

  /**
   * Destination.bookings
   */
  export type Destination$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Destination.favorites
   */
  export type Destination$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * Destination without action
   */
  export type DestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    packageId: number | null
    destinationId: number | null
    numberOfTravelers: number | null
    pricePerPerson: Decimal | null
    totalPrice: Decimal | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    packageId: number | null
    destinationId: number | null
    numberOfTravelers: number | null
    pricePerPerson: Decimal | null
    totalPrice: Decimal | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    confirmationNumber: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    country: string | null
    packageId: number | null
    destinationId: number | null
    bookingType: $Enums.BookingType | null
    numberOfTravelers: number | null
    specialRequests: string | null
    travelDateFrom: Date | null
    travelDateTo: Date | null
    pricePerPerson: Decimal | null
    totalPrice: Decimal | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: string | null
    paymentReference: string | null
    paymentIntentId: string | null
    stripeCustomerId: string | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    confirmationNumber: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    country: string | null
    packageId: number | null
    destinationId: number | null
    bookingType: $Enums.BookingType | null
    numberOfTravelers: number | null
    specialRequests: string | null
    travelDateFrom: Date | null
    travelDateTo: Date | null
    pricePerPerson: Decimal | null
    totalPrice: Decimal | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: string | null
    paymentReference: string | null
    paymentIntentId: string | null
    stripeCustomerId: string | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    confirmationNumber: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    country: number
    packageId: number
    destinationId: number
    bookingType: number
    numberOfTravelers: number
    specialRequests: number
    travelDateFrom: number
    travelDateTo: number
    pricePerPerson: number
    totalPrice: number
    status: number
    paymentStatus: number
    paymentMethod: number
    paymentReference: number
    paymentIntentId: number
    stripeCustomerId: number
    adminNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    packageId?: true
    destinationId?: true
    numberOfTravelers?: true
    pricePerPerson?: true
    totalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    packageId?: true
    destinationId?: true
    numberOfTravelers?: true
    pricePerPerson?: true
    totalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    confirmationNumber?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    country?: true
    packageId?: true
    destinationId?: true
    bookingType?: true
    numberOfTravelers?: true
    specialRequests?: true
    travelDateFrom?: true
    travelDateTo?: true
    pricePerPerson?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentReference?: true
    paymentIntentId?: true
    stripeCustomerId?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    confirmationNumber?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    country?: true
    packageId?: true
    destinationId?: true
    bookingType?: true
    numberOfTravelers?: true
    specialRequests?: true
    travelDateFrom?: true
    travelDateTo?: true
    pricePerPerson?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentReference?: true
    paymentIntentId?: true
    stripeCustomerId?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    confirmationNumber?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    country?: true
    packageId?: true
    destinationId?: true
    bookingType?: true
    numberOfTravelers?: true
    specialRequests?: true
    travelDateFrom?: true
    travelDateTo?: true
    pricePerPerson?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentReference?: true
    paymentIntentId?: true
    stripeCustomerId?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    confirmationNumber: string
    userId: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country: string | null
    packageId: number | null
    destinationId: number | null
    bookingType: $Enums.BookingType
    numberOfTravelers: number
    specialRequests: string | null
    travelDateFrom: Date
    travelDateTo: Date
    pricePerPerson: Decimal
    totalPrice: Decimal
    status: $Enums.BookingStatus
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: string | null
    paymentReference: string | null
    paymentIntentId: string | null
    stripeCustomerId: string | null
    adminNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    confirmationNumber?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    country?: boolean
    packageId?: boolean
    destinationId?: boolean
    bookingType?: boolean
    numberOfTravelers?: boolean
    specialRequests?: boolean
    travelDateFrom?: boolean
    travelDateTo?: boolean
    pricePerPerson?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    paymentIntentId?: boolean
    stripeCustomerId?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    confirmationNumber?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    country?: boolean
    packageId?: boolean
    destinationId?: boolean
    bookingType?: boolean
    numberOfTravelers?: boolean
    specialRequests?: boolean
    travelDateFrom?: boolean
    travelDateTo?: boolean
    pricePerPerson?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    paymentIntentId?: boolean
    stripeCustomerId?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    confirmationNumber?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    country?: boolean
    packageId?: boolean
    destinationId?: boolean
    bookingType?: boolean
    numberOfTravelers?: boolean
    specialRequests?: boolean
    travelDateFrom?: boolean
    travelDateTo?: boolean
    pricePerPerson?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    paymentIntentId?: boolean
    stripeCustomerId?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    confirmationNumber?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    country?: boolean
    packageId?: boolean
    destinationId?: boolean
    bookingType?: boolean
    numberOfTravelers?: boolean
    specialRequests?: boolean
    travelDateFrom?: boolean
    travelDateTo?: boolean
    pricePerPerson?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    paymentIntentId?: boolean
    stripeCustomerId?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "confirmationNumber" | "userId" | "firstName" | "lastName" | "email" | "phone" | "country" | "packageId" | "destinationId" | "bookingType" | "numberOfTravelers" | "specialRequests" | "travelDateFrom" | "travelDateTo" | "pricePerPerson" | "totalPrice" | "status" | "paymentStatus" | "paymentMethod" | "paymentReference" | "paymentIntentId" | "stripeCustomerId" | "adminNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Booking$destinationArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs> | null
      package: Prisma.$PackagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      confirmationNumber: string
      userId: string | null
      firstName: string
      lastName: string
      email: string
      phone: string
      country: string | null
      packageId: number | null
      destinationId: number | null
      bookingType: $Enums.BookingType
      numberOfTravelers: number
      specialRequests: string | null
      travelDateFrom: Date
      travelDateTo: Date
      pricePerPerson: Prisma.Decimal
      totalPrice: Prisma.Decimal
      status: $Enums.BookingStatus
      paymentStatus: $Enums.PaymentStatus
      paymentMethod: string | null
      paymentReference: string | null
      paymentIntentId: string | null
      stripeCustomerId: string | null
      adminNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends Booking$destinationArgs<ExtArgs> = {}>(args?: Subset<T, Booking$destinationArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    package<T extends Booking$packageArgs<ExtArgs> = {}>(args?: Subset<T, Booking$packageArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly confirmationNumber: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly firstName: FieldRef<"Booking", 'String'>
    readonly lastName: FieldRef<"Booking", 'String'>
    readonly email: FieldRef<"Booking", 'String'>
    readonly phone: FieldRef<"Booking", 'String'>
    readonly country: FieldRef<"Booking", 'String'>
    readonly packageId: FieldRef<"Booking", 'Int'>
    readonly destinationId: FieldRef<"Booking", 'Int'>
    readonly bookingType: FieldRef<"Booking", 'BookingType'>
    readonly numberOfTravelers: FieldRef<"Booking", 'Int'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly travelDateFrom: FieldRef<"Booking", 'DateTime'>
    readonly travelDateTo: FieldRef<"Booking", 'DateTime'>
    readonly pricePerPerson: FieldRef<"Booking", 'Decimal'>
    readonly totalPrice: FieldRef<"Booking", 'Decimal'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly paymentStatus: FieldRef<"Booking", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Booking", 'String'>
    readonly paymentReference: FieldRef<"Booking", 'String'>
    readonly paymentIntentId: FieldRef<"Booking", 'String'>
    readonly stripeCustomerId: FieldRef<"Booking", 'String'>
    readonly adminNotes: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.destination
   */
  export type Booking$destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
  }

  /**
   * Booking.package
   */
  export type Booking$packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model ContactInquiry
   */

  export type AggregateContactInquiry = {
    _count: ContactInquiryCountAggregateOutputType | null
    _avg: ContactInquiryAvgAggregateOutputType | null
    _sum: ContactInquirySumAggregateOutputType | null
    _min: ContactInquiryMinAggregateOutputType | null
    _max: ContactInquiryMaxAggregateOutputType | null
  }

  export type ContactInquiryAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactInquirySumAggregateOutputType = {
    id: number | null
  }

  export type ContactInquiryMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    responseNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInquiryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    responseNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInquiryCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    status: number
    responseNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactInquiryAvgAggregateInputType = {
    id?: true
  }

  export type ContactInquirySumAggregateInputType = {
    id?: true
  }

  export type ContactInquiryMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    status?: true
    responseNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInquiryMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    status?: true
    responseNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInquiryCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    status?: true
    responseNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactInquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInquiry to aggregate.
     */
    where?: ContactInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInquiries to fetch.
     */
    orderBy?: ContactInquiryOrderByWithRelationInput | ContactInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInquiries
    **/
    _count?: true | ContactInquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactInquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactInquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInquiryMaxAggregateInputType
  }

  export type GetContactInquiryAggregateType<T extends ContactInquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInquiry[P]>
      : GetScalarType<T[P], AggregateContactInquiry[P]>
  }




  export type ContactInquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInquiryWhereInput
    orderBy?: ContactInquiryOrderByWithAggregationInput | ContactInquiryOrderByWithAggregationInput[]
    by: ContactInquiryScalarFieldEnum[] | ContactInquiryScalarFieldEnum
    having?: ContactInquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInquiryCountAggregateInputType | true
    _avg?: ContactInquiryAvgAggregateInputType
    _sum?: ContactInquirySumAggregateInputType
    _min?: ContactInquiryMinAggregateInputType
    _max?: ContactInquiryMaxAggregateInputType
  }

  export type ContactInquiryGroupByOutputType = {
    id: number
    name: string
    email: string
    subject: string
    message: string
    status: $Enums.InquiryStatus
    responseNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactInquiryCountAggregateOutputType | null
    _avg: ContactInquiryAvgAggregateOutputType | null
    _sum: ContactInquirySumAggregateOutputType | null
    _min: ContactInquiryMinAggregateOutputType | null
    _max: ContactInquiryMaxAggregateOutputType | null
  }

  type GetContactInquiryGroupByPayload<T extends ContactInquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInquiryGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInquiryGroupByOutputType[P]>
        }
      >
    >


  export type ContactInquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responseNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInquiry"]>

  export type ContactInquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responseNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInquiry"]>

  export type ContactInquirySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responseNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInquiry"]>

  export type ContactInquirySelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responseNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "status" | "responseNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["contactInquiry"]>

  export type $ContactInquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInquiry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      subject: string
      message: string
      status: $Enums.InquiryStatus
      responseNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactInquiry"]>
    composites: {}
  }

  type ContactInquiryGetPayload<S extends boolean | null | undefined | ContactInquiryDefaultArgs> = $Result.GetResult<Prisma.$ContactInquiryPayload, S>

  type ContactInquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactInquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactInquiryCountAggregateInputType | true
    }

  export interface ContactInquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInquiry'], meta: { name: 'ContactInquiry' } }
    /**
     * Find zero or one ContactInquiry that matches the filter.
     * @param {ContactInquiryFindUniqueArgs} args - Arguments to find a ContactInquiry
     * @example
     * // Get one ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactInquiryFindUniqueArgs>(args: SelectSubset<T, ContactInquiryFindUniqueArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactInquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactInquiryFindUniqueOrThrowArgs} args - Arguments to find a ContactInquiry
     * @example
     * // Get one ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactInquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactInquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryFindFirstArgs} args - Arguments to find a ContactInquiry
     * @example
     * // Get one ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactInquiryFindFirstArgs>(args?: SelectSubset<T, ContactInquiryFindFirstArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryFindFirstOrThrowArgs} args - Arguments to find a ContactInquiry
     * @example
     * // Get one ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactInquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactInquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInquiries
     * const contactInquiries = await prisma.contactInquiry.findMany()
     * 
     * // Get first 10 ContactInquiries
     * const contactInquiries = await prisma.contactInquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInquiryWithIdOnly = await prisma.contactInquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactInquiryFindManyArgs>(args?: SelectSubset<T, ContactInquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactInquiry.
     * @param {ContactInquiryCreateArgs} args - Arguments to create a ContactInquiry.
     * @example
     * // Create one ContactInquiry
     * const ContactInquiry = await prisma.contactInquiry.create({
     *   data: {
     *     // ... data to create a ContactInquiry
     *   }
     * })
     * 
     */
    create<T extends ContactInquiryCreateArgs>(args: SelectSubset<T, ContactInquiryCreateArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactInquiries.
     * @param {ContactInquiryCreateManyArgs} args - Arguments to create many ContactInquiries.
     * @example
     * // Create many ContactInquiries
     * const contactInquiry = await prisma.contactInquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactInquiryCreateManyArgs>(args?: SelectSubset<T, ContactInquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactInquiries and returns the data saved in the database.
     * @param {ContactInquiryCreateManyAndReturnArgs} args - Arguments to create many ContactInquiries.
     * @example
     * // Create many ContactInquiries
     * const contactInquiry = await prisma.contactInquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactInquiries and only return the `id`
     * const contactInquiryWithIdOnly = await prisma.contactInquiry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactInquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactInquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactInquiry.
     * @param {ContactInquiryDeleteArgs} args - Arguments to delete one ContactInquiry.
     * @example
     * // Delete one ContactInquiry
     * const ContactInquiry = await prisma.contactInquiry.delete({
     *   where: {
     *     // ... filter to delete one ContactInquiry
     *   }
     * })
     * 
     */
    delete<T extends ContactInquiryDeleteArgs>(args: SelectSubset<T, ContactInquiryDeleteArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactInquiry.
     * @param {ContactInquiryUpdateArgs} args - Arguments to update one ContactInquiry.
     * @example
     * // Update one ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactInquiryUpdateArgs>(args: SelectSubset<T, ContactInquiryUpdateArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactInquiries.
     * @param {ContactInquiryDeleteManyArgs} args - Arguments to filter ContactInquiries to delete.
     * @example
     * // Delete a few ContactInquiries
     * const { count } = await prisma.contactInquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactInquiryDeleteManyArgs>(args?: SelectSubset<T, ContactInquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInquiries
     * const contactInquiry = await prisma.contactInquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactInquiryUpdateManyArgs>(args: SelectSubset<T, ContactInquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInquiries and returns the data updated in the database.
     * @param {ContactInquiryUpdateManyAndReturnArgs} args - Arguments to update many ContactInquiries.
     * @example
     * // Update many ContactInquiries
     * const contactInquiry = await prisma.contactInquiry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactInquiries and only return the `id`
     * const contactInquiryWithIdOnly = await prisma.contactInquiry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactInquiryUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactInquiryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactInquiry.
     * @param {ContactInquiryUpsertArgs} args - Arguments to update or create a ContactInquiry.
     * @example
     * // Update or create a ContactInquiry
     * const contactInquiry = await prisma.contactInquiry.upsert({
     *   create: {
     *     // ... data to create a ContactInquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInquiry we want to update
     *   }
     * })
     */
    upsert<T extends ContactInquiryUpsertArgs>(args: SelectSubset<T, ContactInquiryUpsertArgs<ExtArgs>>): Prisma__ContactInquiryClient<$Result.GetResult<Prisma.$ContactInquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryCountArgs} args - Arguments to filter ContactInquiries to count.
     * @example
     * // Count the number of ContactInquiries
     * const count = await prisma.contactInquiry.count({
     *   where: {
     *     // ... the filter for the ContactInquiries we want to count
     *   }
     * })
    **/
    count<T extends ContactInquiryCountArgs>(
      args?: Subset<T, ContactInquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInquiryAggregateArgs>(args: Subset<T, ContactInquiryAggregateArgs>): Prisma.PrismaPromise<GetContactInquiryAggregateType<T>>

    /**
     * Group by ContactInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInquiryGroupByArgs['orderBy'] }
        : { orderBy?: ContactInquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInquiry model
   */
  readonly fields: ContactInquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactInquiry model
   */
  interface ContactInquiryFieldRefs {
    readonly id: FieldRef<"ContactInquiry", 'Int'>
    readonly name: FieldRef<"ContactInquiry", 'String'>
    readonly email: FieldRef<"ContactInquiry", 'String'>
    readonly subject: FieldRef<"ContactInquiry", 'String'>
    readonly message: FieldRef<"ContactInquiry", 'String'>
    readonly status: FieldRef<"ContactInquiry", 'InquiryStatus'>
    readonly responseNotes: FieldRef<"ContactInquiry", 'String'>
    readonly createdAt: FieldRef<"ContactInquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactInquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactInquiry findUnique
   */
  export type ContactInquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ContactInquiry to fetch.
     */
    where: ContactInquiryWhereUniqueInput
  }

  /**
   * ContactInquiry findUniqueOrThrow
   */
  export type ContactInquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ContactInquiry to fetch.
     */
    where: ContactInquiryWhereUniqueInput
  }

  /**
   * ContactInquiry findFirst
   */
  export type ContactInquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ContactInquiry to fetch.
     */
    where?: ContactInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInquiries to fetch.
     */
    orderBy?: ContactInquiryOrderByWithRelationInput | ContactInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInquiries.
     */
    cursor?: ContactInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInquiries.
     */
    distinct?: ContactInquiryScalarFieldEnum | ContactInquiryScalarFieldEnum[]
  }

  /**
   * ContactInquiry findFirstOrThrow
   */
  export type ContactInquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ContactInquiry to fetch.
     */
    where?: ContactInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInquiries to fetch.
     */
    orderBy?: ContactInquiryOrderByWithRelationInput | ContactInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInquiries.
     */
    cursor?: ContactInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInquiries.
     */
    distinct?: ContactInquiryScalarFieldEnum | ContactInquiryScalarFieldEnum[]
  }

  /**
   * ContactInquiry findMany
   */
  export type ContactInquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ContactInquiries to fetch.
     */
    where?: ContactInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInquiries to fetch.
     */
    orderBy?: ContactInquiryOrderByWithRelationInput | ContactInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInquiries.
     */
    cursor?: ContactInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInquiries.
     */
    skip?: number
    distinct?: ContactInquiryScalarFieldEnum | ContactInquiryScalarFieldEnum[]
  }

  /**
   * ContactInquiry create
   */
  export type ContactInquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactInquiry.
     */
    data: XOR<ContactInquiryCreateInput, ContactInquiryUncheckedCreateInput>
  }

  /**
   * ContactInquiry createMany
   */
  export type ContactInquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInquiries.
     */
    data: ContactInquiryCreateManyInput | ContactInquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInquiry createManyAndReturn
   */
  export type ContactInquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * The data used to create many ContactInquiries.
     */
    data: ContactInquiryCreateManyInput | ContactInquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInquiry update
   */
  export type ContactInquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactInquiry.
     */
    data: XOR<ContactInquiryUpdateInput, ContactInquiryUncheckedUpdateInput>
    /**
     * Choose, which ContactInquiry to update.
     */
    where: ContactInquiryWhereUniqueInput
  }

  /**
   * ContactInquiry updateMany
   */
  export type ContactInquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInquiries.
     */
    data: XOR<ContactInquiryUpdateManyMutationInput, ContactInquiryUncheckedUpdateManyInput>
    /**
     * Filter which ContactInquiries to update
     */
    where?: ContactInquiryWhereInput
    /**
     * Limit how many ContactInquiries to update.
     */
    limit?: number
  }

  /**
   * ContactInquiry updateManyAndReturn
   */
  export type ContactInquiryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * The data used to update ContactInquiries.
     */
    data: XOR<ContactInquiryUpdateManyMutationInput, ContactInquiryUncheckedUpdateManyInput>
    /**
     * Filter which ContactInquiries to update
     */
    where?: ContactInquiryWhereInput
    /**
     * Limit how many ContactInquiries to update.
     */
    limit?: number
  }

  /**
   * ContactInquiry upsert
   */
  export type ContactInquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactInquiry to update in case it exists.
     */
    where: ContactInquiryWhereUniqueInput
    /**
     * In case the ContactInquiry found by the `where` argument doesn't exist, create a new ContactInquiry with this data.
     */
    create: XOR<ContactInquiryCreateInput, ContactInquiryUncheckedCreateInput>
    /**
     * In case the ContactInquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInquiryUpdateInput, ContactInquiryUncheckedUpdateInput>
  }

  /**
   * ContactInquiry delete
   */
  export type ContactInquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
    /**
     * Filter which ContactInquiry to delete.
     */
    where: ContactInquiryWhereUniqueInput
  }

  /**
   * ContactInquiry deleteMany
   */
  export type ContactInquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInquiries to delete
     */
    where?: ContactInquiryWhereInput
    /**
     * Limit how many ContactInquiries to delete.
     */
    limit?: number
  }

  /**
   * ContactInquiry without action
   */
  export type ContactInquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInquiry
     */
    select?: ContactInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInquiry
     */
    omit?: ContactInquiryOmit<ExtArgs> | null
  }


  /**
   * Model NewsletterSubscription
   */

  export type AggregateNewsletterSubscription = {
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _avg: NewsletterSubscriptionAvgAggregateOutputType | null
    _sum: NewsletterSubscriptionSumAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  export type NewsletterSubscriptionAvgAggregateOutputType = {
    id: number | null
  }

  export type NewsletterSubscriptionSumAggregateOutputType = {
    id: number | null
  }

  export type NewsletterSubscriptionMinAggregateOutputType = {
    id: number | null
    email: string | null
    status: $Enums.SubscriptionStatus | null
    subscribedAt: Date | null
    unsubscribedAt: Date | null
  }

  export type NewsletterSubscriptionMaxAggregateOutputType = {
    id: number | null
    email: string | null
    status: $Enums.SubscriptionStatus | null
    subscribedAt: Date | null
    unsubscribedAt: Date | null
  }

  export type NewsletterSubscriptionCountAggregateOutputType = {
    id: number
    email: number
    status: number
    subscribedAt: number
    unsubscribedAt: number
    _all: number
  }


  export type NewsletterSubscriptionAvgAggregateInputType = {
    id?: true
  }

  export type NewsletterSubscriptionSumAggregateInputType = {
    id?: true
  }

  export type NewsletterSubscriptionMinAggregateInputType = {
    id?: true
    email?: true
    status?: true
    subscribedAt?: true
    unsubscribedAt?: true
  }

  export type NewsletterSubscriptionMaxAggregateInputType = {
    id?: true
    email?: true
    status?: true
    subscribedAt?: true
    unsubscribedAt?: true
  }

  export type NewsletterSubscriptionCountAggregateInputType = {
    id?: true
    email?: true
    status?: true
    subscribedAt?: true
    unsubscribedAt?: true
    _all?: true
  }

  export type NewsletterSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscription to aggregate.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterSubscriptions
    **/
    _count?: true | NewsletterSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsletterSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsletterSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type GetNewsletterSubscriptionAggregateType<T extends NewsletterSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
      : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
  }




  export type NewsletterSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriptionWhereInput
    orderBy?: NewsletterSubscriptionOrderByWithAggregationInput | NewsletterSubscriptionOrderByWithAggregationInput[]
    by: NewsletterSubscriptionScalarFieldEnum[] | NewsletterSubscriptionScalarFieldEnum
    having?: NewsletterSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterSubscriptionCountAggregateInputType | true
    _avg?: NewsletterSubscriptionAvgAggregateInputType
    _sum?: NewsletterSubscriptionSumAggregateInputType
    _min?: NewsletterSubscriptionMinAggregateInputType
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type NewsletterSubscriptionGroupByOutputType = {
    id: number
    email: string
    status: $Enums.SubscriptionStatus
    subscribedAt: Date
    unsubscribedAt: Date | null
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _avg: NewsletterSubscriptionAvgAggregateOutputType | null
    _sum: NewsletterSubscriptionSumAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  type GetNewsletterSubscriptionGroupByPayload<T extends NewsletterSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    status?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    status?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    status?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectScalar = {
    id?: boolean
    email?: boolean
    status?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
  }

  export type NewsletterSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "status" | "subscribedAt" | "unsubscribedAt", ExtArgs["result"]["newsletterSubscription"]>

  export type $NewsletterSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterSubscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      status: $Enums.SubscriptionStatus
      subscribedAt: Date
      unsubscribedAt: Date | null
    }, ExtArgs["result"]["newsletterSubscription"]>
    composites: {}
  }

  type NewsletterSubscriptionGetPayload<S extends boolean | null | undefined | NewsletterSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$NewsletterSubscriptionPayload, S>

  type NewsletterSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterSubscriptionCountAggregateInputType | true
    }

  export interface NewsletterSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterSubscription'], meta: { name: 'NewsletterSubscription' } }
    /**
     * Find zero or one NewsletterSubscription that matches the filter.
     * @param {NewsletterSubscriptionFindUniqueArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterSubscriptionFindUniqueArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsletterSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterSubscriptionFindFirstArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsletterSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
     * 
     * // Get first 10 NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterSubscriptionFindManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsletterSubscription.
     * @param {NewsletterSubscriptionCreateArgs} args - Arguments to create a NewsletterSubscription.
     * @example
     * // Create one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.create({
     *   data: {
     *     // ... data to create a NewsletterSubscription
     *   }
     * })
     * 
     */
    create<T extends NewsletterSubscriptionCreateArgs>(args: SelectSubset<T, NewsletterSubscriptionCreateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsletterSubscriptions.
     * @param {NewsletterSubscriptionCreateManyArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterSubscriptionCreateManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterSubscriptions and returns the data saved in the database.
     * @param {NewsletterSubscriptionCreateManyAndReturnArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterSubscriptions and only return the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsletterSubscription.
     * @param {NewsletterSubscriptionDeleteArgs} args - Arguments to delete one NewsletterSubscription.
     * @example
     * // Delete one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.delete({
     *   where: {
     *     // ... filter to delete one NewsletterSubscription
     *   }
     * })
     * 
     */
    delete<T extends NewsletterSubscriptionDeleteArgs>(args: SelectSubset<T, NewsletterSubscriptionDeleteArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpdateArgs} args - Arguments to update one NewsletterSubscription.
     * @example
     * // Update one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterSubscriptionUpdateArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsletterSubscriptions.
     * @param {NewsletterSubscriptionDeleteManyArgs} args - Arguments to filter NewsletterSubscriptions to delete.
     * @example
     * // Delete a few NewsletterSubscriptions
     * const { count } = await prisma.newsletterSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterSubscriptionDeleteManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterSubscriptionUpdateManyArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscriptions and returns the data updated in the database.
     * @param {NewsletterSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many NewsletterSubscriptions.
     * @example
     * // Update many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsletterSubscriptions and only return the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsletterSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpsertArgs} args - Arguments to update or create a NewsletterSubscription.
     * @example
     * // Update or create a NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.upsert({
     *   create: {
     *     // ... data to create a NewsletterSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterSubscription we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterSubscriptionUpsertArgs>(args: SelectSubset<T, NewsletterSubscriptionUpsertArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionCountArgs} args - Arguments to filter NewsletterSubscriptions to count.
     * @example
     * // Count the number of NewsletterSubscriptions
     * const count = await prisma.newsletterSubscription.count({
     *   where: {
     *     // ... the filter for the NewsletterSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NewsletterSubscriptionCountArgs>(
      args?: Subset<T, NewsletterSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterSubscriptionAggregateArgs>(args: Subset<T, NewsletterSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetNewsletterSubscriptionAggregateType<T>>

    /**
     * Group by NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterSubscription model
   */
  readonly fields: NewsletterSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterSubscription model
   */
  interface NewsletterSubscriptionFieldRefs {
    readonly id: FieldRef<"NewsletterSubscription", 'Int'>
    readonly email: FieldRef<"NewsletterSubscription", 'String'>
    readonly status: FieldRef<"NewsletterSubscription", 'SubscriptionStatus'>
    readonly subscribedAt: FieldRef<"NewsletterSubscription", 'DateTime'>
    readonly unsubscribedAt: FieldRef<"NewsletterSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterSubscription findUnique
   */
  export type NewsletterSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findUniqueOrThrow
   */
  export type NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findFirst
   */
  export type NewsletterSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findFirstOrThrow
   */
  export type NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findMany
   */
  export type NewsletterSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriptions to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription create
   */
  export type NewsletterSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
  }

  /**
   * NewsletterSubscription createMany
   */
  export type NewsletterSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscription createManyAndReturn
   */
  export type NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscription update
   */
  export type NewsletterSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which NewsletterSubscription to update.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription updateMany
   */
  export type NewsletterSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterSubscriptions.
     */
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscriptions to update
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription updateManyAndReturn
   */
  export type NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update NewsletterSubscriptions.
     */
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscriptions to update
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription upsert
   */
  export type NewsletterSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the NewsletterSubscription to update in case it exists.
     */
    where: NewsletterSubscriptionWhereUniqueInput
    /**
     * In case the NewsletterSubscription found by the `where` argument doesn't exist, create a new NewsletterSubscription with this data.
     */
    create: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
    /**
     * In case the NewsletterSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
  }

  /**
   * NewsletterSubscription delete
   */
  export type NewsletterSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter which NewsletterSubscription to delete.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription deleteMany
   */
  export type NewsletterSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscriptions to delete
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription without action
   */
  export type NewsletterSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    profileImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    profileImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    phone: number
    profileImageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    profileImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    customPackages?: boolean | User$customPackagesArgs<ExtArgs>
    packageBundles?: boolean | User$packageBundlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "phone" | "profileImageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    customPackages?: boolean | User$customPackagesArgs<ExtArgs>
    packageBundles?: boolean | User$packageBundlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      favorites: Prisma.$UserFavoritePayload<ExtArgs>[]
      customPackages: Prisma.$CustomPackagePayload<ExtArgs>[]
      packageBundles: Prisma.$PackageBundlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      profileImageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customPackages<T extends User$customPackagesArgs<ExtArgs> = {}>(args?: Subset<T, User$customPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packageBundles<T extends User$packageBundlesArgs<ExtArgs> = {}>(args?: Subset<T, User$packageBundlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly profileImageUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User.customPackages
   */
  export type User$customPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    where?: CustomPackageWhereInput
    orderBy?: CustomPackageOrderByWithRelationInput | CustomPackageOrderByWithRelationInput[]
    cursor?: CustomPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPackageScalarFieldEnum | CustomPackageScalarFieldEnum[]
  }

  /**
   * User.packageBundles
   */
  export type User$packageBundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    where?: PackageBundleWhereInput
    orderBy?: PackageBundleOrderByWithRelationInput | PackageBundleOrderByWithRelationInput[]
    cursor?: PackageBundleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageBundleScalarFieldEnum | PackageBundleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteAvgAggregateOutputType = {
    id: number | null
    destinationId: number | null
  }

  export type UserFavoriteSumAggregateOutputType = {
    id: number | null
    destinationId: number | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    id: number | null
    userId: string | null
    destinationId: number | null
    createdAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    destinationId: number | null
    createdAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    id: number
    userId: number
    destinationId: number
    createdAt: number
    _all: number
  }


  export type UserFavoriteAvgAggregateInputType = {
    id?: true
    destinationId?: true
  }

  export type UserFavoriteSumAggregateInputType = {
    id?: true
    destinationId?: true
  }

  export type UserFavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    createdAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    createdAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _avg?: UserFavoriteAvgAggregateInputType
    _sum?: UserFavoriteSumAggregateInputType
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    id: number
    userId: string
    destinationId: number
    createdAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    createdAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    createdAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    createdAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    createdAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "destinationId" | "createdAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      destinationId: number
      createdAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly id: FieldRef<"UserFavorite", 'Int'>
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly destinationId: FieldRef<"UserFavorite", 'Int'>
    readonly createdAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    minTravelers: number | null
    maxTravelers: number | null
    displayOrder: number | null
  }

  export type PackageSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    minTravelers: number | null
    maxTravelers: number | null
    displayOrder: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    category: string | null
    duration: string | null
    price: Decimal | null
    description: string | null
    shortDesc: string | null
    image: string | null
    minTravelers: number | null
    maxTravelers: number | null
    difficulty: $Enums.DifficultyLevel | null
    featured: boolean | null
    popular: boolean | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    category: string | null
    duration: string | null
    price: Decimal | null
    description: string | null
    shortDesc: string | null
    image: string | null
    minTravelers: number | null
    maxTravelers: number | null
    difficulty: $Enums.DifficultyLevel | null
    featured: boolean | null
    popular: boolean | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    category: number
    duration: number
    price: number
    description: number
    shortDesc: number
    image: number
    images: number
    gallery2Images: number
    highlights: number
    itinerary: number
    included: number
    excluded: number
    minTravelers: number
    maxTravelers: number
    difficulty: number
    featured: number
    popular: number
    active: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    id?: true
    price?: true
    minTravelers?: true
    maxTravelers?: true
    displayOrder?: true
  }

  export type PackageSumAggregateInputType = {
    id?: true
    price?: true
    minTravelers?: true
    maxTravelers?: true
    displayOrder?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    duration?: true
    price?: true
    description?: true
    shortDesc?: true
    image?: true
    minTravelers?: true
    maxTravelers?: true
    difficulty?: true
    featured?: true
    popular?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    duration?: true
    price?: true
    description?: true
    shortDesc?: true
    image?: true
    minTravelers?: true
    maxTravelers?: true
    difficulty?: true
    featured?: true
    popular?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    duration?: true
    price?: true
    description?: true
    shortDesc?: true
    image?: true
    images?: true
    gallery2Images?: true
    highlights?: true
    itinerary?: true
    included?: true
    excluded?: true
    minTravelers?: true
    maxTravelers?: true
    difficulty?: true
    featured?: true
    popular?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: number
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal
    description: string
    shortDesc: string | null
    image: string
    images: string[]
    gallery2Images: string[]
    highlights: string[]
    itinerary: JsonValue
    included: string[]
    excluded: string[]
    minTravelers: number
    maxTravelers: number
    difficulty: $Enums.DifficultyLevel
    featured: boolean
    popular: boolean
    active: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    shortDesc?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    highlights?: boolean
    itinerary?: boolean
    included?: boolean
    excluded?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    difficulty?: boolean
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Package$bookingsArgs<ExtArgs>
    bundleItems?: boolean | Package$bundleItemsArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    shortDesc?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    highlights?: boolean
    itinerary?: boolean
    included?: boolean
    excluded?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    difficulty?: boolean
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["package"]>

  export type PackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    shortDesc?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    highlights?: boolean
    itinerary?: boolean
    included?: boolean
    excluded?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    difficulty?: boolean
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    shortDesc?: boolean
    image?: boolean
    images?: boolean
    gallery2Images?: boolean
    highlights?: boolean
    itinerary?: boolean
    included?: boolean
    excluded?: boolean
    minTravelers?: boolean
    maxTravelers?: boolean
    difficulty?: boolean
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "category" | "duration" | "price" | "description" | "shortDesc" | "image" | "images" | "gallery2Images" | "highlights" | "itinerary" | "included" | "excluded" | "minTravelers" | "maxTravelers" | "difficulty" | "featured" | "popular" | "active" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["package"]>
  export type PackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Package$bookingsArgs<ExtArgs>
    bundleItems?: boolean | Package$bundleItemsArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      bundleItems: Prisma.$PackageBundleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      category: string
      duration: string
      price: Prisma.Decimal
      description: string
      shortDesc: string | null
      image: string
      images: string[]
      gallery2Images: string[]
      highlights: string[]
      itinerary: Prisma.JsonValue
      included: string[]
      excluded: string[]
      minTravelers: number
      maxTravelers: number
      difficulty: $Enums.DifficultyLevel
      featured: boolean
      popular: boolean
      active: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {PackageCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {PackageUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Package$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Package$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bundleItems<T extends Package$bundleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Package$bundleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'Int'>
    readonly name: FieldRef<"Package", 'String'>
    readonly slug: FieldRef<"Package", 'String'>
    readonly category: FieldRef<"Package", 'String'>
    readonly duration: FieldRef<"Package", 'String'>
    readonly price: FieldRef<"Package", 'Decimal'>
    readonly description: FieldRef<"Package", 'String'>
    readonly shortDesc: FieldRef<"Package", 'String'>
    readonly image: FieldRef<"Package", 'String'>
    readonly images: FieldRef<"Package", 'String[]'>
    readonly gallery2Images: FieldRef<"Package", 'String[]'>
    readonly highlights: FieldRef<"Package", 'String[]'>
    readonly itinerary: FieldRef<"Package", 'Json'>
    readonly included: FieldRef<"Package", 'String[]'>
    readonly excluded: FieldRef<"Package", 'String[]'>
    readonly minTravelers: FieldRef<"Package", 'Int'>
    readonly maxTravelers: FieldRef<"Package", 'Int'>
    readonly difficulty: FieldRef<"Package", 'DifficultyLevel'>
    readonly featured: FieldRef<"Package", 'Boolean'>
    readonly popular: FieldRef<"Package", 'Boolean'>
    readonly active: FieldRef<"Package", 'Boolean'>
    readonly displayOrder: FieldRef<"Package", 'Int'>
    readonly createdAt: FieldRef<"Package", 'DateTime'>
    readonly updatedAt: FieldRef<"Package", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package createManyAndReturn
   */
  export type PackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package updateManyAndReturn
   */
  export type PackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package.bookings
   */
  export type Package$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Package.bundleItems
   */
  export type Package$bundleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    where?: PackageBundleItemWhereInput
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    cursor?: PackageBundleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageBundleItemScalarFieldEnum | PackageBundleItemScalarFieldEnum[]
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
  }


  /**
   * Model CustomPackage
   */

  export type AggregateCustomPackage = {
    _count: CustomPackageCountAggregateOutputType | null
    _avg: CustomPackageAvgAggregateOutputType | null
    _sum: CustomPackageSumAggregateOutputType | null
    _min: CustomPackageMinAggregateOutputType | null
    _max: CustomPackageMaxAggregateOutputType | null
  }

  export type CustomPackageAvgAggregateOutputType = {
    id: number | null
    numberOfPeople: number | null
    budget: Decimal | null
    quotedPrice: Decimal | null
  }

  export type CustomPackageSumAggregateOutputType = {
    id: number | null
    numberOfPeople: number | null
    budget: Decimal | null
    quotedPrice: Decimal | null
  }

  export type CustomPackageMinAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    duration: string | null
    numberOfPeople: number | null
    travelDate: Date | null
    specialRequests: string | null
    budget: Decimal | null
    status: $Enums.CustomPackageStatus | null
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomPackageMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    duration: string | null
    numberOfPeople: number | null
    travelDate: Date | null
    specialRequests: string | null
    budget: Decimal | null
    status: $Enums.CustomPackageStatus | null
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomPackageCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    contactName: number
    email: number
    phone: number
    destinations: number
    duration: number
    numberOfPeople: number
    travelDate: number
    specialRequests: number
    budget: number
    status: number
    quotedPrice: number
    quoteNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomPackageAvgAggregateInputType = {
    id?: true
    numberOfPeople?: true
    budget?: true
    quotedPrice?: true
  }

  export type CustomPackageSumAggregateInputType = {
    id?: true
    numberOfPeople?: true
    budget?: true
    quotedPrice?: true
  }

  export type CustomPackageMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contactName?: true
    email?: true
    phone?: true
    duration?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    budget?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomPackageMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contactName?: true
    email?: true
    phone?: true
    duration?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    budget?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomPackageCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contactName?: true
    email?: true
    phone?: true
    destinations?: true
    duration?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    budget?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPackage to aggregate.
     */
    where?: CustomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPackages to fetch.
     */
    orderBy?: CustomPackageOrderByWithRelationInput | CustomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomPackages
    **/
    _count?: true | CustomPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomPackageMaxAggregateInputType
  }

  export type GetCustomPackageAggregateType<T extends CustomPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomPackage[P]>
      : GetScalarType<T[P], AggregateCustomPackage[P]>
  }




  export type CustomPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPackageWhereInput
    orderBy?: CustomPackageOrderByWithAggregationInput | CustomPackageOrderByWithAggregationInput[]
    by: CustomPackageScalarFieldEnum[] | CustomPackageScalarFieldEnum
    having?: CustomPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomPackageCountAggregateInputType | true
    _avg?: CustomPackageAvgAggregateInputType
    _sum?: CustomPackageSumAggregateInputType
    _min?: CustomPackageMinAggregateInputType
    _max?: CustomPackageMaxAggregateInputType
  }

  export type CustomPackageGroupByOutputType = {
    id: number
    userId: string
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonValue
    duration: string | null
    numberOfPeople: number
    travelDate: Date | null
    specialRequests: string | null
    budget: Decimal | null
    status: $Enums.CustomPackageStatus
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomPackageCountAggregateOutputType | null
    _avg: CustomPackageAvgAggregateOutputType | null
    _sum: CustomPackageSumAggregateOutputType | null
    _min: CustomPackageMinAggregateOutputType | null
    _max: CustomPackageMaxAggregateOutputType | null
  }

  type GetCustomPackageGroupByPayload<T extends CustomPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomPackageGroupByOutputType[P]>
            : GetScalarType<T[P], CustomPackageGroupByOutputType[P]>
        }
      >
    >


  export type CustomPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    destinations?: boolean
    duration?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    budget?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPackage"]>

  export type CustomPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    destinations?: boolean
    duration?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    budget?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPackage"]>

  export type CustomPackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    destinations?: boolean
    duration?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    budget?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPackage"]>

  export type CustomPackageSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    destinations?: boolean
    duration?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    budget?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "contactName" | "email" | "phone" | "destinations" | "duration" | "numberOfPeople" | "travelDate" | "specialRequests" | "budget" | "status" | "quotedPrice" | "quoteNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["customPackage"]>
  export type CustomPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomPackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomPackage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      name: string
      contactName: string
      email: string
      phone: string
      destinations: Prisma.JsonValue
      duration: string | null
      numberOfPeople: number
      travelDate: Date | null
      specialRequests: string | null
      budget: Prisma.Decimal | null
      status: $Enums.CustomPackageStatus
      quotedPrice: Prisma.Decimal | null
      quoteNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customPackage"]>
    composites: {}
  }

  type CustomPackageGetPayload<S extends boolean | null | undefined | CustomPackageDefaultArgs> = $Result.GetResult<Prisma.$CustomPackagePayload, S>

  type CustomPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomPackageCountAggregateInputType | true
    }

  export interface CustomPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomPackage'], meta: { name: 'CustomPackage' } }
    /**
     * Find zero or one CustomPackage that matches the filter.
     * @param {CustomPackageFindUniqueArgs} args - Arguments to find a CustomPackage
     * @example
     * // Get one CustomPackage
     * const customPackage = await prisma.customPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomPackageFindUniqueArgs>(args: SelectSubset<T, CustomPackageFindUniqueArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomPackageFindUniqueOrThrowArgs} args - Arguments to find a CustomPackage
     * @example
     * // Get one CustomPackage
     * const customPackage = await prisma.customPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageFindFirstArgs} args - Arguments to find a CustomPackage
     * @example
     * // Get one CustomPackage
     * const customPackage = await prisma.customPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomPackageFindFirstArgs>(args?: SelectSubset<T, CustomPackageFindFirstArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageFindFirstOrThrowArgs} args - Arguments to find a CustomPackage
     * @example
     * // Get one CustomPackage
     * const customPackage = await prisma.customPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomPackages
     * const customPackages = await prisma.customPackage.findMany()
     * 
     * // Get first 10 CustomPackages
     * const customPackages = await prisma.customPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customPackageWithIdOnly = await prisma.customPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomPackageFindManyArgs>(args?: SelectSubset<T, CustomPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomPackage.
     * @param {CustomPackageCreateArgs} args - Arguments to create a CustomPackage.
     * @example
     * // Create one CustomPackage
     * const CustomPackage = await prisma.customPackage.create({
     *   data: {
     *     // ... data to create a CustomPackage
     *   }
     * })
     * 
     */
    create<T extends CustomPackageCreateArgs>(args: SelectSubset<T, CustomPackageCreateArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomPackages.
     * @param {CustomPackageCreateManyArgs} args - Arguments to create many CustomPackages.
     * @example
     * // Create many CustomPackages
     * const customPackage = await prisma.customPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomPackageCreateManyArgs>(args?: SelectSubset<T, CustomPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomPackages and returns the data saved in the database.
     * @param {CustomPackageCreateManyAndReturnArgs} args - Arguments to create many CustomPackages.
     * @example
     * // Create many CustomPackages
     * const customPackage = await prisma.customPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomPackages and only return the `id`
     * const customPackageWithIdOnly = await prisma.customPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomPackage.
     * @param {CustomPackageDeleteArgs} args - Arguments to delete one CustomPackage.
     * @example
     * // Delete one CustomPackage
     * const CustomPackage = await prisma.customPackage.delete({
     *   where: {
     *     // ... filter to delete one CustomPackage
     *   }
     * })
     * 
     */
    delete<T extends CustomPackageDeleteArgs>(args: SelectSubset<T, CustomPackageDeleteArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomPackage.
     * @param {CustomPackageUpdateArgs} args - Arguments to update one CustomPackage.
     * @example
     * // Update one CustomPackage
     * const customPackage = await prisma.customPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomPackageUpdateArgs>(args: SelectSubset<T, CustomPackageUpdateArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomPackages.
     * @param {CustomPackageDeleteManyArgs} args - Arguments to filter CustomPackages to delete.
     * @example
     * // Delete a few CustomPackages
     * const { count } = await prisma.customPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomPackageDeleteManyArgs>(args?: SelectSubset<T, CustomPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomPackages
     * const customPackage = await prisma.customPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomPackageUpdateManyArgs>(args: SelectSubset<T, CustomPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomPackages and returns the data updated in the database.
     * @param {CustomPackageUpdateManyAndReturnArgs} args - Arguments to update many CustomPackages.
     * @example
     * // Update many CustomPackages
     * const customPackage = await prisma.customPackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomPackages and only return the `id`
     * const customPackageWithIdOnly = await prisma.customPackage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomPackageUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomPackage.
     * @param {CustomPackageUpsertArgs} args - Arguments to update or create a CustomPackage.
     * @example
     * // Update or create a CustomPackage
     * const customPackage = await prisma.customPackage.upsert({
     *   create: {
     *     // ... data to create a CustomPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomPackage we want to update
     *   }
     * })
     */
    upsert<T extends CustomPackageUpsertArgs>(args: SelectSubset<T, CustomPackageUpsertArgs<ExtArgs>>): Prisma__CustomPackageClient<$Result.GetResult<Prisma.$CustomPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageCountArgs} args - Arguments to filter CustomPackages to count.
     * @example
     * // Count the number of CustomPackages
     * const count = await prisma.customPackage.count({
     *   where: {
     *     // ... the filter for the CustomPackages we want to count
     *   }
     * })
    **/
    count<T extends CustomPackageCountArgs>(
      args?: Subset<T, CustomPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomPackageAggregateArgs>(args: Subset<T, CustomPackageAggregateArgs>): Prisma.PrismaPromise<GetCustomPackageAggregateType<T>>

    /**
     * Group by CustomPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomPackageGroupByArgs['orderBy'] }
        : { orderBy?: CustomPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomPackage model
   */
  readonly fields: CustomPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomPackage model
   */
  interface CustomPackageFieldRefs {
    readonly id: FieldRef<"CustomPackage", 'Int'>
    readonly userId: FieldRef<"CustomPackage", 'String'>
    readonly name: FieldRef<"CustomPackage", 'String'>
    readonly contactName: FieldRef<"CustomPackage", 'String'>
    readonly email: FieldRef<"CustomPackage", 'String'>
    readonly phone: FieldRef<"CustomPackage", 'String'>
    readonly destinations: FieldRef<"CustomPackage", 'Json'>
    readonly duration: FieldRef<"CustomPackage", 'String'>
    readonly numberOfPeople: FieldRef<"CustomPackage", 'Int'>
    readonly travelDate: FieldRef<"CustomPackage", 'DateTime'>
    readonly specialRequests: FieldRef<"CustomPackage", 'String'>
    readonly budget: FieldRef<"CustomPackage", 'Decimal'>
    readonly status: FieldRef<"CustomPackage", 'CustomPackageStatus'>
    readonly quotedPrice: FieldRef<"CustomPackage", 'Decimal'>
    readonly quoteNotes: FieldRef<"CustomPackage", 'String'>
    readonly createdAt: FieldRef<"CustomPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomPackage findUnique
   */
  export type CustomPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPackage to fetch.
     */
    where: CustomPackageWhereUniqueInput
  }

  /**
   * CustomPackage findUniqueOrThrow
   */
  export type CustomPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPackage to fetch.
     */
    where: CustomPackageWhereUniqueInput
  }

  /**
   * CustomPackage findFirst
   */
  export type CustomPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPackage to fetch.
     */
    where?: CustomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPackages to fetch.
     */
    orderBy?: CustomPackageOrderByWithRelationInput | CustomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPackages.
     */
    cursor?: CustomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPackages.
     */
    distinct?: CustomPackageScalarFieldEnum | CustomPackageScalarFieldEnum[]
  }

  /**
   * CustomPackage findFirstOrThrow
   */
  export type CustomPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPackage to fetch.
     */
    where?: CustomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPackages to fetch.
     */
    orderBy?: CustomPackageOrderByWithRelationInput | CustomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPackages.
     */
    cursor?: CustomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPackages.
     */
    distinct?: CustomPackageScalarFieldEnum | CustomPackageScalarFieldEnum[]
  }

  /**
   * CustomPackage findMany
   */
  export type CustomPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPackages to fetch.
     */
    where?: CustomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPackages to fetch.
     */
    orderBy?: CustomPackageOrderByWithRelationInput | CustomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomPackages.
     */
    cursor?: CustomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPackages.
     */
    skip?: number
    distinct?: CustomPackageScalarFieldEnum | CustomPackageScalarFieldEnum[]
  }

  /**
   * CustomPackage create
   */
  export type CustomPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomPackage.
     */
    data: XOR<CustomPackageCreateInput, CustomPackageUncheckedCreateInput>
  }

  /**
   * CustomPackage createMany
   */
  export type CustomPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomPackages.
     */
    data: CustomPackageCreateManyInput | CustomPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomPackage createManyAndReturn
   */
  export type CustomPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * The data used to create many CustomPackages.
     */
    data: CustomPackageCreateManyInput | CustomPackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomPackage update
   */
  export type CustomPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomPackage.
     */
    data: XOR<CustomPackageUpdateInput, CustomPackageUncheckedUpdateInput>
    /**
     * Choose, which CustomPackage to update.
     */
    where: CustomPackageWhereUniqueInput
  }

  /**
   * CustomPackage updateMany
   */
  export type CustomPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomPackages.
     */
    data: XOR<CustomPackageUpdateManyMutationInput, CustomPackageUncheckedUpdateManyInput>
    /**
     * Filter which CustomPackages to update
     */
    where?: CustomPackageWhereInput
    /**
     * Limit how many CustomPackages to update.
     */
    limit?: number
  }

  /**
   * CustomPackage updateManyAndReturn
   */
  export type CustomPackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * The data used to update CustomPackages.
     */
    data: XOR<CustomPackageUpdateManyMutationInput, CustomPackageUncheckedUpdateManyInput>
    /**
     * Filter which CustomPackages to update
     */
    where?: CustomPackageWhereInput
    /**
     * Limit how many CustomPackages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomPackage upsert
   */
  export type CustomPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomPackage to update in case it exists.
     */
    where: CustomPackageWhereUniqueInput
    /**
     * In case the CustomPackage found by the `where` argument doesn't exist, create a new CustomPackage with this data.
     */
    create: XOR<CustomPackageCreateInput, CustomPackageUncheckedCreateInput>
    /**
     * In case the CustomPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomPackageUpdateInput, CustomPackageUncheckedUpdateInput>
  }

  /**
   * CustomPackage delete
   */
  export type CustomPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
    /**
     * Filter which CustomPackage to delete.
     */
    where: CustomPackageWhereUniqueInput
  }

  /**
   * CustomPackage deleteMany
   */
  export type CustomPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPackages to delete
     */
    where?: CustomPackageWhereInput
    /**
     * Limit how many CustomPackages to delete.
     */
    limit?: number
  }

  /**
   * CustomPackage without action
   */
  export type CustomPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPackage
     */
    select?: CustomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomPackage
     */
    omit?: CustomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPackageInclude<ExtArgs> | null
  }


  /**
   * Model PackageBundle
   */

  export type AggregatePackageBundle = {
    _count: PackageBundleCountAggregateOutputType | null
    _avg: PackageBundleAvgAggregateOutputType | null
    _sum: PackageBundleSumAggregateOutputType | null
    _min: PackageBundleMinAggregateOutputType | null
    _max: PackageBundleMaxAggregateOutputType | null
  }

  export type PackageBundleAvgAggregateOutputType = {
    id: number | null
    numberOfPeople: number | null
    quotedPrice: Decimal | null
  }

  export type PackageBundleSumAggregateOutputType = {
    id: number | null
    numberOfPeople: number | null
    quotedPrice: Decimal | null
  }

  export type PackageBundleMinAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    numberOfPeople: number | null
    travelDate: Date | null
    specialRequests: string | null
    status: $Enums.CustomPackageStatus | null
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageBundleMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    numberOfPeople: number | null
    travelDate: Date | null
    specialRequests: string | null
    status: $Enums.CustomPackageStatus | null
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageBundleCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    numberOfPeople: number
    travelDate: number
    specialRequests: number
    status: number
    quotedPrice: number
    quoteNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageBundleAvgAggregateInputType = {
    id?: true
    numberOfPeople?: true
    quotedPrice?: true
  }

  export type PackageBundleSumAggregateInputType = {
    id?: true
    numberOfPeople?: true
    quotedPrice?: true
  }

  export type PackageBundleMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageBundleMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageBundleCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    numberOfPeople?: true
    travelDate?: true
    specialRequests?: true
    status?: true
    quotedPrice?: true
    quoteNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageBundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageBundle to aggregate.
     */
    where?: PackageBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundles to fetch.
     */
    orderBy?: PackageBundleOrderByWithRelationInput | PackageBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageBundles
    **/
    _count?: true | PackageBundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageBundleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageBundleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageBundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageBundleMaxAggregateInputType
  }

  export type GetPackageBundleAggregateType<T extends PackageBundleAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageBundle[P]>
      : GetScalarType<T[P], AggregatePackageBundle[P]>
  }




  export type PackageBundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageBundleWhereInput
    orderBy?: PackageBundleOrderByWithAggregationInput | PackageBundleOrderByWithAggregationInput[]
    by: PackageBundleScalarFieldEnum[] | PackageBundleScalarFieldEnum
    having?: PackageBundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageBundleCountAggregateInputType | true
    _avg?: PackageBundleAvgAggregateInputType
    _sum?: PackageBundleSumAggregateInputType
    _min?: PackageBundleMinAggregateInputType
    _max?: PackageBundleMaxAggregateInputType
  }

  export type PackageBundleGroupByOutputType = {
    id: number
    userId: string
    name: string | null
    numberOfPeople: number
    travelDate: Date | null
    specialRequests: string | null
    status: $Enums.CustomPackageStatus
    quotedPrice: Decimal | null
    quoteNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PackageBundleCountAggregateOutputType | null
    _avg: PackageBundleAvgAggregateOutputType | null
    _sum: PackageBundleSumAggregateOutputType | null
    _min: PackageBundleMinAggregateOutputType | null
    _max: PackageBundleMaxAggregateOutputType | null
  }

  type GetPackageBundleGroupByPayload<T extends PackageBundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageBundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageBundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageBundleGroupByOutputType[P]>
            : GetScalarType<T[P], PackageBundleGroupByOutputType[P]>
        }
      >
    >


  export type PackageBundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    packages?: boolean | PackageBundle$packagesArgs<ExtArgs>
    _count?: boolean | PackageBundleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundle"]>

  export type PackageBundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundle"]>

  export type PackageBundleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundle"]>

  export type PackageBundleSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    numberOfPeople?: boolean
    travelDate?: boolean
    specialRequests?: boolean
    status?: boolean
    quotedPrice?: boolean
    quoteNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageBundleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "numberOfPeople" | "travelDate" | "specialRequests" | "status" | "quotedPrice" | "quoteNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["packageBundle"]>
  export type PackageBundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    packages?: boolean | PackageBundle$packagesArgs<ExtArgs>
    _count?: boolean | PackageBundleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageBundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PackageBundleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PackageBundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageBundle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      packages: Prisma.$PackageBundleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      name: string | null
      numberOfPeople: number
      travelDate: Date | null
      specialRequests: string | null
      status: $Enums.CustomPackageStatus
      quotedPrice: Prisma.Decimal | null
      quoteNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packageBundle"]>
    composites: {}
  }

  type PackageBundleGetPayload<S extends boolean | null | undefined | PackageBundleDefaultArgs> = $Result.GetResult<Prisma.$PackageBundlePayload, S>

  type PackageBundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageBundleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageBundleCountAggregateInputType | true
    }

  export interface PackageBundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageBundle'], meta: { name: 'PackageBundle' } }
    /**
     * Find zero or one PackageBundle that matches the filter.
     * @param {PackageBundleFindUniqueArgs} args - Arguments to find a PackageBundle
     * @example
     * // Get one PackageBundle
     * const packageBundle = await prisma.packageBundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageBundleFindUniqueArgs>(args: SelectSubset<T, PackageBundleFindUniqueArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageBundle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageBundleFindUniqueOrThrowArgs} args - Arguments to find a PackageBundle
     * @example
     * // Get one PackageBundle
     * const packageBundle = await prisma.packageBundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageBundleFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageBundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageBundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleFindFirstArgs} args - Arguments to find a PackageBundle
     * @example
     * // Get one PackageBundle
     * const packageBundle = await prisma.packageBundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageBundleFindFirstArgs>(args?: SelectSubset<T, PackageBundleFindFirstArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageBundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleFindFirstOrThrowArgs} args - Arguments to find a PackageBundle
     * @example
     * // Get one PackageBundle
     * const packageBundle = await prisma.packageBundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageBundleFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageBundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageBundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageBundles
     * const packageBundles = await prisma.packageBundle.findMany()
     * 
     * // Get first 10 PackageBundles
     * const packageBundles = await prisma.packageBundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageBundleWithIdOnly = await prisma.packageBundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageBundleFindManyArgs>(args?: SelectSubset<T, PackageBundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageBundle.
     * @param {PackageBundleCreateArgs} args - Arguments to create a PackageBundle.
     * @example
     * // Create one PackageBundle
     * const PackageBundle = await prisma.packageBundle.create({
     *   data: {
     *     // ... data to create a PackageBundle
     *   }
     * })
     * 
     */
    create<T extends PackageBundleCreateArgs>(args: SelectSubset<T, PackageBundleCreateArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageBundles.
     * @param {PackageBundleCreateManyArgs} args - Arguments to create many PackageBundles.
     * @example
     * // Create many PackageBundles
     * const packageBundle = await prisma.packageBundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageBundleCreateManyArgs>(args?: SelectSubset<T, PackageBundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageBundles and returns the data saved in the database.
     * @param {PackageBundleCreateManyAndReturnArgs} args - Arguments to create many PackageBundles.
     * @example
     * // Create many PackageBundles
     * const packageBundle = await prisma.packageBundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageBundles and only return the `id`
     * const packageBundleWithIdOnly = await prisma.packageBundle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageBundleCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageBundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackageBundle.
     * @param {PackageBundleDeleteArgs} args - Arguments to delete one PackageBundle.
     * @example
     * // Delete one PackageBundle
     * const PackageBundle = await prisma.packageBundle.delete({
     *   where: {
     *     // ... filter to delete one PackageBundle
     *   }
     * })
     * 
     */
    delete<T extends PackageBundleDeleteArgs>(args: SelectSubset<T, PackageBundleDeleteArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageBundle.
     * @param {PackageBundleUpdateArgs} args - Arguments to update one PackageBundle.
     * @example
     * // Update one PackageBundle
     * const packageBundle = await prisma.packageBundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageBundleUpdateArgs>(args: SelectSubset<T, PackageBundleUpdateArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageBundles.
     * @param {PackageBundleDeleteManyArgs} args - Arguments to filter PackageBundles to delete.
     * @example
     * // Delete a few PackageBundles
     * const { count } = await prisma.packageBundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageBundleDeleteManyArgs>(args?: SelectSubset<T, PackageBundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageBundles
     * const packageBundle = await prisma.packageBundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageBundleUpdateManyArgs>(args: SelectSubset<T, PackageBundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageBundles and returns the data updated in the database.
     * @param {PackageBundleUpdateManyAndReturnArgs} args - Arguments to update many PackageBundles.
     * @example
     * // Update many PackageBundles
     * const packageBundle = await prisma.packageBundle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackageBundles and only return the `id`
     * const packageBundleWithIdOnly = await prisma.packageBundle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageBundleUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageBundleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackageBundle.
     * @param {PackageBundleUpsertArgs} args - Arguments to update or create a PackageBundle.
     * @example
     * // Update or create a PackageBundle
     * const packageBundle = await prisma.packageBundle.upsert({
     *   create: {
     *     // ... data to create a PackageBundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageBundle we want to update
     *   }
     * })
     */
    upsert<T extends PackageBundleUpsertArgs>(args: SelectSubset<T, PackageBundleUpsertArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleCountArgs} args - Arguments to filter PackageBundles to count.
     * @example
     * // Count the number of PackageBundles
     * const count = await prisma.packageBundle.count({
     *   where: {
     *     // ... the filter for the PackageBundles we want to count
     *   }
     * })
    **/
    count<T extends PackageBundleCountArgs>(
      args?: Subset<T, PackageBundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageBundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageBundleAggregateArgs>(args: Subset<T, PackageBundleAggregateArgs>): Prisma.PrismaPromise<GetPackageBundleAggregateType<T>>

    /**
     * Group by PackageBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageBundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageBundleGroupByArgs['orderBy'] }
        : { orderBy?: PackageBundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageBundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageBundle model
   */
  readonly fields: PackageBundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageBundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageBundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packages<T extends PackageBundle$packagesArgs<ExtArgs> = {}>(args?: Subset<T, PackageBundle$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageBundle model
   */
  interface PackageBundleFieldRefs {
    readonly id: FieldRef<"PackageBundle", 'Int'>
    readonly userId: FieldRef<"PackageBundle", 'String'>
    readonly name: FieldRef<"PackageBundle", 'String'>
    readonly numberOfPeople: FieldRef<"PackageBundle", 'Int'>
    readonly travelDate: FieldRef<"PackageBundle", 'DateTime'>
    readonly specialRequests: FieldRef<"PackageBundle", 'String'>
    readonly status: FieldRef<"PackageBundle", 'CustomPackageStatus'>
    readonly quotedPrice: FieldRef<"PackageBundle", 'Decimal'>
    readonly quoteNotes: FieldRef<"PackageBundle", 'String'>
    readonly createdAt: FieldRef<"PackageBundle", 'DateTime'>
    readonly updatedAt: FieldRef<"PackageBundle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageBundle findUnique
   */
  export type PackageBundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundle to fetch.
     */
    where: PackageBundleWhereUniqueInput
  }

  /**
   * PackageBundle findUniqueOrThrow
   */
  export type PackageBundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundle to fetch.
     */
    where: PackageBundleWhereUniqueInput
  }

  /**
   * PackageBundle findFirst
   */
  export type PackageBundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundle to fetch.
     */
    where?: PackageBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundles to fetch.
     */
    orderBy?: PackageBundleOrderByWithRelationInput | PackageBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageBundles.
     */
    cursor?: PackageBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageBundles.
     */
    distinct?: PackageBundleScalarFieldEnum | PackageBundleScalarFieldEnum[]
  }

  /**
   * PackageBundle findFirstOrThrow
   */
  export type PackageBundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundle to fetch.
     */
    where?: PackageBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundles to fetch.
     */
    orderBy?: PackageBundleOrderByWithRelationInput | PackageBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageBundles.
     */
    cursor?: PackageBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageBundles.
     */
    distinct?: PackageBundleScalarFieldEnum | PackageBundleScalarFieldEnum[]
  }

  /**
   * PackageBundle findMany
   */
  export type PackageBundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundles to fetch.
     */
    where?: PackageBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundles to fetch.
     */
    orderBy?: PackageBundleOrderByWithRelationInput | PackageBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageBundles.
     */
    cursor?: PackageBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundles.
     */
    skip?: number
    distinct?: PackageBundleScalarFieldEnum | PackageBundleScalarFieldEnum[]
  }

  /**
   * PackageBundle create
   */
  export type PackageBundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageBundle.
     */
    data: XOR<PackageBundleCreateInput, PackageBundleUncheckedCreateInput>
  }

  /**
   * PackageBundle createMany
   */
  export type PackageBundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageBundles.
     */
    data: PackageBundleCreateManyInput | PackageBundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageBundle createManyAndReturn
   */
  export type PackageBundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * The data used to create many PackageBundles.
     */
    data: PackageBundleCreateManyInput | PackageBundleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageBundle update
   */
  export type PackageBundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageBundle.
     */
    data: XOR<PackageBundleUpdateInput, PackageBundleUncheckedUpdateInput>
    /**
     * Choose, which PackageBundle to update.
     */
    where: PackageBundleWhereUniqueInput
  }

  /**
   * PackageBundle updateMany
   */
  export type PackageBundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageBundles.
     */
    data: XOR<PackageBundleUpdateManyMutationInput, PackageBundleUncheckedUpdateManyInput>
    /**
     * Filter which PackageBundles to update
     */
    where?: PackageBundleWhereInput
    /**
     * Limit how many PackageBundles to update.
     */
    limit?: number
  }

  /**
   * PackageBundle updateManyAndReturn
   */
  export type PackageBundleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * The data used to update PackageBundles.
     */
    data: XOR<PackageBundleUpdateManyMutationInput, PackageBundleUncheckedUpdateManyInput>
    /**
     * Filter which PackageBundles to update
     */
    where?: PackageBundleWhereInput
    /**
     * Limit how many PackageBundles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageBundle upsert
   */
  export type PackageBundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageBundle to update in case it exists.
     */
    where: PackageBundleWhereUniqueInput
    /**
     * In case the PackageBundle found by the `where` argument doesn't exist, create a new PackageBundle with this data.
     */
    create: XOR<PackageBundleCreateInput, PackageBundleUncheckedCreateInput>
    /**
     * In case the PackageBundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageBundleUpdateInput, PackageBundleUncheckedUpdateInput>
  }

  /**
   * PackageBundle delete
   */
  export type PackageBundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
    /**
     * Filter which PackageBundle to delete.
     */
    where: PackageBundleWhereUniqueInput
  }

  /**
   * PackageBundle deleteMany
   */
  export type PackageBundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageBundles to delete
     */
    where?: PackageBundleWhereInput
    /**
     * Limit how many PackageBundles to delete.
     */
    limit?: number
  }

  /**
   * PackageBundle.packages
   */
  export type PackageBundle$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    where?: PackageBundleItemWhereInput
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    cursor?: PackageBundleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageBundleItemScalarFieldEnum | PackageBundleItemScalarFieldEnum[]
  }

  /**
   * PackageBundle without action
   */
  export type PackageBundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundle
     */
    select?: PackageBundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundle
     */
    omit?: PackageBundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleInclude<ExtArgs> | null
  }


  /**
   * Model PackageBundleItem
   */

  export type AggregatePackageBundleItem = {
    _count: PackageBundleItemCountAggregateOutputType | null
    _avg: PackageBundleItemAvgAggregateOutputType | null
    _sum: PackageBundleItemSumAggregateOutputType | null
    _min: PackageBundleItemMinAggregateOutputType | null
    _max: PackageBundleItemMaxAggregateOutputType | null
  }

  export type PackageBundleItemAvgAggregateOutputType = {
    id: number | null
    bundleId: number | null
    packageId: number | null
  }

  export type PackageBundleItemSumAggregateOutputType = {
    id: number | null
    bundleId: number | null
    packageId: number | null
  }

  export type PackageBundleItemMinAggregateOutputType = {
    id: number | null
    bundleId: number | null
    packageId: number | null
    notes: string | null
  }

  export type PackageBundleItemMaxAggregateOutputType = {
    id: number | null
    bundleId: number | null
    packageId: number | null
    notes: string | null
  }

  export type PackageBundleItemCountAggregateOutputType = {
    id: number
    bundleId: number
    packageId: number
    notes: number
    _all: number
  }


  export type PackageBundleItemAvgAggregateInputType = {
    id?: true
    bundleId?: true
    packageId?: true
  }

  export type PackageBundleItemSumAggregateInputType = {
    id?: true
    bundleId?: true
    packageId?: true
  }

  export type PackageBundleItemMinAggregateInputType = {
    id?: true
    bundleId?: true
    packageId?: true
    notes?: true
  }

  export type PackageBundleItemMaxAggregateInputType = {
    id?: true
    bundleId?: true
    packageId?: true
    notes?: true
  }

  export type PackageBundleItemCountAggregateInputType = {
    id?: true
    bundleId?: true
    packageId?: true
    notes?: true
    _all?: true
  }

  export type PackageBundleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageBundleItem to aggregate.
     */
    where?: PackageBundleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundleItems to fetch.
     */
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageBundleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageBundleItems
    **/
    _count?: true | PackageBundleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageBundleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageBundleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageBundleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageBundleItemMaxAggregateInputType
  }

  export type GetPackageBundleItemAggregateType<T extends PackageBundleItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageBundleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageBundleItem[P]>
      : GetScalarType<T[P], AggregatePackageBundleItem[P]>
  }




  export type PackageBundleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageBundleItemWhereInput
    orderBy?: PackageBundleItemOrderByWithAggregationInput | PackageBundleItemOrderByWithAggregationInput[]
    by: PackageBundleItemScalarFieldEnum[] | PackageBundleItemScalarFieldEnum
    having?: PackageBundleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageBundleItemCountAggregateInputType | true
    _avg?: PackageBundleItemAvgAggregateInputType
    _sum?: PackageBundleItemSumAggregateInputType
    _min?: PackageBundleItemMinAggregateInputType
    _max?: PackageBundleItemMaxAggregateInputType
  }

  export type PackageBundleItemGroupByOutputType = {
    id: number
    bundleId: number
    packageId: number
    notes: string | null
    _count: PackageBundleItemCountAggregateOutputType | null
    _avg: PackageBundleItemAvgAggregateOutputType | null
    _sum: PackageBundleItemSumAggregateOutputType | null
    _min: PackageBundleItemMinAggregateOutputType | null
    _max: PackageBundleItemMaxAggregateOutputType | null
  }

  type GetPackageBundleItemGroupByPayload<T extends PackageBundleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageBundleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageBundleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageBundleItemGroupByOutputType[P]>
            : GetScalarType<T[P], PackageBundleItemGroupByOutputType[P]>
        }
      >
    >


  export type PackageBundleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bundleId?: boolean
    packageId?: boolean
    notes?: boolean
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundleItem"]>

  export type PackageBundleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bundleId?: boolean
    packageId?: boolean
    notes?: boolean
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundleItem"]>

  export type PackageBundleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bundleId?: boolean
    packageId?: boolean
    notes?: boolean
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageBundleItem"]>

  export type PackageBundleItemSelectScalar = {
    id?: boolean
    bundleId?: boolean
    packageId?: boolean
    notes?: boolean
  }

  export type PackageBundleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bundleId" | "packageId" | "notes", ExtArgs["result"]["packageBundleItem"]>
  export type PackageBundleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }
  export type PackageBundleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }
  export type PackageBundleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | PackageBundleDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }

  export type $PackageBundleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageBundleItem"
    objects: {
      bundle: Prisma.$PackageBundlePayload<ExtArgs>
      package: Prisma.$PackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bundleId: number
      packageId: number
      notes: string | null
    }, ExtArgs["result"]["packageBundleItem"]>
    composites: {}
  }

  type PackageBundleItemGetPayload<S extends boolean | null | undefined | PackageBundleItemDefaultArgs> = $Result.GetResult<Prisma.$PackageBundleItemPayload, S>

  type PackageBundleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageBundleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageBundleItemCountAggregateInputType | true
    }

  export interface PackageBundleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageBundleItem'], meta: { name: 'PackageBundleItem' } }
    /**
     * Find zero or one PackageBundleItem that matches the filter.
     * @param {PackageBundleItemFindUniqueArgs} args - Arguments to find a PackageBundleItem
     * @example
     * // Get one PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageBundleItemFindUniqueArgs>(args: SelectSubset<T, PackageBundleItemFindUniqueArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageBundleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageBundleItemFindUniqueOrThrowArgs} args - Arguments to find a PackageBundleItem
     * @example
     * // Get one PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageBundleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageBundleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageBundleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemFindFirstArgs} args - Arguments to find a PackageBundleItem
     * @example
     * // Get one PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageBundleItemFindFirstArgs>(args?: SelectSubset<T, PackageBundleItemFindFirstArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageBundleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemFindFirstOrThrowArgs} args - Arguments to find a PackageBundleItem
     * @example
     * // Get one PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageBundleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageBundleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageBundleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageBundleItems
     * const packageBundleItems = await prisma.packageBundleItem.findMany()
     * 
     * // Get first 10 PackageBundleItems
     * const packageBundleItems = await prisma.packageBundleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageBundleItemWithIdOnly = await prisma.packageBundleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageBundleItemFindManyArgs>(args?: SelectSubset<T, PackageBundleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageBundleItem.
     * @param {PackageBundleItemCreateArgs} args - Arguments to create a PackageBundleItem.
     * @example
     * // Create one PackageBundleItem
     * const PackageBundleItem = await prisma.packageBundleItem.create({
     *   data: {
     *     // ... data to create a PackageBundleItem
     *   }
     * })
     * 
     */
    create<T extends PackageBundleItemCreateArgs>(args: SelectSubset<T, PackageBundleItemCreateArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageBundleItems.
     * @param {PackageBundleItemCreateManyArgs} args - Arguments to create many PackageBundleItems.
     * @example
     * // Create many PackageBundleItems
     * const packageBundleItem = await prisma.packageBundleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageBundleItemCreateManyArgs>(args?: SelectSubset<T, PackageBundleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageBundleItems and returns the data saved in the database.
     * @param {PackageBundleItemCreateManyAndReturnArgs} args - Arguments to create many PackageBundleItems.
     * @example
     * // Create many PackageBundleItems
     * const packageBundleItem = await prisma.packageBundleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageBundleItems and only return the `id`
     * const packageBundleItemWithIdOnly = await prisma.packageBundleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageBundleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageBundleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackageBundleItem.
     * @param {PackageBundleItemDeleteArgs} args - Arguments to delete one PackageBundleItem.
     * @example
     * // Delete one PackageBundleItem
     * const PackageBundleItem = await prisma.packageBundleItem.delete({
     *   where: {
     *     // ... filter to delete one PackageBundleItem
     *   }
     * })
     * 
     */
    delete<T extends PackageBundleItemDeleteArgs>(args: SelectSubset<T, PackageBundleItemDeleteArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageBundleItem.
     * @param {PackageBundleItemUpdateArgs} args - Arguments to update one PackageBundleItem.
     * @example
     * // Update one PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageBundleItemUpdateArgs>(args: SelectSubset<T, PackageBundleItemUpdateArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageBundleItems.
     * @param {PackageBundleItemDeleteManyArgs} args - Arguments to filter PackageBundleItems to delete.
     * @example
     * // Delete a few PackageBundleItems
     * const { count } = await prisma.packageBundleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageBundleItemDeleteManyArgs>(args?: SelectSubset<T, PackageBundleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageBundleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageBundleItems
     * const packageBundleItem = await prisma.packageBundleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageBundleItemUpdateManyArgs>(args: SelectSubset<T, PackageBundleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageBundleItems and returns the data updated in the database.
     * @param {PackageBundleItemUpdateManyAndReturnArgs} args - Arguments to update many PackageBundleItems.
     * @example
     * // Update many PackageBundleItems
     * const packageBundleItem = await prisma.packageBundleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackageBundleItems and only return the `id`
     * const packageBundleItemWithIdOnly = await prisma.packageBundleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageBundleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageBundleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackageBundleItem.
     * @param {PackageBundleItemUpsertArgs} args - Arguments to update or create a PackageBundleItem.
     * @example
     * // Update or create a PackageBundleItem
     * const packageBundleItem = await prisma.packageBundleItem.upsert({
     *   create: {
     *     // ... data to create a PackageBundleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageBundleItem we want to update
     *   }
     * })
     */
    upsert<T extends PackageBundleItemUpsertArgs>(args: SelectSubset<T, PackageBundleItemUpsertArgs<ExtArgs>>): Prisma__PackageBundleItemClient<$Result.GetResult<Prisma.$PackageBundleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageBundleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemCountArgs} args - Arguments to filter PackageBundleItems to count.
     * @example
     * // Count the number of PackageBundleItems
     * const count = await prisma.packageBundleItem.count({
     *   where: {
     *     // ... the filter for the PackageBundleItems we want to count
     *   }
     * })
    **/
    count<T extends PackageBundleItemCountArgs>(
      args?: Subset<T, PackageBundleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageBundleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageBundleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageBundleItemAggregateArgs>(args: Subset<T, PackageBundleItemAggregateArgs>): Prisma.PrismaPromise<GetPackageBundleItemAggregateType<T>>

    /**
     * Group by PackageBundleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageBundleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageBundleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageBundleItemGroupByArgs['orderBy'] }
        : { orderBy?: PackageBundleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageBundleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageBundleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageBundleItem model
   */
  readonly fields: PackageBundleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageBundleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageBundleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle<T extends PackageBundleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageBundleDefaultArgs<ExtArgs>>): Prisma__PackageBundleClient<$Result.GetResult<Prisma.$PackageBundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    package<T extends PackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageDefaultArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageBundleItem model
   */
  interface PackageBundleItemFieldRefs {
    readonly id: FieldRef<"PackageBundleItem", 'Int'>
    readonly bundleId: FieldRef<"PackageBundleItem", 'Int'>
    readonly packageId: FieldRef<"PackageBundleItem", 'Int'>
    readonly notes: FieldRef<"PackageBundleItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PackageBundleItem findUnique
   */
  export type PackageBundleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundleItem to fetch.
     */
    where: PackageBundleItemWhereUniqueInput
  }

  /**
   * PackageBundleItem findUniqueOrThrow
   */
  export type PackageBundleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundleItem to fetch.
     */
    where: PackageBundleItemWhereUniqueInput
  }

  /**
   * PackageBundleItem findFirst
   */
  export type PackageBundleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundleItem to fetch.
     */
    where?: PackageBundleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundleItems to fetch.
     */
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageBundleItems.
     */
    cursor?: PackageBundleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageBundleItems.
     */
    distinct?: PackageBundleItemScalarFieldEnum | PackageBundleItemScalarFieldEnum[]
  }

  /**
   * PackageBundleItem findFirstOrThrow
   */
  export type PackageBundleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundleItem to fetch.
     */
    where?: PackageBundleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundleItems to fetch.
     */
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageBundleItems.
     */
    cursor?: PackageBundleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageBundleItems.
     */
    distinct?: PackageBundleItemScalarFieldEnum | PackageBundleItemScalarFieldEnum[]
  }

  /**
   * PackageBundleItem findMany
   */
  export type PackageBundleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter, which PackageBundleItems to fetch.
     */
    where?: PackageBundleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageBundleItems to fetch.
     */
    orderBy?: PackageBundleItemOrderByWithRelationInput | PackageBundleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageBundleItems.
     */
    cursor?: PackageBundleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageBundleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageBundleItems.
     */
    skip?: number
    distinct?: PackageBundleItemScalarFieldEnum | PackageBundleItemScalarFieldEnum[]
  }

  /**
   * PackageBundleItem create
   */
  export type PackageBundleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageBundleItem.
     */
    data: XOR<PackageBundleItemCreateInput, PackageBundleItemUncheckedCreateInput>
  }

  /**
   * PackageBundleItem createMany
   */
  export type PackageBundleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageBundleItems.
     */
    data: PackageBundleItemCreateManyInput | PackageBundleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageBundleItem createManyAndReturn
   */
  export type PackageBundleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * The data used to create many PackageBundleItems.
     */
    data: PackageBundleItemCreateManyInput | PackageBundleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageBundleItem update
   */
  export type PackageBundleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageBundleItem.
     */
    data: XOR<PackageBundleItemUpdateInput, PackageBundleItemUncheckedUpdateInput>
    /**
     * Choose, which PackageBundleItem to update.
     */
    where: PackageBundleItemWhereUniqueInput
  }

  /**
   * PackageBundleItem updateMany
   */
  export type PackageBundleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageBundleItems.
     */
    data: XOR<PackageBundleItemUpdateManyMutationInput, PackageBundleItemUncheckedUpdateManyInput>
    /**
     * Filter which PackageBundleItems to update
     */
    where?: PackageBundleItemWhereInput
    /**
     * Limit how many PackageBundleItems to update.
     */
    limit?: number
  }

  /**
   * PackageBundleItem updateManyAndReturn
   */
  export type PackageBundleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * The data used to update PackageBundleItems.
     */
    data: XOR<PackageBundleItemUpdateManyMutationInput, PackageBundleItemUncheckedUpdateManyInput>
    /**
     * Filter which PackageBundleItems to update
     */
    where?: PackageBundleItemWhereInput
    /**
     * Limit how many PackageBundleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageBundleItem upsert
   */
  export type PackageBundleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageBundleItem to update in case it exists.
     */
    where: PackageBundleItemWhereUniqueInput
    /**
     * In case the PackageBundleItem found by the `where` argument doesn't exist, create a new PackageBundleItem with this data.
     */
    create: XOR<PackageBundleItemCreateInput, PackageBundleItemUncheckedCreateInput>
    /**
     * In case the PackageBundleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageBundleItemUpdateInput, PackageBundleItemUncheckedUpdateInput>
  }

  /**
   * PackageBundleItem delete
   */
  export type PackageBundleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
    /**
     * Filter which PackageBundleItem to delete.
     */
    where: PackageBundleItemWhereUniqueInput
  }

  /**
   * PackageBundleItem deleteMany
   */
  export type PackageBundleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageBundleItems to delete
     */
    where?: PackageBundleItemWhereInput
    /**
     * Limit how many PackageBundleItems to delete.
     */
    limit?: number
  }

  /**
   * PackageBundleItem without action
   */
  export type PackageBundleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageBundleItem
     */
    select?: PackageBundleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageBundleItem
     */
    omit?: PackageBundleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageBundleItemInclude<ExtArgs> | null
  }


  /**
   * Model CMSImage
   */

  export type AggregateCMSImage = {
    _count: CMSImageCountAggregateOutputType | null
    _avg: CMSImageAvgAggregateOutputType | null
    _sum: CMSImageSumAggregateOutputType | null
    _min: CMSImageMinAggregateOutputType | null
    _max: CMSImageMaxAggregateOutputType | null
  }

  export type CMSImageAvgAggregateOutputType = {
    width: number | null
    height: number | null
    fileSize: number | null
  }

  export type CMSImageSumAggregateOutputType = {
    width: number | null
    height: number | null
    fileSize: number | null
  }

  export type CMSImageMinAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    altText: string | null
    category: string | null
    width: number | null
    height: number | null
    fileSize: number | null
    format: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CMSImageMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    altText: string | null
    category: string | null
    width: number | null
    height: number | null
    fileSize: number | null
    format: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CMSImageCountAggregateOutputType = {
    id: number
    filename: number
    url: number
    altText: number
    category: number
    width: number
    height: number
    fileSize: number
    format: number
    usedIn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CMSImageAvgAggregateInputType = {
    width?: true
    height?: true
    fileSize?: true
  }

  export type CMSImageSumAggregateInputType = {
    width?: true
    height?: true
    fileSize?: true
  }

  export type CMSImageMinAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    altText?: true
    category?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CMSImageMaxAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    altText?: true
    category?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CMSImageCountAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    altText?: true
    category?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    usedIn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CMSImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSImage to aggregate.
     */
    where?: CMSImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSImages to fetch.
     */
    orderBy?: CMSImageOrderByWithRelationInput | CMSImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CMSImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CMSImages
    **/
    _count?: true | CMSImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CMSImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CMSImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CMSImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CMSImageMaxAggregateInputType
  }

  export type GetCMSImageAggregateType<T extends CMSImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCMSImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCMSImage[P]>
      : GetScalarType<T[P], AggregateCMSImage[P]>
  }




  export type CMSImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CMSImageWhereInput
    orderBy?: CMSImageOrderByWithAggregationInput | CMSImageOrderByWithAggregationInput[]
    by: CMSImageScalarFieldEnum[] | CMSImageScalarFieldEnum
    having?: CMSImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CMSImageCountAggregateInputType | true
    _avg?: CMSImageAvgAggregateInputType
    _sum?: CMSImageSumAggregateInputType
    _min?: CMSImageMinAggregateInputType
    _max?: CMSImageMaxAggregateInputType
  }

  export type CMSImageGroupByOutputType = {
    id: string
    filename: string
    url: string
    altText: string | null
    category: string | null
    width: number
    height: number
    fileSize: number
    format: string
    usedIn: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CMSImageCountAggregateOutputType | null
    _avg: CMSImageAvgAggregateOutputType | null
    _sum: CMSImageSumAggregateOutputType | null
    _min: CMSImageMinAggregateOutputType | null
    _max: CMSImageMaxAggregateOutputType | null
  }

  type GetCMSImageGroupByPayload<T extends CMSImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CMSImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CMSImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CMSImageGroupByOutputType[P]>
            : GetScalarType<T[P], CMSImageGroupByOutputType[P]>
        }
      >
    >


  export type CMSImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    altText?: boolean
    category?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    usedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSImage"]>

  export type CMSImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    altText?: boolean
    category?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    usedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSImage"]>

  export type CMSImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    altText?: boolean
    category?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    usedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSImage"]>

  export type CMSImageSelectScalar = {
    id?: boolean
    filename?: boolean
    url?: boolean
    altText?: boolean
    category?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    usedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CMSImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "url" | "altText" | "category" | "width" | "height" | "fileSize" | "format" | "usedIn" | "createdAt" | "updatedAt", ExtArgs["result"]["cMSImage"]>

  export type $CMSImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CMSImage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      url: string
      altText: string | null
      category: string | null
      width: number
      height: number
      fileSize: number
      format: string
      usedIn: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cMSImage"]>
    composites: {}
  }

  type CMSImageGetPayload<S extends boolean | null | undefined | CMSImageDefaultArgs> = $Result.GetResult<Prisma.$CMSImagePayload, S>

  type CMSImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CMSImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CMSImageCountAggregateInputType | true
    }

  export interface CMSImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CMSImage'], meta: { name: 'CMSImage' } }
    /**
     * Find zero or one CMSImage that matches the filter.
     * @param {CMSImageFindUniqueArgs} args - Arguments to find a CMSImage
     * @example
     * // Get one CMSImage
     * const cMSImage = await prisma.cMSImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CMSImageFindUniqueArgs>(args: SelectSubset<T, CMSImageFindUniqueArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CMSImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CMSImageFindUniqueOrThrowArgs} args - Arguments to find a CMSImage
     * @example
     * // Get one CMSImage
     * const cMSImage = await prisma.cMSImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CMSImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CMSImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageFindFirstArgs} args - Arguments to find a CMSImage
     * @example
     * // Get one CMSImage
     * const cMSImage = await prisma.cMSImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CMSImageFindFirstArgs>(args?: SelectSubset<T, CMSImageFindFirstArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageFindFirstOrThrowArgs} args - Arguments to find a CMSImage
     * @example
     * // Get one CMSImage
     * const cMSImage = await prisma.cMSImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CMSImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CMSImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CMSImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CMSImages
     * const cMSImages = await prisma.cMSImage.findMany()
     * 
     * // Get first 10 CMSImages
     * const cMSImages = await prisma.cMSImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cMSImageWithIdOnly = await prisma.cMSImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CMSImageFindManyArgs>(args?: SelectSubset<T, CMSImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CMSImage.
     * @param {CMSImageCreateArgs} args - Arguments to create a CMSImage.
     * @example
     * // Create one CMSImage
     * const CMSImage = await prisma.cMSImage.create({
     *   data: {
     *     // ... data to create a CMSImage
     *   }
     * })
     * 
     */
    create<T extends CMSImageCreateArgs>(args: SelectSubset<T, CMSImageCreateArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CMSImages.
     * @param {CMSImageCreateManyArgs} args - Arguments to create many CMSImages.
     * @example
     * // Create many CMSImages
     * const cMSImage = await prisma.cMSImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CMSImageCreateManyArgs>(args?: SelectSubset<T, CMSImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CMSImages and returns the data saved in the database.
     * @param {CMSImageCreateManyAndReturnArgs} args - Arguments to create many CMSImages.
     * @example
     * // Create many CMSImages
     * const cMSImage = await prisma.cMSImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CMSImages and only return the `id`
     * const cMSImageWithIdOnly = await prisma.cMSImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CMSImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CMSImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CMSImage.
     * @param {CMSImageDeleteArgs} args - Arguments to delete one CMSImage.
     * @example
     * // Delete one CMSImage
     * const CMSImage = await prisma.cMSImage.delete({
     *   where: {
     *     // ... filter to delete one CMSImage
     *   }
     * })
     * 
     */
    delete<T extends CMSImageDeleteArgs>(args: SelectSubset<T, CMSImageDeleteArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CMSImage.
     * @param {CMSImageUpdateArgs} args - Arguments to update one CMSImage.
     * @example
     * // Update one CMSImage
     * const cMSImage = await prisma.cMSImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CMSImageUpdateArgs>(args: SelectSubset<T, CMSImageUpdateArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CMSImages.
     * @param {CMSImageDeleteManyArgs} args - Arguments to filter CMSImages to delete.
     * @example
     * // Delete a few CMSImages
     * const { count } = await prisma.cMSImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CMSImageDeleteManyArgs>(args?: SelectSubset<T, CMSImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CMSImages
     * const cMSImage = await prisma.cMSImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CMSImageUpdateManyArgs>(args: SelectSubset<T, CMSImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSImages and returns the data updated in the database.
     * @param {CMSImageUpdateManyAndReturnArgs} args - Arguments to update many CMSImages.
     * @example
     * // Update many CMSImages
     * const cMSImage = await prisma.cMSImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CMSImages and only return the `id`
     * const cMSImageWithIdOnly = await prisma.cMSImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CMSImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CMSImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CMSImage.
     * @param {CMSImageUpsertArgs} args - Arguments to update or create a CMSImage.
     * @example
     * // Update or create a CMSImage
     * const cMSImage = await prisma.cMSImage.upsert({
     *   create: {
     *     // ... data to create a CMSImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CMSImage we want to update
     *   }
     * })
     */
    upsert<T extends CMSImageUpsertArgs>(args: SelectSubset<T, CMSImageUpsertArgs<ExtArgs>>): Prisma__CMSImageClient<$Result.GetResult<Prisma.$CMSImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CMSImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageCountArgs} args - Arguments to filter CMSImages to count.
     * @example
     * // Count the number of CMSImages
     * const count = await prisma.cMSImage.count({
     *   where: {
     *     // ... the filter for the CMSImages we want to count
     *   }
     * })
    **/
    count<T extends CMSImageCountArgs>(
      args?: Subset<T, CMSImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CMSImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CMSImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CMSImageAggregateArgs>(args: Subset<T, CMSImageAggregateArgs>): Prisma.PrismaPromise<GetCMSImageAggregateType<T>>

    /**
     * Group by CMSImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CMSImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CMSImageGroupByArgs['orderBy'] }
        : { orderBy?: CMSImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CMSImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCMSImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CMSImage model
   */
  readonly fields: CMSImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CMSImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CMSImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CMSImage model
   */
  interface CMSImageFieldRefs {
    readonly id: FieldRef<"CMSImage", 'String'>
    readonly filename: FieldRef<"CMSImage", 'String'>
    readonly url: FieldRef<"CMSImage", 'String'>
    readonly altText: FieldRef<"CMSImage", 'String'>
    readonly category: FieldRef<"CMSImage", 'String'>
    readonly width: FieldRef<"CMSImage", 'Int'>
    readonly height: FieldRef<"CMSImage", 'Int'>
    readonly fileSize: FieldRef<"CMSImage", 'Int'>
    readonly format: FieldRef<"CMSImage", 'String'>
    readonly usedIn: FieldRef<"CMSImage", 'Json'>
    readonly createdAt: FieldRef<"CMSImage", 'DateTime'>
    readonly updatedAt: FieldRef<"CMSImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CMSImage findUnique
   */
  export type CMSImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter, which CMSImage to fetch.
     */
    where: CMSImageWhereUniqueInput
  }

  /**
   * CMSImage findUniqueOrThrow
   */
  export type CMSImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter, which CMSImage to fetch.
     */
    where: CMSImageWhereUniqueInput
  }

  /**
   * CMSImage findFirst
   */
  export type CMSImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter, which CMSImage to fetch.
     */
    where?: CMSImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSImages to fetch.
     */
    orderBy?: CMSImageOrderByWithRelationInput | CMSImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSImages.
     */
    cursor?: CMSImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSImages.
     */
    distinct?: CMSImageScalarFieldEnum | CMSImageScalarFieldEnum[]
  }

  /**
   * CMSImage findFirstOrThrow
   */
  export type CMSImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter, which CMSImage to fetch.
     */
    where?: CMSImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSImages to fetch.
     */
    orderBy?: CMSImageOrderByWithRelationInput | CMSImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSImages.
     */
    cursor?: CMSImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSImages.
     */
    distinct?: CMSImageScalarFieldEnum | CMSImageScalarFieldEnum[]
  }

  /**
   * CMSImage findMany
   */
  export type CMSImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter, which CMSImages to fetch.
     */
    where?: CMSImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSImages to fetch.
     */
    orderBy?: CMSImageOrderByWithRelationInput | CMSImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CMSImages.
     */
    cursor?: CMSImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSImages.
     */
    skip?: number
    distinct?: CMSImageScalarFieldEnum | CMSImageScalarFieldEnum[]
  }

  /**
   * CMSImage create
   */
  export type CMSImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * The data needed to create a CMSImage.
     */
    data: XOR<CMSImageCreateInput, CMSImageUncheckedCreateInput>
  }

  /**
   * CMSImage createMany
   */
  export type CMSImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CMSImages.
     */
    data: CMSImageCreateManyInput | CMSImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSImage createManyAndReturn
   */
  export type CMSImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * The data used to create many CMSImages.
     */
    data: CMSImageCreateManyInput | CMSImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSImage update
   */
  export type CMSImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * The data needed to update a CMSImage.
     */
    data: XOR<CMSImageUpdateInput, CMSImageUncheckedUpdateInput>
    /**
     * Choose, which CMSImage to update.
     */
    where: CMSImageWhereUniqueInput
  }

  /**
   * CMSImage updateMany
   */
  export type CMSImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CMSImages.
     */
    data: XOR<CMSImageUpdateManyMutationInput, CMSImageUncheckedUpdateManyInput>
    /**
     * Filter which CMSImages to update
     */
    where?: CMSImageWhereInput
    /**
     * Limit how many CMSImages to update.
     */
    limit?: number
  }

  /**
   * CMSImage updateManyAndReturn
   */
  export type CMSImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * The data used to update CMSImages.
     */
    data: XOR<CMSImageUpdateManyMutationInput, CMSImageUncheckedUpdateManyInput>
    /**
     * Filter which CMSImages to update
     */
    where?: CMSImageWhereInput
    /**
     * Limit how many CMSImages to update.
     */
    limit?: number
  }

  /**
   * CMSImage upsert
   */
  export type CMSImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * The filter to search for the CMSImage to update in case it exists.
     */
    where: CMSImageWhereUniqueInput
    /**
     * In case the CMSImage found by the `where` argument doesn't exist, create a new CMSImage with this data.
     */
    create: XOR<CMSImageCreateInput, CMSImageUncheckedCreateInput>
    /**
     * In case the CMSImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CMSImageUpdateInput, CMSImageUncheckedUpdateInput>
  }

  /**
   * CMSImage delete
   */
  export type CMSImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
    /**
     * Filter which CMSImage to delete.
     */
    where: CMSImageWhereUniqueInput
  }

  /**
   * CMSImage deleteMany
   */
  export type CMSImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSImages to delete
     */
    where?: CMSImageWhereInput
    /**
     * Limit how many CMSImages to delete.
     */
    limit?: number
  }

  /**
   * CMSImage without action
   */
  export type CMSImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSImage
     */
    select?: CMSImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSImage
     */
    omit?: CMSImageOmit<ExtArgs> | null
  }


  /**
   * Model HeroSlide
   */

  export type AggregateHeroSlide = {
    _count: HeroSlideCountAggregateOutputType | null
    _avg: HeroSlideAvgAggregateOutputType | null
    _sum: HeroSlideSumAggregateOutputType | null
    _min: HeroSlideMinAggregateOutputType | null
    _max: HeroSlideMaxAggregateOutputType | null
  }

  export type HeroSlideAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type HeroSlideSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type HeroSlideMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    image: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSlideMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    image: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSlideCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    description: number
    image: number
    displayOrder: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroSlideAvgAggregateInputType = {
    displayOrder?: true
  }

  export type HeroSlideSumAggregateInputType = {
    displayOrder?: true
  }

  export type HeroSlideMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    image?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSlideMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    image?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSlideCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    image?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroSlideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSlide to aggregate.
     */
    where?: HeroSlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?: HeroSlideOrderByWithRelationInput | HeroSlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroSlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSlides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroSlides
    **/
    _count?: true | HeroSlideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeroSlideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeroSlideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroSlideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroSlideMaxAggregateInputType
  }

  export type GetHeroSlideAggregateType<T extends HeroSlideAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroSlide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroSlide[P]>
      : GetScalarType<T[P], AggregateHeroSlide[P]>
  }




  export type HeroSlideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroSlideWhereInput
    orderBy?: HeroSlideOrderByWithAggregationInput | HeroSlideOrderByWithAggregationInput[]
    by: HeroSlideScalarFieldEnum[] | HeroSlideScalarFieldEnum
    having?: HeroSlideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroSlideCountAggregateInputType | true
    _avg?: HeroSlideAvgAggregateInputType
    _sum?: HeroSlideSumAggregateInputType
    _min?: HeroSlideMinAggregateInputType
    _max?: HeroSlideMaxAggregateInputType
  }

  export type HeroSlideGroupByOutputType = {
    id: string
    title: string
    subtitle: string
    description: string
    image: string
    displayOrder: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: HeroSlideCountAggregateOutputType | null
    _avg: HeroSlideAvgAggregateOutputType | null
    _sum: HeroSlideSumAggregateOutputType | null
    _min: HeroSlideMinAggregateOutputType | null
    _max: HeroSlideMaxAggregateOutputType | null
  }

  type GetHeroSlideGroupByPayload<T extends HeroSlideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroSlideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroSlideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroSlideGroupByOutputType[P]>
            : GetScalarType<T[P], HeroSlideGroupByOutputType[P]>
        }
      >
    >


  export type HeroSlideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    image?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroSlide"]>

  export type HeroSlideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    image?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroSlide"]>

  export type HeroSlideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    image?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroSlide"]>

  export type HeroSlideSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    image?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroSlideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "description" | "image" | "displayOrder" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["heroSlide"]>

  export type $HeroSlidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroSlide"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string
      description: string
      image: string
      displayOrder: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroSlide"]>
    composites: {}
  }

  type HeroSlideGetPayload<S extends boolean | null | undefined | HeroSlideDefaultArgs> = $Result.GetResult<Prisma.$HeroSlidePayload, S>

  type HeroSlideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroSlideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroSlideCountAggregateInputType | true
    }

  export interface HeroSlideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroSlide'], meta: { name: 'HeroSlide' } }
    /**
     * Find zero or one HeroSlide that matches the filter.
     * @param {HeroSlideFindUniqueArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroSlideFindUniqueArgs>(args: SelectSubset<T, HeroSlideFindUniqueArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroSlide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroSlideFindUniqueOrThrowArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroSlideFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroSlideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSlide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindFirstArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroSlideFindFirstArgs>(args?: SelectSubset<T, HeroSlideFindFirstArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSlide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindFirstOrThrowArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroSlideFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroSlideFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroSlides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroSlides
     * const heroSlides = await prisma.heroSlide.findMany()
     * 
     * // Get first 10 HeroSlides
     * const heroSlides = await prisma.heroSlide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroSlideWithIdOnly = await prisma.heroSlide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroSlideFindManyArgs>(args?: SelectSubset<T, HeroSlideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroSlide.
     * @param {HeroSlideCreateArgs} args - Arguments to create a HeroSlide.
     * @example
     * // Create one HeroSlide
     * const HeroSlide = await prisma.heroSlide.create({
     *   data: {
     *     // ... data to create a HeroSlide
     *   }
     * })
     * 
     */
    create<T extends HeroSlideCreateArgs>(args: SelectSubset<T, HeroSlideCreateArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroSlides.
     * @param {HeroSlideCreateManyArgs} args - Arguments to create many HeroSlides.
     * @example
     * // Create many HeroSlides
     * const heroSlide = await prisma.heroSlide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroSlideCreateManyArgs>(args?: SelectSubset<T, HeroSlideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroSlides and returns the data saved in the database.
     * @param {HeroSlideCreateManyAndReturnArgs} args - Arguments to create many HeroSlides.
     * @example
     * // Create many HeroSlides
     * const heroSlide = await prisma.heroSlide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroSlides and only return the `id`
     * const heroSlideWithIdOnly = await prisma.heroSlide.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroSlideCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroSlideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HeroSlide.
     * @param {HeroSlideDeleteArgs} args - Arguments to delete one HeroSlide.
     * @example
     * // Delete one HeroSlide
     * const HeroSlide = await prisma.heroSlide.delete({
     *   where: {
     *     // ... filter to delete one HeroSlide
     *   }
     * })
     * 
     */
    delete<T extends HeroSlideDeleteArgs>(args: SelectSubset<T, HeroSlideDeleteArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroSlide.
     * @param {HeroSlideUpdateArgs} args - Arguments to update one HeroSlide.
     * @example
     * // Update one HeroSlide
     * const heroSlide = await prisma.heroSlide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroSlideUpdateArgs>(args: SelectSubset<T, HeroSlideUpdateArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroSlides.
     * @param {HeroSlideDeleteManyArgs} args - Arguments to filter HeroSlides to delete.
     * @example
     * // Delete a few HeroSlides
     * const { count } = await prisma.heroSlide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroSlideDeleteManyArgs>(args?: SelectSubset<T, HeroSlideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroSlides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroSlides
     * const heroSlide = await prisma.heroSlide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroSlideUpdateManyArgs>(args: SelectSubset<T, HeroSlideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroSlides and returns the data updated in the database.
     * @param {HeroSlideUpdateManyAndReturnArgs} args - Arguments to update many HeroSlides.
     * @example
     * // Update many HeroSlides
     * const heroSlide = await prisma.heroSlide.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HeroSlides and only return the `id`
     * const heroSlideWithIdOnly = await prisma.heroSlide.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HeroSlideUpdateManyAndReturnArgs>(args: SelectSubset<T, HeroSlideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HeroSlide.
     * @param {HeroSlideUpsertArgs} args - Arguments to update or create a HeroSlide.
     * @example
     * // Update or create a HeroSlide
     * const heroSlide = await prisma.heroSlide.upsert({
     *   create: {
     *     // ... data to create a HeroSlide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroSlide we want to update
     *   }
     * })
     */
    upsert<T extends HeroSlideUpsertArgs>(args: SelectSubset<T, HeroSlideUpsertArgs<ExtArgs>>): Prisma__HeroSlideClient<$Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HeroSlides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideCountArgs} args - Arguments to filter HeroSlides to count.
     * @example
     * // Count the number of HeroSlides
     * const count = await prisma.heroSlide.count({
     *   where: {
     *     // ... the filter for the HeroSlides we want to count
     *   }
     * })
    **/
    count<T extends HeroSlideCountArgs>(
      args?: Subset<T, HeroSlideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroSlideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroSlide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroSlideAggregateArgs>(args: Subset<T, HeroSlideAggregateArgs>): Prisma.PrismaPromise<GetHeroSlideAggregateType<T>>

    /**
     * Group by HeroSlide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroSlideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroSlideGroupByArgs['orderBy'] }
        : { orderBy?: HeroSlideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroSlideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroSlideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroSlide model
   */
  readonly fields: HeroSlideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroSlide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroSlideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroSlide model
   */
  interface HeroSlideFieldRefs {
    readonly id: FieldRef<"HeroSlide", 'String'>
    readonly title: FieldRef<"HeroSlide", 'String'>
    readonly subtitle: FieldRef<"HeroSlide", 'String'>
    readonly description: FieldRef<"HeroSlide", 'String'>
    readonly image: FieldRef<"HeroSlide", 'String'>
    readonly displayOrder: FieldRef<"HeroSlide", 'Int'>
    readonly active: FieldRef<"HeroSlide", 'Boolean'>
    readonly createdAt: FieldRef<"HeroSlide", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroSlide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroSlide findUnique
   */
  export type HeroSlideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter, which HeroSlide to fetch.
     */
    where: HeroSlideWhereUniqueInput
  }

  /**
   * HeroSlide findUniqueOrThrow
   */
  export type HeroSlideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter, which HeroSlide to fetch.
     */
    where: HeroSlideWhereUniqueInput
  }

  /**
   * HeroSlide findFirst
   */
  export type HeroSlideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter, which HeroSlide to fetch.
     */
    where?: HeroSlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?: HeroSlideOrderByWithRelationInput | HeroSlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSlides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSlides.
     */
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[]
  }

  /**
   * HeroSlide findFirstOrThrow
   */
  export type HeroSlideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter, which HeroSlide to fetch.
     */
    where?: HeroSlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?: HeroSlideOrderByWithRelationInput | HeroSlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSlides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSlides.
     */
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[]
  }

  /**
   * HeroSlide findMany
   */
  export type HeroSlideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter, which HeroSlides to fetch.
     */
    where?: HeroSlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?: HeroSlideOrderByWithRelationInput | HeroSlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSlides.
     */
    skip?: number
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[]
  }

  /**
   * HeroSlide create
   */
  export type HeroSlideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * The data needed to create a HeroSlide.
     */
    data: XOR<HeroSlideCreateInput, HeroSlideUncheckedCreateInput>
  }

  /**
   * HeroSlide createMany
   */
  export type HeroSlideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroSlides.
     */
    data: HeroSlideCreateManyInput | HeroSlideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroSlide createManyAndReturn
   */
  export type HeroSlideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * The data used to create many HeroSlides.
     */
    data: HeroSlideCreateManyInput | HeroSlideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroSlide update
   */
  export type HeroSlideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * The data needed to update a HeroSlide.
     */
    data: XOR<HeroSlideUpdateInput, HeroSlideUncheckedUpdateInput>
    /**
     * Choose, which HeroSlide to update.
     */
    where: HeroSlideWhereUniqueInput
  }

  /**
   * HeroSlide updateMany
   */
  export type HeroSlideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroSlides.
     */
    data: XOR<HeroSlideUpdateManyMutationInput, HeroSlideUncheckedUpdateManyInput>
    /**
     * Filter which HeroSlides to update
     */
    where?: HeroSlideWhereInput
    /**
     * Limit how many HeroSlides to update.
     */
    limit?: number
  }

  /**
   * HeroSlide updateManyAndReturn
   */
  export type HeroSlideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * The data used to update HeroSlides.
     */
    data: XOR<HeroSlideUpdateManyMutationInput, HeroSlideUncheckedUpdateManyInput>
    /**
     * Filter which HeroSlides to update
     */
    where?: HeroSlideWhereInput
    /**
     * Limit how many HeroSlides to update.
     */
    limit?: number
  }

  /**
   * HeroSlide upsert
   */
  export type HeroSlideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * The filter to search for the HeroSlide to update in case it exists.
     */
    where: HeroSlideWhereUniqueInput
    /**
     * In case the HeroSlide found by the `where` argument doesn't exist, create a new HeroSlide with this data.
     */
    create: XOR<HeroSlideCreateInput, HeroSlideUncheckedCreateInput>
    /**
     * In case the HeroSlide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroSlideUpdateInput, HeroSlideUncheckedUpdateInput>
  }

  /**
   * HeroSlide delete
   */
  export type HeroSlideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
    /**
     * Filter which HeroSlide to delete.
     */
    where: HeroSlideWhereUniqueInput
  }

  /**
   * HeroSlide deleteMany
   */
  export type HeroSlideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSlides to delete
     */
    where?: HeroSlideWhereInput
    /**
     * Limit how many HeroSlides to delete.
     */
    limit?: number
  }

  /**
   * HeroSlide without action
   */
  export type HeroSlideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSlide
     */
    omit?: HeroSlideOmit<ExtArgs> | null
  }


  /**
   * Model CMSDestination
   */

  export type AggregateCMSDestination = {
    _count: CMSDestinationCountAggregateOutputType | null
    _avg: CMSDestinationAvgAggregateOutputType | null
    _sum: CMSDestinationSumAggregateOutputType | null
    _min: CMSDestinationMinAggregateOutputType | null
    _max: CMSDestinationMaxAggregateOutputType | null
  }

  export type CMSDestinationAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type CMSDestinationSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type CMSDestinationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    region: string | null
    country: string | null
    description: string | null
    shortDesc: string | null
    heroImage: string | null
    history: string | null
    geography: string | null
    climate: string | null
    wildlife: string | null
    bestTime: string | null
    featured: boolean | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CMSDestinationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    region: string | null
    country: string | null
    description: string | null
    shortDesc: string | null
    heroImage: string | null
    history: string | null
    geography: string | null
    climate: string | null
    wildlife: string | null
    bestTime: string | null
    featured: boolean | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CMSDestinationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    category: number
    region: number
    country: number
    description: number
    shortDesc: number
    heroImage: number
    gallery: number
    history: number
    geography: number
    climate: number
    wildlife: number
    keyWildlife: number
    flora: number
    cultural: number
    bestTime: number
    featured: number
    active: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CMSDestinationAvgAggregateInputType = {
    displayOrder?: true
  }

  export type CMSDestinationSumAggregateInputType = {
    displayOrder?: true
  }

  export type CMSDestinationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    region?: true
    country?: true
    description?: true
    shortDesc?: true
    heroImage?: true
    history?: true
    geography?: true
    climate?: true
    wildlife?: true
    bestTime?: true
    featured?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CMSDestinationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    region?: true
    country?: true
    description?: true
    shortDesc?: true
    heroImage?: true
    history?: true
    geography?: true
    climate?: true
    wildlife?: true
    bestTime?: true
    featured?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CMSDestinationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    region?: true
    country?: true
    description?: true
    shortDesc?: true
    heroImage?: true
    gallery?: true
    history?: true
    geography?: true
    climate?: true
    wildlife?: true
    keyWildlife?: true
    flora?: true
    cultural?: true
    bestTime?: true
    featured?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CMSDestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSDestination to aggregate.
     */
    where?: CMSDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSDestinations to fetch.
     */
    orderBy?: CMSDestinationOrderByWithRelationInput | CMSDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CMSDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CMSDestinations
    **/
    _count?: true | CMSDestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CMSDestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CMSDestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CMSDestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CMSDestinationMaxAggregateInputType
  }

  export type GetCMSDestinationAggregateType<T extends CMSDestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateCMSDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCMSDestination[P]>
      : GetScalarType<T[P], AggregateCMSDestination[P]>
  }




  export type CMSDestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CMSDestinationWhereInput
    orderBy?: CMSDestinationOrderByWithAggregationInput | CMSDestinationOrderByWithAggregationInput[]
    by: CMSDestinationScalarFieldEnum[] | CMSDestinationScalarFieldEnum
    having?: CMSDestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CMSDestinationCountAggregateInputType | true
    _avg?: CMSDestinationAvgAggregateInputType
    _sum?: CMSDestinationSumAggregateInputType
    _min?: CMSDestinationMinAggregateInputType
    _max?: CMSDestinationMaxAggregateInputType
  }

  export type CMSDestinationGroupByOutputType = {
    id: string
    name: string
    slug: string
    category: string
    region: string
    country: string
    description: string
    shortDesc: string | null
    heroImage: string
    gallery: JsonValue
    history: string | null
    geography: string | null
    climate: string | null
    wildlife: string | null
    keyWildlife: JsonValue | null
    flora: JsonValue | null
    cultural: JsonValue | null
    bestTime: string | null
    featured: boolean
    active: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CMSDestinationCountAggregateOutputType | null
    _avg: CMSDestinationAvgAggregateOutputType | null
    _sum: CMSDestinationSumAggregateOutputType | null
    _min: CMSDestinationMinAggregateOutputType | null
    _max: CMSDestinationMaxAggregateOutputType | null
  }

  type GetCMSDestinationGroupByPayload<T extends CMSDestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CMSDestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CMSDestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CMSDestinationGroupByOutputType[P]>
            : GetScalarType<T[P], CMSDestinationGroupByOutputType[P]>
        }
      >
    >


  export type CMSDestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    region?: boolean
    country?: boolean
    description?: boolean
    shortDesc?: boolean
    heroImage?: boolean
    gallery?: boolean
    history?: boolean
    geography?: boolean
    climate?: boolean
    wildlife?: boolean
    keyWildlife?: boolean
    flora?: boolean
    cultural?: boolean
    bestTime?: boolean
    featured?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSDestination"]>

  export type CMSDestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    region?: boolean
    country?: boolean
    description?: boolean
    shortDesc?: boolean
    heroImage?: boolean
    gallery?: boolean
    history?: boolean
    geography?: boolean
    climate?: boolean
    wildlife?: boolean
    keyWildlife?: boolean
    flora?: boolean
    cultural?: boolean
    bestTime?: boolean
    featured?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSDestination"]>

  export type CMSDestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    region?: boolean
    country?: boolean
    description?: boolean
    shortDesc?: boolean
    heroImage?: boolean
    gallery?: boolean
    history?: boolean
    geography?: boolean
    climate?: boolean
    wildlife?: boolean
    keyWildlife?: boolean
    flora?: boolean
    cultural?: boolean
    bestTime?: boolean
    featured?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cMSDestination"]>

  export type CMSDestinationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    region?: boolean
    country?: boolean
    description?: boolean
    shortDesc?: boolean
    heroImage?: boolean
    gallery?: boolean
    history?: boolean
    geography?: boolean
    climate?: boolean
    wildlife?: boolean
    keyWildlife?: boolean
    flora?: boolean
    cultural?: boolean
    bestTime?: boolean
    featured?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CMSDestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "category" | "region" | "country" | "description" | "shortDesc" | "heroImage" | "gallery" | "history" | "geography" | "climate" | "wildlife" | "keyWildlife" | "flora" | "cultural" | "bestTime" | "featured" | "active" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["cMSDestination"]>

  export type $CMSDestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CMSDestination"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      category: string
      region: string
      country: string
      description: string
      shortDesc: string | null
      heroImage: string
      gallery: Prisma.JsonValue
      history: string | null
      geography: string | null
      climate: string | null
      wildlife: string | null
      keyWildlife: Prisma.JsonValue | null
      flora: Prisma.JsonValue | null
      cultural: Prisma.JsonValue | null
      bestTime: string | null
      featured: boolean
      active: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cMSDestination"]>
    composites: {}
  }

  type CMSDestinationGetPayload<S extends boolean | null | undefined | CMSDestinationDefaultArgs> = $Result.GetResult<Prisma.$CMSDestinationPayload, S>

  type CMSDestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CMSDestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CMSDestinationCountAggregateInputType | true
    }

  export interface CMSDestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CMSDestination'], meta: { name: 'CMSDestination' } }
    /**
     * Find zero or one CMSDestination that matches the filter.
     * @param {CMSDestinationFindUniqueArgs} args - Arguments to find a CMSDestination
     * @example
     * // Get one CMSDestination
     * const cMSDestination = await prisma.cMSDestination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CMSDestinationFindUniqueArgs>(args: SelectSubset<T, CMSDestinationFindUniqueArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CMSDestination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CMSDestinationFindUniqueOrThrowArgs} args - Arguments to find a CMSDestination
     * @example
     * // Get one CMSDestination
     * const cMSDestination = await prisma.cMSDestination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CMSDestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, CMSDestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSDestination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationFindFirstArgs} args - Arguments to find a CMSDestination
     * @example
     * // Get one CMSDestination
     * const cMSDestination = await prisma.cMSDestination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CMSDestinationFindFirstArgs>(args?: SelectSubset<T, CMSDestinationFindFirstArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSDestination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationFindFirstOrThrowArgs} args - Arguments to find a CMSDestination
     * @example
     * // Get one CMSDestination
     * const cMSDestination = await prisma.cMSDestination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CMSDestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, CMSDestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CMSDestinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CMSDestinations
     * const cMSDestinations = await prisma.cMSDestination.findMany()
     * 
     * // Get first 10 CMSDestinations
     * const cMSDestinations = await prisma.cMSDestination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cMSDestinationWithIdOnly = await prisma.cMSDestination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CMSDestinationFindManyArgs>(args?: SelectSubset<T, CMSDestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CMSDestination.
     * @param {CMSDestinationCreateArgs} args - Arguments to create a CMSDestination.
     * @example
     * // Create one CMSDestination
     * const CMSDestination = await prisma.cMSDestination.create({
     *   data: {
     *     // ... data to create a CMSDestination
     *   }
     * })
     * 
     */
    create<T extends CMSDestinationCreateArgs>(args: SelectSubset<T, CMSDestinationCreateArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CMSDestinations.
     * @param {CMSDestinationCreateManyArgs} args - Arguments to create many CMSDestinations.
     * @example
     * // Create many CMSDestinations
     * const cMSDestination = await prisma.cMSDestination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CMSDestinationCreateManyArgs>(args?: SelectSubset<T, CMSDestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CMSDestinations and returns the data saved in the database.
     * @param {CMSDestinationCreateManyAndReturnArgs} args - Arguments to create many CMSDestinations.
     * @example
     * // Create many CMSDestinations
     * const cMSDestination = await prisma.cMSDestination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CMSDestinations and only return the `id`
     * const cMSDestinationWithIdOnly = await prisma.cMSDestination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CMSDestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, CMSDestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CMSDestination.
     * @param {CMSDestinationDeleteArgs} args - Arguments to delete one CMSDestination.
     * @example
     * // Delete one CMSDestination
     * const CMSDestination = await prisma.cMSDestination.delete({
     *   where: {
     *     // ... filter to delete one CMSDestination
     *   }
     * })
     * 
     */
    delete<T extends CMSDestinationDeleteArgs>(args: SelectSubset<T, CMSDestinationDeleteArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CMSDestination.
     * @param {CMSDestinationUpdateArgs} args - Arguments to update one CMSDestination.
     * @example
     * // Update one CMSDestination
     * const cMSDestination = await prisma.cMSDestination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CMSDestinationUpdateArgs>(args: SelectSubset<T, CMSDestinationUpdateArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CMSDestinations.
     * @param {CMSDestinationDeleteManyArgs} args - Arguments to filter CMSDestinations to delete.
     * @example
     * // Delete a few CMSDestinations
     * const { count } = await prisma.cMSDestination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CMSDestinationDeleteManyArgs>(args?: SelectSubset<T, CMSDestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CMSDestinations
     * const cMSDestination = await prisma.cMSDestination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CMSDestinationUpdateManyArgs>(args: SelectSubset<T, CMSDestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSDestinations and returns the data updated in the database.
     * @param {CMSDestinationUpdateManyAndReturnArgs} args - Arguments to update many CMSDestinations.
     * @example
     * // Update many CMSDestinations
     * const cMSDestination = await prisma.cMSDestination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CMSDestinations and only return the `id`
     * const cMSDestinationWithIdOnly = await prisma.cMSDestination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CMSDestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, CMSDestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CMSDestination.
     * @param {CMSDestinationUpsertArgs} args - Arguments to update or create a CMSDestination.
     * @example
     * // Update or create a CMSDestination
     * const cMSDestination = await prisma.cMSDestination.upsert({
     *   create: {
     *     // ... data to create a CMSDestination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CMSDestination we want to update
     *   }
     * })
     */
    upsert<T extends CMSDestinationUpsertArgs>(args: SelectSubset<T, CMSDestinationUpsertArgs<ExtArgs>>): Prisma__CMSDestinationClient<$Result.GetResult<Prisma.$CMSDestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CMSDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationCountArgs} args - Arguments to filter CMSDestinations to count.
     * @example
     * // Count the number of CMSDestinations
     * const count = await prisma.cMSDestination.count({
     *   where: {
     *     // ... the filter for the CMSDestinations we want to count
     *   }
     * })
    **/
    count<T extends CMSDestinationCountArgs>(
      args?: Subset<T, CMSDestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CMSDestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CMSDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CMSDestinationAggregateArgs>(args: Subset<T, CMSDestinationAggregateArgs>): Prisma.PrismaPromise<GetCMSDestinationAggregateType<T>>

    /**
     * Group by CMSDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSDestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CMSDestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CMSDestinationGroupByArgs['orderBy'] }
        : { orderBy?: CMSDestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CMSDestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCMSDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CMSDestination model
   */
  readonly fields: CMSDestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CMSDestination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CMSDestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CMSDestination model
   */
  interface CMSDestinationFieldRefs {
    readonly id: FieldRef<"CMSDestination", 'String'>
    readonly name: FieldRef<"CMSDestination", 'String'>
    readonly slug: FieldRef<"CMSDestination", 'String'>
    readonly category: FieldRef<"CMSDestination", 'String'>
    readonly region: FieldRef<"CMSDestination", 'String'>
    readonly country: FieldRef<"CMSDestination", 'String'>
    readonly description: FieldRef<"CMSDestination", 'String'>
    readonly shortDesc: FieldRef<"CMSDestination", 'String'>
    readonly heroImage: FieldRef<"CMSDestination", 'String'>
    readonly gallery: FieldRef<"CMSDestination", 'Json'>
    readonly history: FieldRef<"CMSDestination", 'String'>
    readonly geography: FieldRef<"CMSDestination", 'String'>
    readonly climate: FieldRef<"CMSDestination", 'String'>
    readonly wildlife: FieldRef<"CMSDestination", 'String'>
    readonly keyWildlife: FieldRef<"CMSDestination", 'Json'>
    readonly flora: FieldRef<"CMSDestination", 'Json'>
    readonly cultural: FieldRef<"CMSDestination", 'Json'>
    readonly bestTime: FieldRef<"CMSDestination", 'String'>
    readonly featured: FieldRef<"CMSDestination", 'Boolean'>
    readonly active: FieldRef<"CMSDestination", 'Boolean'>
    readonly displayOrder: FieldRef<"CMSDestination", 'Int'>
    readonly createdAt: FieldRef<"CMSDestination", 'DateTime'>
    readonly updatedAt: FieldRef<"CMSDestination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CMSDestination findUnique
   */
  export type CMSDestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter, which CMSDestination to fetch.
     */
    where: CMSDestinationWhereUniqueInput
  }

  /**
   * CMSDestination findUniqueOrThrow
   */
  export type CMSDestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter, which CMSDestination to fetch.
     */
    where: CMSDestinationWhereUniqueInput
  }

  /**
   * CMSDestination findFirst
   */
  export type CMSDestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter, which CMSDestination to fetch.
     */
    where?: CMSDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSDestinations to fetch.
     */
    orderBy?: CMSDestinationOrderByWithRelationInput | CMSDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSDestinations.
     */
    cursor?: CMSDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSDestinations.
     */
    distinct?: CMSDestinationScalarFieldEnum | CMSDestinationScalarFieldEnum[]
  }

  /**
   * CMSDestination findFirstOrThrow
   */
  export type CMSDestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter, which CMSDestination to fetch.
     */
    where?: CMSDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSDestinations to fetch.
     */
    orderBy?: CMSDestinationOrderByWithRelationInput | CMSDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSDestinations.
     */
    cursor?: CMSDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSDestinations.
     */
    distinct?: CMSDestinationScalarFieldEnum | CMSDestinationScalarFieldEnum[]
  }

  /**
   * CMSDestination findMany
   */
  export type CMSDestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter, which CMSDestinations to fetch.
     */
    where?: CMSDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSDestinations to fetch.
     */
    orderBy?: CMSDestinationOrderByWithRelationInput | CMSDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CMSDestinations.
     */
    cursor?: CMSDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSDestinations.
     */
    skip?: number
    distinct?: CMSDestinationScalarFieldEnum | CMSDestinationScalarFieldEnum[]
  }

  /**
   * CMSDestination create
   */
  export type CMSDestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * The data needed to create a CMSDestination.
     */
    data: XOR<CMSDestinationCreateInput, CMSDestinationUncheckedCreateInput>
  }

  /**
   * CMSDestination createMany
   */
  export type CMSDestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CMSDestinations.
     */
    data: CMSDestinationCreateManyInput | CMSDestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSDestination createManyAndReturn
   */
  export type CMSDestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * The data used to create many CMSDestinations.
     */
    data: CMSDestinationCreateManyInput | CMSDestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSDestination update
   */
  export type CMSDestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * The data needed to update a CMSDestination.
     */
    data: XOR<CMSDestinationUpdateInput, CMSDestinationUncheckedUpdateInput>
    /**
     * Choose, which CMSDestination to update.
     */
    where: CMSDestinationWhereUniqueInput
  }

  /**
   * CMSDestination updateMany
   */
  export type CMSDestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CMSDestinations.
     */
    data: XOR<CMSDestinationUpdateManyMutationInput, CMSDestinationUncheckedUpdateManyInput>
    /**
     * Filter which CMSDestinations to update
     */
    where?: CMSDestinationWhereInput
    /**
     * Limit how many CMSDestinations to update.
     */
    limit?: number
  }

  /**
   * CMSDestination updateManyAndReturn
   */
  export type CMSDestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * The data used to update CMSDestinations.
     */
    data: XOR<CMSDestinationUpdateManyMutationInput, CMSDestinationUncheckedUpdateManyInput>
    /**
     * Filter which CMSDestinations to update
     */
    where?: CMSDestinationWhereInput
    /**
     * Limit how many CMSDestinations to update.
     */
    limit?: number
  }

  /**
   * CMSDestination upsert
   */
  export type CMSDestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * The filter to search for the CMSDestination to update in case it exists.
     */
    where: CMSDestinationWhereUniqueInput
    /**
     * In case the CMSDestination found by the `where` argument doesn't exist, create a new CMSDestination with this data.
     */
    create: XOR<CMSDestinationCreateInput, CMSDestinationUncheckedCreateInput>
    /**
     * In case the CMSDestination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CMSDestinationUpdateInput, CMSDestinationUncheckedUpdateInput>
  }

  /**
   * CMSDestination delete
   */
  export type CMSDestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
    /**
     * Filter which CMSDestination to delete.
     */
    where: CMSDestinationWhereUniqueInput
  }

  /**
   * CMSDestination deleteMany
   */
  export type CMSDestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSDestinations to delete
     */
    where?: CMSDestinationWhereInput
    /**
     * Limit how many CMSDestinations to delete.
     */
    limit?: number
  }

  /**
   * CMSDestination without action
   */
  export type CMSDestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSDestination
     */
    select?: CMSDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSDestination
     */
    omit?: CMSDestinationOmit<ExtArgs> | null
  }


  /**
   * Model SiteSettings
   */

  export type AggregateSiteSettings = {
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  export type SiteSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SiteSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SiteSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SiteSettingsMinAggregateInputType = {
    id?: true
    key?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SiteSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SiteSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to aggregate.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type GetSiteSettingsAggregateType<T extends SiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSettings[P]>
      : GetScalarType<T[P], AggregateSiteSettings[P]>
  }




  export type SiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingsWhereInput
    orderBy?: SiteSettingsOrderByWithAggregationInput | SiteSettingsOrderByWithAggregationInput[]
    by: SiteSettingsScalarFieldEnum[] | SiteSettingsScalarFieldEnum
    having?: SiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingsCountAggregateInputType | true
    _min?: SiteSettingsMinAggregateInputType
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type SiteSettingsGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    category: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  type GetSiteSettingsGroupByPayload<T extends SiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "updatedAt" | "updatedBy", ExtArgs["result"]["siteSettings"]>

  export type $SiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      category: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["siteSettings"]>
    composites: {}
  }

  type SiteSettingsGetPayload<S extends boolean | null | undefined | SiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingsPayload, S>

  type SiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteSettingsCountAggregateInputType | true
    }

  export interface SiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSettings'], meta: { name: 'SiteSettings' } }
    /**
     * Find zero or one SiteSettings that matches the filter.
     * @param {SiteSettingsFindUniqueArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingsFindUniqueArgs>(args: SelectSubset<T, SiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingsFindFirstArgs>(args?: SelectSubset<T, SiteSettingsFindFirstArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteSettingsFindManyArgs>(args?: SelectSubset<T, SiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteSettings.
     * @param {SiteSettingsCreateArgs} args - Arguments to create a SiteSettings.
     * @example
     * // Create one SiteSettings
     * const SiteSettings = await prisma.siteSettings.create({
     *   data: {
     *     // ... data to create a SiteSettings
     *   }
     * })
     * 
     */
    create<T extends SiteSettingsCreateArgs>(args: SelectSubset<T, SiteSettingsCreateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingsCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingsCreateManyArgs>(args?: SelectSubset<T, SiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteSettings and returns the data saved in the database.
     * @param {SiteSettingsCreateManyAndReturnArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteSettings.
     * @param {SiteSettingsDeleteArgs} args - Arguments to delete one SiteSettings.
     * @example
     * // Delete one SiteSettings
     * const SiteSettings = await prisma.siteSettings.delete({
     *   where: {
     *     // ... filter to delete one SiteSettings
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingsDeleteArgs>(args: SelectSubset<T, SiteSettingsDeleteArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteSettings.
     * @param {SiteSettingsUpdateArgs} args - Arguments to update one SiteSettings.
     * @example
     * // Update one SiteSettings
     * const siteSettings = await prisma.siteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingsUpdateArgs>(args: SelectSubset<T, SiteSettingsUpdateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingsDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingsDeleteManyArgs>(args?: SelectSubset<T, SiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingsUpdateManyArgs>(args: SelectSubset<T, SiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings and returns the data updated in the database.
     * @param {SiteSettingsUpdateManyAndReturnArgs} args - Arguments to update many SiteSettings.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteSettings.
     * @param {SiteSettingsUpsertArgs} args - Arguments to update or create a SiteSettings.
     * @example
     * // Update or create a SiteSettings
     * const siteSettings = await prisma.siteSettings.upsert({
     *   create: {
     *     // ... data to create a SiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingsUpsertArgs>(args: SelectSubset<T, SiteSettingsUpsertArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSettings.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingsCountArgs>(
      args?: Subset<T, SiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingsAggregateArgs>(args: Subset<T, SiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingsAggregateType<T>>

    /**
     * Group by SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSettings model
   */
  readonly fields: SiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSettings model
   */
  interface SiteSettingsFieldRefs {
    readonly id: FieldRef<"SiteSettings", 'String'>
    readonly key: FieldRef<"SiteSettings", 'String'>
    readonly value: FieldRef<"SiteSettings", 'Json'>
    readonly category: FieldRef<"SiteSettings", 'String'>
    readonly updatedAt: FieldRef<"SiteSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"SiteSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SiteSettings findUnique
   */
  export type SiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findUniqueOrThrow
   */
  export type SiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findFirst
   */
  export type SiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findFirstOrThrow
   */
  export type SiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findMany
   */
  export type SiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings create
   */
  export type SiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteSettings.
     */
    data: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
  }

  /**
   * SiteSettings createMany
   */
  export type SiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings createManyAndReturn
   */
  export type SiteSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings update
   */
  export type SiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteSettings.
     */
    data: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which SiteSettings to update.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings updateMany
   */
  export type SiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings updateManyAndReturn
   */
  export type SiteSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings upsert
   */
  export type SiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteSettings to update in case it exists.
     */
    where: SiteSettingsWhereUniqueInput
    /**
     * In case the SiteSettings found by the `where` argument doesn't exist, create a new SiteSettings with this data.
     */
    create: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
    /**
     * In case the SiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
  }

  /**
   * SiteSettings delete
   */
  export type SiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter which SiteSettings to delete.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings deleteMany
   */
  export type SiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to delete.
     */
    limit?: number
  }

  /**
   * SiteSettings without action
   */
  export type SiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    bio: string | null
    image: string | null
    years: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    bio: string | null
    image: string | null
    years: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    name: number
    role: number
    bio: number
    image: number
    years: number
    specialties: number
    displayOrder: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TeamMemberSumAggregateInputType = {
    displayOrder?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    bio?: true
    image?: true
    years?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    bio?: true
    image?: true
    years?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    bio?: true
    image?: true
    years?: true
    specialties?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    name: string
    role: string
    bio: string
    image: string
    years: string
    specialties: JsonValue
    displayOrder: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    bio?: boolean
    image?: boolean
    years?: boolean
    specialties?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    bio?: boolean
    image?: boolean
    years?: boolean
    specialties?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    bio?: boolean
    image?: boolean
    years?: boolean
    specialties?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    bio?: boolean
    image?: boolean
    years?: boolean
    specialties?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "bio" | "image" | "years" | "specialties" | "displayOrder" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      bio: string
      image: string
      years: string
      specialties: Prisma.JsonValue
      displayOrder: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly name: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly bio: FieldRef<"TeamMember", 'String'>
    readonly image: FieldRef<"TeamMember", 'String'>
    readonly years: FieldRef<"TeamMember", 'String'>
    readonly specialties: FieldRef<"TeamMember", 'Json'>
    readonly displayOrder: FieldRef<"TeamMember", 'Int'>
    readonly active: FieldRef<"TeamMember", 'Boolean'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type FAQSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type FAQMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    displayOrder: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FAQAvgAggregateInputType = {
    displayOrder?: true
  }

  export type FAQSumAggregateInputType = {
    displayOrder?: true
  }

  export type FAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _avg?: FAQAvgAggregateInputType
    _sum?: FAQSumAggregateInputType
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: string
    question: string
    answer: string
    category: string | null
    displayOrder: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FAQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "displayOrder" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["fAQ"]>

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      category: string | null
      displayOrder: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS and returns the data updated in the database.
     * @param {FAQUpdateManyAndReturnArgs} args - Arguments to update many FAQS.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'String'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
    readonly category: FieldRef<"FAQ", 'String'>
    readonly displayOrder: FieldRef<"FAQ", 'Int'>
    readonly active: FieldRef<"FAQ", 'Boolean'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ updateManyAndReturn
   */
  export type FAQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to delete.
     */
    limit?: number
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
  }


  /**
   * Model CMSAuditLog
   */

  export type AggregateCMSAuditLog = {
    _count: CMSAuditLogCountAggregateOutputType | null
    _min: CMSAuditLogMinAggregateOutputType | null
    _max: CMSAuditLogMaxAggregateOutputType | null
  }

  export type CMSAuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type CMSAuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type CMSAuditLogCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type CMSAuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type CMSAuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type CMSAuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type CMSAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSAuditLog to aggregate.
     */
    where?: CMSAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSAuditLogs to fetch.
     */
    orderBy?: CMSAuditLogOrderByWithRelationInput | CMSAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CMSAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CMSAuditLogs
    **/
    _count?: true | CMSAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CMSAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CMSAuditLogMaxAggregateInputType
  }

  export type GetCMSAuditLogAggregateType<T extends CMSAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCMSAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCMSAuditLog[P]>
      : GetScalarType<T[P], AggregateCMSAuditLog[P]>
  }




  export type CMSAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CMSAuditLogWhereInput
    orderBy?: CMSAuditLogOrderByWithAggregationInput | CMSAuditLogOrderByWithAggregationInput[]
    by: CMSAuditLogScalarFieldEnum[] | CMSAuditLogScalarFieldEnum
    having?: CMSAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CMSAuditLogCountAggregateInputType | true
    _min?: CMSAuditLogMinAggregateInputType
    _max?: CMSAuditLogMaxAggregateInputType
  }

  export type CMSAuditLogGroupByOutputType = {
    id: string
    userId: string
    userName: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: CMSAuditLogCountAggregateOutputType | null
    _min: CMSAuditLogMinAggregateOutputType | null
    _max: CMSAuditLogMaxAggregateOutputType | null
  }

  type GetCMSAuditLogGroupByPayload<T extends CMSAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CMSAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CMSAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CMSAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], CMSAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type CMSAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cMSAuditLog"]>

  export type CMSAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cMSAuditLog"]>

  export type CMSAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cMSAuditLog"]>

  export type CMSAuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type CMSAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["cMSAuditLog"]>

  export type $CMSAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CMSAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string | null
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["cMSAuditLog"]>
    composites: {}
  }

  type CMSAuditLogGetPayload<S extends boolean | null | undefined | CMSAuditLogDefaultArgs> = $Result.GetResult<Prisma.$CMSAuditLogPayload, S>

  type CMSAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CMSAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CMSAuditLogCountAggregateInputType | true
    }

  export interface CMSAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CMSAuditLog'], meta: { name: 'CMSAuditLog' } }
    /**
     * Find zero or one CMSAuditLog that matches the filter.
     * @param {CMSAuditLogFindUniqueArgs} args - Arguments to find a CMSAuditLog
     * @example
     * // Get one CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CMSAuditLogFindUniqueArgs>(args: SelectSubset<T, CMSAuditLogFindUniqueArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CMSAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CMSAuditLogFindUniqueOrThrowArgs} args - Arguments to find a CMSAuditLog
     * @example
     * // Get one CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CMSAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CMSAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogFindFirstArgs} args - Arguments to find a CMSAuditLog
     * @example
     * // Get one CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CMSAuditLogFindFirstArgs>(args?: SelectSubset<T, CMSAuditLogFindFirstArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CMSAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogFindFirstOrThrowArgs} args - Arguments to find a CMSAuditLog
     * @example
     * // Get one CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CMSAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CMSAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CMSAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CMSAuditLogs
     * const cMSAuditLogs = await prisma.cMSAuditLog.findMany()
     * 
     * // Get first 10 CMSAuditLogs
     * const cMSAuditLogs = await prisma.cMSAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cMSAuditLogWithIdOnly = await prisma.cMSAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CMSAuditLogFindManyArgs>(args?: SelectSubset<T, CMSAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CMSAuditLog.
     * @param {CMSAuditLogCreateArgs} args - Arguments to create a CMSAuditLog.
     * @example
     * // Create one CMSAuditLog
     * const CMSAuditLog = await prisma.cMSAuditLog.create({
     *   data: {
     *     // ... data to create a CMSAuditLog
     *   }
     * })
     * 
     */
    create<T extends CMSAuditLogCreateArgs>(args: SelectSubset<T, CMSAuditLogCreateArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CMSAuditLogs.
     * @param {CMSAuditLogCreateManyArgs} args - Arguments to create many CMSAuditLogs.
     * @example
     * // Create many CMSAuditLogs
     * const cMSAuditLog = await prisma.cMSAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CMSAuditLogCreateManyArgs>(args?: SelectSubset<T, CMSAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CMSAuditLogs and returns the data saved in the database.
     * @param {CMSAuditLogCreateManyAndReturnArgs} args - Arguments to create many CMSAuditLogs.
     * @example
     * // Create many CMSAuditLogs
     * const cMSAuditLog = await prisma.cMSAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CMSAuditLogs and only return the `id`
     * const cMSAuditLogWithIdOnly = await prisma.cMSAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CMSAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CMSAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CMSAuditLog.
     * @param {CMSAuditLogDeleteArgs} args - Arguments to delete one CMSAuditLog.
     * @example
     * // Delete one CMSAuditLog
     * const CMSAuditLog = await prisma.cMSAuditLog.delete({
     *   where: {
     *     // ... filter to delete one CMSAuditLog
     *   }
     * })
     * 
     */
    delete<T extends CMSAuditLogDeleteArgs>(args: SelectSubset<T, CMSAuditLogDeleteArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CMSAuditLog.
     * @param {CMSAuditLogUpdateArgs} args - Arguments to update one CMSAuditLog.
     * @example
     * // Update one CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CMSAuditLogUpdateArgs>(args: SelectSubset<T, CMSAuditLogUpdateArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CMSAuditLogs.
     * @param {CMSAuditLogDeleteManyArgs} args - Arguments to filter CMSAuditLogs to delete.
     * @example
     * // Delete a few CMSAuditLogs
     * const { count } = await prisma.cMSAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CMSAuditLogDeleteManyArgs>(args?: SelectSubset<T, CMSAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CMSAuditLogs
     * const cMSAuditLog = await prisma.cMSAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CMSAuditLogUpdateManyArgs>(args: SelectSubset<T, CMSAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CMSAuditLogs and returns the data updated in the database.
     * @param {CMSAuditLogUpdateManyAndReturnArgs} args - Arguments to update many CMSAuditLogs.
     * @example
     * // Update many CMSAuditLogs
     * const cMSAuditLog = await prisma.cMSAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CMSAuditLogs and only return the `id`
     * const cMSAuditLogWithIdOnly = await prisma.cMSAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CMSAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CMSAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CMSAuditLog.
     * @param {CMSAuditLogUpsertArgs} args - Arguments to update or create a CMSAuditLog.
     * @example
     * // Update or create a CMSAuditLog
     * const cMSAuditLog = await prisma.cMSAuditLog.upsert({
     *   create: {
     *     // ... data to create a CMSAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CMSAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends CMSAuditLogUpsertArgs>(args: SelectSubset<T, CMSAuditLogUpsertArgs<ExtArgs>>): Prisma__CMSAuditLogClient<$Result.GetResult<Prisma.$CMSAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CMSAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogCountArgs} args - Arguments to filter CMSAuditLogs to count.
     * @example
     * // Count the number of CMSAuditLogs
     * const count = await prisma.cMSAuditLog.count({
     *   where: {
     *     // ... the filter for the CMSAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends CMSAuditLogCountArgs>(
      args?: Subset<T, CMSAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CMSAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CMSAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CMSAuditLogAggregateArgs>(args: Subset<T, CMSAuditLogAggregateArgs>): Prisma.PrismaPromise<GetCMSAuditLogAggregateType<T>>

    /**
     * Group by CMSAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CMSAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CMSAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CMSAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: CMSAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CMSAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCMSAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CMSAuditLog model
   */
  readonly fields: CMSAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CMSAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CMSAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CMSAuditLog model
   */
  interface CMSAuditLogFieldRefs {
    readonly id: FieldRef<"CMSAuditLog", 'String'>
    readonly userId: FieldRef<"CMSAuditLog", 'String'>
    readonly userName: FieldRef<"CMSAuditLog", 'String'>
    readonly action: FieldRef<"CMSAuditLog", 'String'>
    readonly entityType: FieldRef<"CMSAuditLog", 'String'>
    readonly entityId: FieldRef<"CMSAuditLog", 'String'>
    readonly changes: FieldRef<"CMSAuditLog", 'Json'>
    readonly ipAddress: FieldRef<"CMSAuditLog", 'String'>
    readonly userAgent: FieldRef<"CMSAuditLog", 'String'>
    readonly createdAt: FieldRef<"CMSAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CMSAuditLog findUnique
   */
  export type CMSAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which CMSAuditLog to fetch.
     */
    where: CMSAuditLogWhereUniqueInput
  }

  /**
   * CMSAuditLog findUniqueOrThrow
   */
  export type CMSAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which CMSAuditLog to fetch.
     */
    where: CMSAuditLogWhereUniqueInput
  }

  /**
   * CMSAuditLog findFirst
   */
  export type CMSAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which CMSAuditLog to fetch.
     */
    where?: CMSAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSAuditLogs to fetch.
     */
    orderBy?: CMSAuditLogOrderByWithRelationInput | CMSAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSAuditLogs.
     */
    cursor?: CMSAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSAuditLogs.
     */
    distinct?: CMSAuditLogScalarFieldEnum | CMSAuditLogScalarFieldEnum[]
  }

  /**
   * CMSAuditLog findFirstOrThrow
   */
  export type CMSAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which CMSAuditLog to fetch.
     */
    where?: CMSAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSAuditLogs to fetch.
     */
    orderBy?: CMSAuditLogOrderByWithRelationInput | CMSAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CMSAuditLogs.
     */
    cursor?: CMSAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CMSAuditLogs.
     */
    distinct?: CMSAuditLogScalarFieldEnum | CMSAuditLogScalarFieldEnum[]
  }

  /**
   * CMSAuditLog findMany
   */
  export type CMSAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which CMSAuditLogs to fetch.
     */
    where?: CMSAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CMSAuditLogs to fetch.
     */
    orderBy?: CMSAuditLogOrderByWithRelationInput | CMSAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CMSAuditLogs.
     */
    cursor?: CMSAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CMSAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CMSAuditLogs.
     */
    skip?: number
    distinct?: CMSAuditLogScalarFieldEnum | CMSAuditLogScalarFieldEnum[]
  }

  /**
   * CMSAuditLog create
   */
  export type CMSAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a CMSAuditLog.
     */
    data: XOR<CMSAuditLogCreateInput, CMSAuditLogUncheckedCreateInput>
  }

  /**
   * CMSAuditLog createMany
   */
  export type CMSAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CMSAuditLogs.
     */
    data: CMSAuditLogCreateManyInput | CMSAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSAuditLog createManyAndReturn
   */
  export type CMSAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many CMSAuditLogs.
     */
    data: CMSAuditLogCreateManyInput | CMSAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CMSAuditLog update
   */
  export type CMSAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a CMSAuditLog.
     */
    data: XOR<CMSAuditLogUpdateInput, CMSAuditLogUncheckedUpdateInput>
    /**
     * Choose, which CMSAuditLog to update.
     */
    where: CMSAuditLogWhereUniqueInput
  }

  /**
   * CMSAuditLog updateMany
   */
  export type CMSAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CMSAuditLogs.
     */
    data: XOR<CMSAuditLogUpdateManyMutationInput, CMSAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which CMSAuditLogs to update
     */
    where?: CMSAuditLogWhereInput
    /**
     * Limit how many CMSAuditLogs to update.
     */
    limit?: number
  }

  /**
   * CMSAuditLog updateManyAndReturn
   */
  export type CMSAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update CMSAuditLogs.
     */
    data: XOR<CMSAuditLogUpdateManyMutationInput, CMSAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which CMSAuditLogs to update
     */
    where?: CMSAuditLogWhereInput
    /**
     * Limit how many CMSAuditLogs to update.
     */
    limit?: number
  }

  /**
   * CMSAuditLog upsert
   */
  export type CMSAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the CMSAuditLog to update in case it exists.
     */
    where: CMSAuditLogWhereUniqueInput
    /**
     * In case the CMSAuditLog found by the `where` argument doesn't exist, create a new CMSAuditLog with this data.
     */
    create: XOR<CMSAuditLogCreateInput, CMSAuditLogUncheckedCreateInput>
    /**
     * In case the CMSAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CMSAuditLogUpdateInput, CMSAuditLogUncheckedUpdateInput>
  }

  /**
   * CMSAuditLog delete
   */
  export type CMSAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
    /**
     * Filter which CMSAuditLog to delete.
     */
    where: CMSAuditLogWhereUniqueInput
  }

  /**
   * CMSAuditLog deleteMany
   */
  export type CMSAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CMSAuditLogs to delete
     */
    where?: CMSAuditLogWhereInput
    /**
     * Limit how many CMSAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * CMSAuditLog without action
   */
  export type CMSAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CMSAuditLog
     */
    select?: CMSAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CMSAuditLog
     */
    omit?: CMSAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model ExperienceSection
   */

  export type AggregateExperienceSection = {
    _count: ExperienceSectionCountAggregateOutputType | null
    _min: ExperienceSectionMinAggregateOutputType | null
    _max: ExperienceSectionMaxAggregateOutputType | null
  }

  export type ExperienceSectionMinAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    description: string | null
    image: string | null
    stat1Value: string | null
    stat1Label: string | null
    stat2Value: string | null
    stat2Label: string | null
    badgeText: string | null
    backgroundText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceSectionMaxAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    description: string | null
    image: string | null
    stat1Value: string | null
    stat1Label: string | null
    stat2Value: string | null
    stat2Label: string | null
    badgeText: string | null
    backgroundText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceSectionCountAggregateOutputType = {
    id: number
    heading: number
    title: number
    description: number
    image: number
    stat1Value: number
    stat1Label: number
    stat2Value: number
    stat2Label: number
    badgeText: number
    backgroundText: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExperienceSectionMinAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    description?: true
    image?: true
    stat1Value?: true
    stat1Label?: true
    stat2Value?: true
    stat2Label?: true
    badgeText?: true
    backgroundText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceSectionMaxAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    description?: true
    image?: true
    stat1Value?: true
    stat1Label?: true
    stat2Value?: true
    stat2Label?: true
    badgeText?: true
    backgroundText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceSectionCountAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    description?: true
    image?: true
    stat1Value?: true
    stat1Label?: true
    stat2Value?: true
    stat2Label?: true
    badgeText?: true
    backgroundText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExperienceSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceSection to aggregate.
     */
    where?: ExperienceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceSections to fetch.
     */
    orderBy?: ExperienceSectionOrderByWithRelationInput | ExperienceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExperienceSections
    **/
    _count?: true | ExperienceSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceSectionMaxAggregateInputType
  }

  export type GetExperienceSectionAggregateType<T extends ExperienceSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateExperienceSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperienceSection[P]>
      : GetScalarType<T[P], AggregateExperienceSection[P]>
  }




  export type ExperienceSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceSectionWhereInput
    orderBy?: ExperienceSectionOrderByWithAggregationInput | ExperienceSectionOrderByWithAggregationInput[]
    by: ExperienceSectionScalarFieldEnum[] | ExperienceSectionScalarFieldEnum
    having?: ExperienceSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceSectionCountAggregateInputType | true
    _min?: ExperienceSectionMinAggregateInputType
    _max?: ExperienceSectionMaxAggregateInputType
  }

  export type ExperienceSectionGroupByOutputType = {
    id: string
    heading: string
    title: string
    description: string
    image: string
    stat1Value: string
    stat1Label: string
    stat2Value: string
    stat2Label: string
    badgeText: string
    backgroundText: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExperienceSectionCountAggregateOutputType | null
    _min: ExperienceSectionMinAggregateOutputType | null
    _max: ExperienceSectionMaxAggregateOutputType | null
  }

  type GetExperienceSectionGroupByPayload<T extends ExperienceSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceSectionGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceSectionGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    stat1Value?: boolean
    stat1Label?: boolean
    stat2Value?: boolean
    stat2Label?: boolean
    badgeText?: boolean
    backgroundText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["experienceSection"]>

  export type ExperienceSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    stat1Value?: boolean
    stat1Label?: boolean
    stat2Value?: boolean
    stat2Label?: boolean
    badgeText?: boolean
    backgroundText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["experienceSection"]>

  export type ExperienceSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    stat1Value?: boolean
    stat1Label?: boolean
    stat2Value?: boolean
    stat2Label?: boolean
    badgeText?: boolean
    backgroundText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["experienceSection"]>

  export type ExperienceSectionSelectScalar = {
    id?: boolean
    heading?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    stat1Value?: boolean
    stat1Label?: boolean
    stat2Value?: boolean
    stat2Label?: boolean
    badgeText?: boolean
    backgroundText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExperienceSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heading" | "title" | "description" | "image" | "stat1Value" | "stat1Label" | "stat2Value" | "stat2Label" | "badgeText" | "backgroundText" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["experienceSection"]>

  export type $ExperienceSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExperienceSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      heading: string
      title: string
      description: string
      image: string
      stat1Value: string
      stat1Label: string
      stat2Value: string
      stat2Label: string
      badgeText: string
      backgroundText: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["experienceSection"]>
    composites: {}
  }

  type ExperienceSectionGetPayload<S extends boolean | null | undefined | ExperienceSectionDefaultArgs> = $Result.GetResult<Prisma.$ExperienceSectionPayload, S>

  type ExperienceSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExperienceSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperienceSectionCountAggregateInputType | true
    }

  export interface ExperienceSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExperienceSection'], meta: { name: 'ExperienceSection' } }
    /**
     * Find zero or one ExperienceSection that matches the filter.
     * @param {ExperienceSectionFindUniqueArgs} args - Arguments to find a ExperienceSection
     * @example
     * // Get one ExperienceSection
     * const experienceSection = await prisma.experienceSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceSectionFindUniqueArgs>(args: SelectSubset<T, ExperienceSectionFindUniqueArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExperienceSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExperienceSectionFindUniqueOrThrowArgs} args - Arguments to find a ExperienceSection
     * @example
     * // Get one ExperienceSection
     * const experienceSection = await prisma.experienceSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionFindFirstArgs} args - Arguments to find a ExperienceSection
     * @example
     * // Get one ExperienceSection
     * const experienceSection = await prisma.experienceSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceSectionFindFirstArgs>(args?: SelectSubset<T, ExperienceSectionFindFirstArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionFindFirstOrThrowArgs} args - Arguments to find a ExperienceSection
     * @example
     * // Get one ExperienceSection
     * const experienceSection = await prisma.experienceSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExperienceSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExperienceSections
     * const experienceSections = await prisma.experienceSection.findMany()
     * 
     * // Get first 10 ExperienceSections
     * const experienceSections = await prisma.experienceSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceSectionWithIdOnly = await prisma.experienceSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceSectionFindManyArgs>(args?: SelectSubset<T, ExperienceSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExperienceSection.
     * @param {ExperienceSectionCreateArgs} args - Arguments to create a ExperienceSection.
     * @example
     * // Create one ExperienceSection
     * const ExperienceSection = await prisma.experienceSection.create({
     *   data: {
     *     // ... data to create a ExperienceSection
     *   }
     * })
     * 
     */
    create<T extends ExperienceSectionCreateArgs>(args: SelectSubset<T, ExperienceSectionCreateArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExperienceSections.
     * @param {ExperienceSectionCreateManyArgs} args - Arguments to create many ExperienceSections.
     * @example
     * // Create many ExperienceSections
     * const experienceSection = await prisma.experienceSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceSectionCreateManyArgs>(args?: SelectSubset<T, ExperienceSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExperienceSections and returns the data saved in the database.
     * @param {ExperienceSectionCreateManyAndReturnArgs} args - Arguments to create many ExperienceSections.
     * @example
     * // Create many ExperienceSections
     * const experienceSection = await prisma.experienceSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExperienceSections and only return the `id`
     * const experienceSectionWithIdOnly = await prisma.experienceSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperienceSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperienceSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExperienceSection.
     * @param {ExperienceSectionDeleteArgs} args - Arguments to delete one ExperienceSection.
     * @example
     * // Delete one ExperienceSection
     * const ExperienceSection = await prisma.experienceSection.delete({
     *   where: {
     *     // ... filter to delete one ExperienceSection
     *   }
     * })
     * 
     */
    delete<T extends ExperienceSectionDeleteArgs>(args: SelectSubset<T, ExperienceSectionDeleteArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExperienceSection.
     * @param {ExperienceSectionUpdateArgs} args - Arguments to update one ExperienceSection.
     * @example
     * // Update one ExperienceSection
     * const experienceSection = await prisma.experienceSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceSectionUpdateArgs>(args: SelectSubset<T, ExperienceSectionUpdateArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExperienceSections.
     * @param {ExperienceSectionDeleteManyArgs} args - Arguments to filter ExperienceSections to delete.
     * @example
     * // Delete a few ExperienceSections
     * const { count } = await prisma.experienceSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceSectionDeleteManyArgs>(args?: SelectSubset<T, ExperienceSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperienceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExperienceSections
     * const experienceSection = await prisma.experienceSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceSectionUpdateManyArgs>(args: SelectSubset<T, ExperienceSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperienceSections and returns the data updated in the database.
     * @param {ExperienceSectionUpdateManyAndReturnArgs} args - Arguments to update many ExperienceSections.
     * @example
     * // Update many ExperienceSections
     * const experienceSection = await prisma.experienceSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExperienceSections and only return the `id`
     * const experienceSectionWithIdOnly = await prisma.experienceSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExperienceSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExperienceSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExperienceSection.
     * @param {ExperienceSectionUpsertArgs} args - Arguments to update or create a ExperienceSection.
     * @example
     * // Update or create a ExperienceSection
     * const experienceSection = await prisma.experienceSection.upsert({
     *   create: {
     *     // ... data to create a ExperienceSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExperienceSection we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceSectionUpsertArgs>(args: SelectSubset<T, ExperienceSectionUpsertArgs<ExtArgs>>): Prisma__ExperienceSectionClient<$Result.GetResult<Prisma.$ExperienceSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExperienceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionCountArgs} args - Arguments to filter ExperienceSections to count.
     * @example
     * // Count the number of ExperienceSections
     * const count = await prisma.experienceSection.count({
     *   where: {
     *     // ... the filter for the ExperienceSections we want to count
     *   }
     * })
    **/
    count<T extends ExperienceSectionCountArgs>(
      args?: Subset<T, ExperienceSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExperienceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceSectionAggregateArgs>(args: Subset<T, ExperienceSectionAggregateArgs>): Prisma.PrismaPromise<GetExperienceSectionAggregateType<T>>

    /**
     * Group by ExperienceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceSectionGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExperienceSection model
   */
  readonly fields: ExperienceSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExperienceSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExperienceSection model
   */
  interface ExperienceSectionFieldRefs {
    readonly id: FieldRef<"ExperienceSection", 'String'>
    readonly heading: FieldRef<"ExperienceSection", 'String'>
    readonly title: FieldRef<"ExperienceSection", 'String'>
    readonly description: FieldRef<"ExperienceSection", 'String'>
    readonly image: FieldRef<"ExperienceSection", 'String'>
    readonly stat1Value: FieldRef<"ExperienceSection", 'String'>
    readonly stat1Label: FieldRef<"ExperienceSection", 'String'>
    readonly stat2Value: FieldRef<"ExperienceSection", 'String'>
    readonly stat2Label: FieldRef<"ExperienceSection", 'String'>
    readonly badgeText: FieldRef<"ExperienceSection", 'String'>
    readonly backgroundText: FieldRef<"ExperienceSection", 'String'>
    readonly status: FieldRef<"ExperienceSection", 'ContentStatus'>
    readonly publishedAt: FieldRef<"ExperienceSection", 'DateTime'>
    readonly createdAt: FieldRef<"ExperienceSection", 'DateTime'>
    readonly updatedAt: FieldRef<"ExperienceSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExperienceSection findUnique
   */
  export type ExperienceSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter, which ExperienceSection to fetch.
     */
    where: ExperienceSectionWhereUniqueInput
  }

  /**
   * ExperienceSection findUniqueOrThrow
   */
  export type ExperienceSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter, which ExperienceSection to fetch.
     */
    where: ExperienceSectionWhereUniqueInput
  }

  /**
   * ExperienceSection findFirst
   */
  export type ExperienceSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter, which ExperienceSection to fetch.
     */
    where?: ExperienceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceSections to fetch.
     */
    orderBy?: ExperienceSectionOrderByWithRelationInput | ExperienceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceSections.
     */
    cursor?: ExperienceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceSections.
     */
    distinct?: ExperienceSectionScalarFieldEnum | ExperienceSectionScalarFieldEnum[]
  }

  /**
   * ExperienceSection findFirstOrThrow
   */
  export type ExperienceSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter, which ExperienceSection to fetch.
     */
    where?: ExperienceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceSections to fetch.
     */
    orderBy?: ExperienceSectionOrderByWithRelationInput | ExperienceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceSections.
     */
    cursor?: ExperienceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceSections.
     */
    distinct?: ExperienceSectionScalarFieldEnum | ExperienceSectionScalarFieldEnum[]
  }

  /**
   * ExperienceSection findMany
   */
  export type ExperienceSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter, which ExperienceSections to fetch.
     */
    where?: ExperienceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceSections to fetch.
     */
    orderBy?: ExperienceSectionOrderByWithRelationInput | ExperienceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExperienceSections.
     */
    cursor?: ExperienceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceSections.
     */
    skip?: number
    distinct?: ExperienceSectionScalarFieldEnum | ExperienceSectionScalarFieldEnum[]
  }

  /**
   * ExperienceSection create
   */
  export type ExperienceSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * The data needed to create a ExperienceSection.
     */
    data: XOR<ExperienceSectionCreateInput, ExperienceSectionUncheckedCreateInput>
  }

  /**
   * ExperienceSection createMany
   */
  export type ExperienceSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExperienceSections.
     */
    data: ExperienceSectionCreateManyInput | ExperienceSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExperienceSection createManyAndReturn
   */
  export type ExperienceSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * The data used to create many ExperienceSections.
     */
    data: ExperienceSectionCreateManyInput | ExperienceSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExperienceSection update
   */
  export type ExperienceSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * The data needed to update a ExperienceSection.
     */
    data: XOR<ExperienceSectionUpdateInput, ExperienceSectionUncheckedUpdateInput>
    /**
     * Choose, which ExperienceSection to update.
     */
    where: ExperienceSectionWhereUniqueInput
  }

  /**
   * ExperienceSection updateMany
   */
  export type ExperienceSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExperienceSections.
     */
    data: XOR<ExperienceSectionUpdateManyMutationInput, ExperienceSectionUncheckedUpdateManyInput>
    /**
     * Filter which ExperienceSections to update
     */
    where?: ExperienceSectionWhereInput
    /**
     * Limit how many ExperienceSections to update.
     */
    limit?: number
  }

  /**
   * ExperienceSection updateManyAndReturn
   */
  export type ExperienceSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * The data used to update ExperienceSections.
     */
    data: XOR<ExperienceSectionUpdateManyMutationInput, ExperienceSectionUncheckedUpdateManyInput>
    /**
     * Filter which ExperienceSections to update
     */
    where?: ExperienceSectionWhereInput
    /**
     * Limit how many ExperienceSections to update.
     */
    limit?: number
  }

  /**
   * ExperienceSection upsert
   */
  export type ExperienceSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * The filter to search for the ExperienceSection to update in case it exists.
     */
    where: ExperienceSectionWhereUniqueInput
    /**
     * In case the ExperienceSection found by the `where` argument doesn't exist, create a new ExperienceSection with this data.
     */
    create: XOR<ExperienceSectionCreateInput, ExperienceSectionUncheckedCreateInput>
    /**
     * In case the ExperienceSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceSectionUpdateInput, ExperienceSectionUncheckedUpdateInput>
  }

  /**
   * ExperienceSection delete
   */
  export type ExperienceSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
    /**
     * Filter which ExperienceSection to delete.
     */
    where: ExperienceSectionWhereUniqueInput
  }

  /**
   * ExperienceSection deleteMany
   */
  export type ExperienceSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceSections to delete
     */
    where?: ExperienceSectionWhereInput
    /**
     * Limit how many ExperienceSections to delete.
     */
    limit?: number
  }

  /**
   * ExperienceSection without action
   */
  export type ExperienceSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceSection
     */
    select?: ExperienceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceSection
     */
    omit?: ExperienceSectionOmit<ExtArgs> | null
  }


  /**
   * Model TourGuideSection
   */

  export type AggregateTourGuideSection = {
    _count: TourGuideSectionCountAggregateOutputType | null
    _min: TourGuideSectionMinAggregateOutputType | null
    _max: TourGuideSectionMaxAggregateOutputType | null
  }

  export type TourGuideSectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    mapImage: string | null
    buttonText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourGuideSectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    mapImage: string | null
    buttonText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourGuideSectionCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    description: number
    mapImage: number
    buttonText: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourGuideSectionMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    mapImage?: true
    buttonText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourGuideSectionMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    mapImage?: true
    buttonText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourGuideSectionCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    mapImage?: true
    buttonText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourGuideSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourGuideSection to aggregate.
     */
    where?: TourGuideSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourGuideSections to fetch.
     */
    orderBy?: TourGuideSectionOrderByWithRelationInput | TourGuideSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourGuideSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourGuideSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourGuideSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourGuideSections
    **/
    _count?: true | TourGuideSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourGuideSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourGuideSectionMaxAggregateInputType
  }

  export type GetTourGuideSectionAggregateType<T extends TourGuideSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateTourGuideSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourGuideSection[P]>
      : GetScalarType<T[P], AggregateTourGuideSection[P]>
  }




  export type TourGuideSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourGuideSectionWhereInput
    orderBy?: TourGuideSectionOrderByWithAggregationInput | TourGuideSectionOrderByWithAggregationInput[]
    by: TourGuideSectionScalarFieldEnum[] | TourGuideSectionScalarFieldEnum
    having?: TourGuideSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourGuideSectionCountAggregateInputType | true
    _min?: TourGuideSectionMinAggregateInputType
    _max?: TourGuideSectionMaxAggregateInputType
  }

  export type TourGuideSectionGroupByOutputType = {
    id: string
    title: string
    subtitle: string
    description: string
    mapImage: string
    buttonText: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TourGuideSectionCountAggregateOutputType | null
    _min: TourGuideSectionMinAggregateOutputType | null
    _max: TourGuideSectionMaxAggregateOutputType | null
  }

  type GetTourGuideSectionGroupByPayload<T extends TourGuideSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGuideSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGuideSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGuideSectionGroupByOutputType[P]>
            : GetScalarType<T[P], TourGuideSectionGroupByOutputType[P]>
        }
      >
    >


  export type TourGuideSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    mapImage?: boolean
    buttonText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tourGuideSection"]>

  export type TourGuideSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    mapImage?: boolean
    buttonText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tourGuideSection"]>

  export type TourGuideSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    mapImage?: boolean
    buttonText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tourGuideSection"]>

  export type TourGuideSectionSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    mapImage?: boolean
    buttonText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourGuideSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "description" | "mapImage" | "buttonText" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tourGuideSection"]>

  export type $TourGuideSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourGuideSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string
      description: string
      mapImage: string
      buttonText: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tourGuideSection"]>
    composites: {}
  }

  type TourGuideSectionGetPayload<S extends boolean | null | undefined | TourGuideSectionDefaultArgs> = $Result.GetResult<Prisma.$TourGuideSectionPayload, S>

  type TourGuideSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TourGuideSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TourGuideSectionCountAggregateInputType | true
    }

  export interface TourGuideSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourGuideSection'], meta: { name: 'TourGuideSection' } }
    /**
     * Find zero or one TourGuideSection that matches the filter.
     * @param {TourGuideSectionFindUniqueArgs} args - Arguments to find a TourGuideSection
     * @example
     * // Get one TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourGuideSectionFindUniqueArgs>(args: SelectSubset<T, TourGuideSectionFindUniqueArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TourGuideSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TourGuideSectionFindUniqueOrThrowArgs} args - Arguments to find a TourGuideSection
     * @example
     * // Get one TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourGuideSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, TourGuideSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourGuideSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionFindFirstArgs} args - Arguments to find a TourGuideSection
     * @example
     * // Get one TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourGuideSectionFindFirstArgs>(args?: SelectSubset<T, TourGuideSectionFindFirstArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourGuideSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionFindFirstOrThrowArgs} args - Arguments to find a TourGuideSection
     * @example
     * // Get one TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourGuideSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, TourGuideSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TourGuideSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourGuideSections
     * const tourGuideSections = await prisma.tourGuideSection.findMany()
     * 
     * // Get first 10 TourGuideSections
     * const tourGuideSections = await prisma.tourGuideSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourGuideSectionWithIdOnly = await prisma.tourGuideSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourGuideSectionFindManyArgs>(args?: SelectSubset<T, TourGuideSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TourGuideSection.
     * @param {TourGuideSectionCreateArgs} args - Arguments to create a TourGuideSection.
     * @example
     * // Create one TourGuideSection
     * const TourGuideSection = await prisma.tourGuideSection.create({
     *   data: {
     *     // ... data to create a TourGuideSection
     *   }
     * })
     * 
     */
    create<T extends TourGuideSectionCreateArgs>(args: SelectSubset<T, TourGuideSectionCreateArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TourGuideSections.
     * @param {TourGuideSectionCreateManyArgs} args - Arguments to create many TourGuideSections.
     * @example
     * // Create many TourGuideSections
     * const tourGuideSection = await prisma.tourGuideSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourGuideSectionCreateManyArgs>(args?: SelectSubset<T, TourGuideSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourGuideSections and returns the data saved in the database.
     * @param {TourGuideSectionCreateManyAndReturnArgs} args - Arguments to create many TourGuideSections.
     * @example
     * // Create many TourGuideSections
     * const tourGuideSection = await prisma.tourGuideSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourGuideSections and only return the `id`
     * const tourGuideSectionWithIdOnly = await prisma.tourGuideSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourGuideSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, TourGuideSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TourGuideSection.
     * @param {TourGuideSectionDeleteArgs} args - Arguments to delete one TourGuideSection.
     * @example
     * // Delete one TourGuideSection
     * const TourGuideSection = await prisma.tourGuideSection.delete({
     *   where: {
     *     // ... filter to delete one TourGuideSection
     *   }
     * })
     * 
     */
    delete<T extends TourGuideSectionDeleteArgs>(args: SelectSubset<T, TourGuideSectionDeleteArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TourGuideSection.
     * @param {TourGuideSectionUpdateArgs} args - Arguments to update one TourGuideSection.
     * @example
     * // Update one TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourGuideSectionUpdateArgs>(args: SelectSubset<T, TourGuideSectionUpdateArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TourGuideSections.
     * @param {TourGuideSectionDeleteManyArgs} args - Arguments to filter TourGuideSections to delete.
     * @example
     * // Delete a few TourGuideSections
     * const { count } = await prisma.tourGuideSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourGuideSectionDeleteManyArgs>(args?: SelectSubset<T, TourGuideSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourGuideSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourGuideSections
     * const tourGuideSection = await prisma.tourGuideSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourGuideSectionUpdateManyArgs>(args: SelectSubset<T, TourGuideSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourGuideSections and returns the data updated in the database.
     * @param {TourGuideSectionUpdateManyAndReturnArgs} args - Arguments to update many TourGuideSections.
     * @example
     * // Update many TourGuideSections
     * const tourGuideSection = await prisma.tourGuideSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TourGuideSections and only return the `id`
     * const tourGuideSectionWithIdOnly = await prisma.tourGuideSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TourGuideSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, TourGuideSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TourGuideSection.
     * @param {TourGuideSectionUpsertArgs} args - Arguments to update or create a TourGuideSection.
     * @example
     * // Update or create a TourGuideSection
     * const tourGuideSection = await prisma.tourGuideSection.upsert({
     *   create: {
     *     // ... data to create a TourGuideSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourGuideSection we want to update
     *   }
     * })
     */
    upsert<T extends TourGuideSectionUpsertArgs>(args: SelectSubset<T, TourGuideSectionUpsertArgs<ExtArgs>>): Prisma__TourGuideSectionClient<$Result.GetResult<Prisma.$TourGuideSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TourGuideSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionCountArgs} args - Arguments to filter TourGuideSections to count.
     * @example
     * // Count the number of TourGuideSections
     * const count = await prisma.tourGuideSection.count({
     *   where: {
     *     // ... the filter for the TourGuideSections we want to count
     *   }
     * })
    **/
    count<T extends TourGuideSectionCountArgs>(
      args?: Subset<T, TourGuideSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourGuideSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourGuideSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourGuideSectionAggregateArgs>(args: Subset<T, TourGuideSectionAggregateArgs>): Prisma.PrismaPromise<GetTourGuideSectionAggregateType<T>>

    /**
     * Group by TourGuideSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGuideSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGuideSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGuideSectionGroupByArgs['orderBy'] }
        : { orderBy?: TourGuideSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGuideSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGuideSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourGuideSection model
   */
  readonly fields: TourGuideSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourGuideSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourGuideSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourGuideSection model
   */
  interface TourGuideSectionFieldRefs {
    readonly id: FieldRef<"TourGuideSection", 'String'>
    readonly title: FieldRef<"TourGuideSection", 'String'>
    readonly subtitle: FieldRef<"TourGuideSection", 'String'>
    readonly description: FieldRef<"TourGuideSection", 'String'>
    readonly mapImage: FieldRef<"TourGuideSection", 'String'>
    readonly buttonText: FieldRef<"TourGuideSection", 'String'>
    readonly status: FieldRef<"TourGuideSection", 'ContentStatus'>
    readonly publishedAt: FieldRef<"TourGuideSection", 'DateTime'>
    readonly createdAt: FieldRef<"TourGuideSection", 'DateTime'>
    readonly updatedAt: FieldRef<"TourGuideSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TourGuideSection findUnique
   */
  export type TourGuideSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter, which TourGuideSection to fetch.
     */
    where: TourGuideSectionWhereUniqueInput
  }

  /**
   * TourGuideSection findUniqueOrThrow
   */
  export type TourGuideSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter, which TourGuideSection to fetch.
     */
    where: TourGuideSectionWhereUniqueInput
  }

  /**
   * TourGuideSection findFirst
   */
  export type TourGuideSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter, which TourGuideSection to fetch.
     */
    where?: TourGuideSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourGuideSections to fetch.
     */
    orderBy?: TourGuideSectionOrderByWithRelationInput | TourGuideSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourGuideSections.
     */
    cursor?: TourGuideSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourGuideSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourGuideSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourGuideSections.
     */
    distinct?: TourGuideSectionScalarFieldEnum | TourGuideSectionScalarFieldEnum[]
  }

  /**
   * TourGuideSection findFirstOrThrow
   */
  export type TourGuideSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter, which TourGuideSection to fetch.
     */
    where?: TourGuideSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourGuideSections to fetch.
     */
    orderBy?: TourGuideSectionOrderByWithRelationInput | TourGuideSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourGuideSections.
     */
    cursor?: TourGuideSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourGuideSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourGuideSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourGuideSections.
     */
    distinct?: TourGuideSectionScalarFieldEnum | TourGuideSectionScalarFieldEnum[]
  }

  /**
   * TourGuideSection findMany
   */
  export type TourGuideSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter, which TourGuideSections to fetch.
     */
    where?: TourGuideSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourGuideSections to fetch.
     */
    orderBy?: TourGuideSectionOrderByWithRelationInput | TourGuideSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourGuideSections.
     */
    cursor?: TourGuideSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourGuideSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourGuideSections.
     */
    skip?: number
    distinct?: TourGuideSectionScalarFieldEnum | TourGuideSectionScalarFieldEnum[]
  }

  /**
   * TourGuideSection create
   */
  export type TourGuideSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * The data needed to create a TourGuideSection.
     */
    data: XOR<TourGuideSectionCreateInput, TourGuideSectionUncheckedCreateInput>
  }

  /**
   * TourGuideSection createMany
   */
  export type TourGuideSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourGuideSections.
     */
    data: TourGuideSectionCreateManyInput | TourGuideSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourGuideSection createManyAndReturn
   */
  export type TourGuideSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * The data used to create many TourGuideSections.
     */
    data: TourGuideSectionCreateManyInput | TourGuideSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourGuideSection update
   */
  export type TourGuideSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * The data needed to update a TourGuideSection.
     */
    data: XOR<TourGuideSectionUpdateInput, TourGuideSectionUncheckedUpdateInput>
    /**
     * Choose, which TourGuideSection to update.
     */
    where: TourGuideSectionWhereUniqueInput
  }

  /**
   * TourGuideSection updateMany
   */
  export type TourGuideSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourGuideSections.
     */
    data: XOR<TourGuideSectionUpdateManyMutationInput, TourGuideSectionUncheckedUpdateManyInput>
    /**
     * Filter which TourGuideSections to update
     */
    where?: TourGuideSectionWhereInput
    /**
     * Limit how many TourGuideSections to update.
     */
    limit?: number
  }

  /**
   * TourGuideSection updateManyAndReturn
   */
  export type TourGuideSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * The data used to update TourGuideSections.
     */
    data: XOR<TourGuideSectionUpdateManyMutationInput, TourGuideSectionUncheckedUpdateManyInput>
    /**
     * Filter which TourGuideSections to update
     */
    where?: TourGuideSectionWhereInput
    /**
     * Limit how many TourGuideSections to update.
     */
    limit?: number
  }

  /**
   * TourGuideSection upsert
   */
  export type TourGuideSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * The filter to search for the TourGuideSection to update in case it exists.
     */
    where: TourGuideSectionWhereUniqueInput
    /**
     * In case the TourGuideSection found by the `where` argument doesn't exist, create a new TourGuideSection with this data.
     */
    create: XOR<TourGuideSectionCreateInput, TourGuideSectionUncheckedCreateInput>
    /**
     * In case the TourGuideSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourGuideSectionUpdateInput, TourGuideSectionUncheckedUpdateInput>
  }

  /**
   * TourGuideSection delete
   */
  export type TourGuideSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
    /**
     * Filter which TourGuideSection to delete.
     */
    where: TourGuideSectionWhereUniqueInput
  }

  /**
   * TourGuideSection deleteMany
   */
  export type TourGuideSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourGuideSections to delete
     */
    where?: TourGuideSectionWhereInput
    /**
     * Limit how many TourGuideSections to delete.
     */
    limit?: number
  }

  /**
   * TourGuideSection without action
   */
  export type TourGuideSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourGuideSection
     */
    select?: TourGuideSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourGuideSection
     */
    omit?: TourGuideSectionOmit<ExtArgs> | null
  }


  /**
   * Model VideoSection
   */

  export type AggregateVideoSection = {
    _count: VideoSectionCountAggregateOutputType | null
    _min: VideoSectionMinAggregateOutputType | null
    _max: VideoSectionMaxAggregateOutputType | null
  }

  export type VideoSectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoSectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoSectionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    videoUrl: number
    thumbnailUrl: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoSectionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoSectionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoSectionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoSection to aggregate.
     */
    where?: VideoSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSections to fetch.
     */
    orderBy?: VideoSectionOrderByWithRelationInput | VideoSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoSections
    **/
    _count?: true | VideoSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoSectionMaxAggregateInputType
  }

  export type GetVideoSectionAggregateType<T extends VideoSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoSection[P]>
      : GetScalarType<T[P], AggregateVideoSection[P]>
  }




  export type VideoSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoSectionWhereInput
    orderBy?: VideoSectionOrderByWithAggregationInput | VideoSectionOrderByWithAggregationInput[]
    by: VideoSectionScalarFieldEnum[] | VideoSectionScalarFieldEnum
    having?: VideoSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoSectionCountAggregateInputType | true
    _min?: VideoSectionMinAggregateInputType
    _max?: VideoSectionMaxAggregateInputType
  }

  export type VideoSectionGroupByOutputType = {
    id: string
    title: string
    description: string
    videoUrl: string
    thumbnailUrl: string | null
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VideoSectionCountAggregateOutputType | null
    _min: VideoSectionMinAggregateOutputType | null
    _max: VideoSectionMaxAggregateOutputType | null
  }

  type GetVideoSectionGroupByPayload<T extends VideoSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoSectionGroupByOutputType[P]>
            : GetScalarType<T[P], VideoSectionGroupByOutputType[P]>
        }
      >
    >


  export type VideoSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoSection"]>

  export type VideoSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoSection"]>

  export type VideoSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoSection"]>

  export type VideoSectionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "videoUrl" | "thumbnailUrl" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["videoSection"]>

  export type $VideoSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      videoUrl: string
      thumbnailUrl: string | null
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoSection"]>
    composites: {}
  }

  type VideoSectionGetPayload<S extends boolean | null | undefined | VideoSectionDefaultArgs> = $Result.GetResult<Prisma.$VideoSectionPayload, S>

  type VideoSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoSectionCountAggregateInputType | true
    }

  export interface VideoSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoSection'], meta: { name: 'VideoSection' } }
    /**
     * Find zero or one VideoSection that matches the filter.
     * @param {VideoSectionFindUniqueArgs} args - Arguments to find a VideoSection
     * @example
     * // Get one VideoSection
     * const videoSection = await prisma.videoSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoSectionFindUniqueArgs>(args: SelectSubset<T, VideoSectionFindUniqueArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoSectionFindUniqueOrThrowArgs} args - Arguments to find a VideoSection
     * @example
     * // Get one VideoSection
     * const videoSection = await prisma.videoSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionFindFirstArgs} args - Arguments to find a VideoSection
     * @example
     * // Get one VideoSection
     * const videoSection = await prisma.videoSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoSectionFindFirstArgs>(args?: SelectSubset<T, VideoSectionFindFirstArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionFindFirstOrThrowArgs} args - Arguments to find a VideoSection
     * @example
     * // Get one VideoSection
     * const videoSection = await prisma.videoSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoSections
     * const videoSections = await prisma.videoSection.findMany()
     * 
     * // Get first 10 VideoSections
     * const videoSections = await prisma.videoSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoSectionWithIdOnly = await prisma.videoSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoSectionFindManyArgs>(args?: SelectSubset<T, VideoSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoSection.
     * @param {VideoSectionCreateArgs} args - Arguments to create a VideoSection.
     * @example
     * // Create one VideoSection
     * const VideoSection = await prisma.videoSection.create({
     *   data: {
     *     // ... data to create a VideoSection
     *   }
     * })
     * 
     */
    create<T extends VideoSectionCreateArgs>(args: SelectSubset<T, VideoSectionCreateArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoSections.
     * @param {VideoSectionCreateManyArgs} args - Arguments to create many VideoSections.
     * @example
     * // Create many VideoSections
     * const videoSection = await prisma.videoSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoSectionCreateManyArgs>(args?: SelectSubset<T, VideoSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoSections and returns the data saved in the database.
     * @param {VideoSectionCreateManyAndReturnArgs} args - Arguments to create many VideoSections.
     * @example
     * // Create many VideoSections
     * const videoSection = await prisma.videoSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoSections and only return the `id`
     * const videoSectionWithIdOnly = await prisma.videoSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoSection.
     * @param {VideoSectionDeleteArgs} args - Arguments to delete one VideoSection.
     * @example
     * // Delete one VideoSection
     * const VideoSection = await prisma.videoSection.delete({
     *   where: {
     *     // ... filter to delete one VideoSection
     *   }
     * })
     * 
     */
    delete<T extends VideoSectionDeleteArgs>(args: SelectSubset<T, VideoSectionDeleteArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoSection.
     * @param {VideoSectionUpdateArgs} args - Arguments to update one VideoSection.
     * @example
     * // Update one VideoSection
     * const videoSection = await prisma.videoSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoSectionUpdateArgs>(args: SelectSubset<T, VideoSectionUpdateArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoSections.
     * @param {VideoSectionDeleteManyArgs} args - Arguments to filter VideoSections to delete.
     * @example
     * // Delete a few VideoSections
     * const { count } = await prisma.videoSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoSectionDeleteManyArgs>(args?: SelectSubset<T, VideoSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoSections
     * const videoSection = await prisma.videoSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoSectionUpdateManyArgs>(args: SelectSubset<T, VideoSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoSections and returns the data updated in the database.
     * @param {VideoSectionUpdateManyAndReturnArgs} args - Arguments to update many VideoSections.
     * @example
     * // Update many VideoSections
     * const videoSection = await prisma.videoSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoSections and only return the `id`
     * const videoSectionWithIdOnly = await prisma.videoSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoSection.
     * @param {VideoSectionUpsertArgs} args - Arguments to update or create a VideoSection.
     * @example
     * // Update or create a VideoSection
     * const videoSection = await prisma.videoSection.upsert({
     *   create: {
     *     // ... data to create a VideoSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoSection we want to update
     *   }
     * })
     */
    upsert<T extends VideoSectionUpsertArgs>(args: SelectSubset<T, VideoSectionUpsertArgs<ExtArgs>>): Prisma__VideoSectionClient<$Result.GetResult<Prisma.$VideoSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionCountArgs} args - Arguments to filter VideoSections to count.
     * @example
     * // Count the number of VideoSections
     * const count = await prisma.videoSection.count({
     *   where: {
     *     // ... the filter for the VideoSections we want to count
     *   }
     * })
    **/
    count<T extends VideoSectionCountArgs>(
      args?: Subset<T, VideoSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoSectionAggregateArgs>(args: Subset<T, VideoSectionAggregateArgs>): Prisma.PrismaPromise<GetVideoSectionAggregateType<T>>

    /**
     * Group by VideoSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoSectionGroupByArgs['orderBy'] }
        : { orderBy?: VideoSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoSection model
   */
  readonly fields: VideoSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoSection model
   */
  interface VideoSectionFieldRefs {
    readonly id: FieldRef<"VideoSection", 'String'>
    readonly title: FieldRef<"VideoSection", 'String'>
    readonly description: FieldRef<"VideoSection", 'String'>
    readonly videoUrl: FieldRef<"VideoSection", 'String'>
    readonly thumbnailUrl: FieldRef<"VideoSection", 'String'>
    readonly status: FieldRef<"VideoSection", 'ContentStatus'>
    readonly publishedAt: FieldRef<"VideoSection", 'DateTime'>
    readonly createdAt: FieldRef<"VideoSection", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoSection findUnique
   */
  export type VideoSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter, which VideoSection to fetch.
     */
    where: VideoSectionWhereUniqueInput
  }

  /**
   * VideoSection findUniqueOrThrow
   */
  export type VideoSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter, which VideoSection to fetch.
     */
    where: VideoSectionWhereUniqueInput
  }

  /**
   * VideoSection findFirst
   */
  export type VideoSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter, which VideoSection to fetch.
     */
    where?: VideoSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSections to fetch.
     */
    orderBy?: VideoSectionOrderByWithRelationInput | VideoSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoSections.
     */
    cursor?: VideoSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoSections.
     */
    distinct?: VideoSectionScalarFieldEnum | VideoSectionScalarFieldEnum[]
  }

  /**
   * VideoSection findFirstOrThrow
   */
  export type VideoSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter, which VideoSection to fetch.
     */
    where?: VideoSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSections to fetch.
     */
    orderBy?: VideoSectionOrderByWithRelationInput | VideoSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoSections.
     */
    cursor?: VideoSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoSections.
     */
    distinct?: VideoSectionScalarFieldEnum | VideoSectionScalarFieldEnum[]
  }

  /**
   * VideoSection findMany
   */
  export type VideoSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter, which VideoSections to fetch.
     */
    where?: VideoSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSections to fetch.
     */
    orderBy?: VideoSectionOrderByWithRelationInput | VideoSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoSections.
     */
    cursor?: VideoSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSections.
     */
    skip?: number
    distinct?: VideoSectionScalarFieldEnum | VideoSectionScalarFieldEnum[]
  }

  /**
   * VideoSection create
   */
  export type VideoSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * The data needed to create a VideoSection.
     */
    data: XOR<VideoSectionCreateInput, VideoSectionUncheckedCreateInput>
  }

  /**
   * VideoSection createMany
   */
  export type VideoSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoSections.
     */
    data: VideoSectionCreateManyInput | VideoSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoSection createManyAndReturn
   */
  export type VideoSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * The data used to create many VideoSections.
     */
    data: VideoSectionCreateManyInput | VideoSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoSection update
   */
  export type VideoSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * The data needed to update a VideoSection.
     */
    data: XOR<VideoSectionUpdateInput, VideoSectionUncheckedUpdateInput>
    /**
     * Choose, which VideoSection to update.
     */
    where: VideoSectionWhereUniqueInput
  }

  /**
   * VideoSection updateMany
   */
  export type VideoSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoSections.
     */
    data: XOR<VideoSectionUpdateManyMutationInput, VideoSectionUncheckedUpdateManyInput>
    /**
     * Filter which VideoSections to update
     */
    where?: VideoSectionWhereInput
    /**
     * Limit how many VideoSections to update.
     */
    limit?: number
  }

  /**
   * VideoSection updateManyAndReturn
   */
  export type VideoSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * The data used to update VideoSections.
     */
    data: XOR<VideoSectionUpdateManyMutationInput, VideoSectionUncheckedUpdateManyInput>
    /**
     * Filter which VideoSections to update
     */
    where?: VideoSectionWhereInput
    /**
     * Limit how many VideoSections to update.
     */
    limit?: number
  }

  /**
   * VideoSection upsert
   */
  export type VideoSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * The filter to search for the VideoSection to update in case it exists.
     */
    where: VideoSectionWhereUniqueInput
    /**
     * In case the VideoSection found by the `where` argument doesn't exist, create a new VideoSection with this data.
     */
    create: XOR<VideoSectionCreateInput, VideoSectionUncheckedCreateInput>
    /**
     * In case the VideoSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoSectionUpdateInput, VideoSectionUncheckedUpdateInput>
  }

  /**
   * VideoSection delete
   */
  export type VideoSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
    /**
     * Filter which VideoSection to delete.
     */
    where: VideoSectionWhereUniqueInput
  }

  /**
   * VideoSection deleteMany
   */
  export type VideoSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoSections to delete
     */
    where?: VideoSectionWhereInput
    /**
     * Limit how many VideoSections to delete.
     */
    limit?: number
  }

  /**
   * VideoSection without action
   */
  export type VideoSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSection
     */
    select?: VideoSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoSection
     */
    omit?: VideoSectionOmit<ExtArgs> | null
  }


  /**
   * Model PackagesHero
   */

  export type AggregatePackagesHero = {
    _count: PackagesHeroCountAggregateOutputType | null
    _min: PackagesHeroMinAggregateOutputType | null
    _max: PackagesHeroMaxAggregateOutputType | null
  }

  export type PackagesHeroMinAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackagesHeroMaxAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackagesHeroCountAggregateOutputType = {
    id: number
    image: number
    title: number
    subtitle: number
    description: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackagesHeroMinAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackagesHeroMaxAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackagesHeroCountAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackagesHeroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagesHero to aggregate.
     */
    where?: PackagesHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagesHeroes to fetch.
     */
    orderBy?: PackagesHeroOrderByWithRelationInput | PackagesHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackagesHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagesHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagesHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackagesHeroes
    **/
    _count?: true | PackagesHeroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagesHeroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagesHeroMaxAggregateInputType
  }

  export type GetPackagesHeroAggregateType<T extends PackagesHeroAggregateArgs> = {
        [P in keyof T & keyof AggregatePackagesHero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackagesHero[P]>
      : GetScalarType<T[P], AggregatePackagesHero[P]>
  }




  export type PackagesHeroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagesHeroWhereInput
    orderBy?: PackagesHeroOrderByWithAggregationInput | PackagesHeroOrderByWithAggregationInput[]
    by: PackagesHeroScalarFieldEnum[] | PackagesHeroScalarFieldEnum
    having?: PackagesHeroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagesHeroCountAggregateInputType | true
    _min?: PackagesHeroMinAggregateInputType
    _max?: PackagesHeroMaxAggregateInputType
  }

  export type PackagesHeroGroupByOutputType = {
    id: string
    image: string
    title: string
    subtitle: string
    description: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PackagesHeroCountAggregateOutputType | null
    _min: PackagesHeroMinAggregateOutputType | null
    _max: PackagesHeroMaxAggregateOutputType | null
  }

  type GetPackagesHeroGroupByPayload<T extends PackagesHeroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagesHeroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagesHeroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagesHeroGroupByOutputType[P]>
            : GetScalarType<T[P], PackagesHeroGroupByOutputType[P]>
        }
      >
    >


  export type PackagesHeroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packagesHero"]>

  export type PackagesHeroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packagesHero"]>

  export type PackagesHeroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packagesHero"]>

  export type PackagesHeroSelectScalar = {
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackagesHeroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "title" | "subtitle" | "description" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["packagesHero"]>

  export type $PackagesHeroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackagesHero"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      title: string
      subtitle: string
      description: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packagesHero"]>
    composites: {}
  }

  type PackagesHeroGetPayload<S extends boolean | null | undefined | PackagesHeroDefaultArgs> = $Result.GetResult<Prisma.$PackagesHeroPayload, S>

  type PackagesHeroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackagesHeroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackagesHeroCountAggregateInputType | true
    }

  export interface PackagesHeroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackagesHero'], meta: { name: 'PackagesHero' } }
    /**
     * Find zero or one PackagesHero that matches the filter.
     * @param {PackagesHeroFindUniqueArgs} args - Arguments to find a PackagesHero
     * @example
     * // Get one PackagesHero
     * const packagesHero = await prisma.packagesHero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackagesHeroFindUniqueArgs>(args: SelectSubset<T, PackagesHeroFindUniqueArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackagesHero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackagesHeroFindUniqueOrThrowArgs} args - Arguments to find a PackagesHero
     * @example
     * // Get one PackagesHero
     * const packagesHero = await prisma.packagesHero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackagesHeroFindUniqueOrThrowArgs>(args: SelectSubset<T, PackagesHeroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackagesHero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroFindFirstArgs} args - Arguments to find a PackagesHero
     * @example
     * // Get one PackagesHero
     * const packagesHero = await prisma.packagesHero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackagesHeroFindFirstArgs>(args?: SelectSubset<T, PackagesHeroFindFirstArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackagesHero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroFindFirstOrThrowArgs} args - Arguments to find a PackagesHero
     * @example
     * // Get one PackagesHero
     * const packagesHero = await prisma.packagesHero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackagesHeroFindFirstOrThrowArgs>(args?: SelectSubset<T, PackagesHeroFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackagesHeroes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackagesHeroes
     * const packagesHeroes = await prisma.packagesHero.findMany()
     * 
     * // Get first 10 PackagesHeroes
     * const packagesHeroes = await prisma.packagesHero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagesHeroWithIdOnly = await prisma.packagesHero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackagesHeroFindManyArgs>(args?: SelectSubset<T, PackagesHeroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackagesHero.
     * @param {PackagesHeroCreateArgs} args - Arguments to create a PackagesHero.
     * @example
     * // Create one PackagesHero
     * const PackagesHero = await prisma.packagesHero.create({
     *   data: {
     *     // ... data to create a PackagesHero
     *   }
     * })
     * 
     */
    create<T extends PackagesHeroCreateArgs>(args: SelectSubset<T, PackagesHeroCreateArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackagesHeroes.
     * @param {PackagesHeroCreateManyArgs} args - Arguments to create many PackagesHeroes.
     * @example
     * // Create many PackagesHeroes
     * const packagesHero = await prisma.packagesHero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackagesHeroCreateManyArgs>(args?: SelectSubset<T, PackagesHeroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackagesHeroes and returns the data saved in the database.
     * @param {PackagesHeroCreateManyAndReturnArgs} args - Arguments to create many PackagesHeroes.
     * @example
     * // Create many PackagesHeroes
     * const packagesHero = await prisma.packagesHero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackagesHeroes and only return the `id`
     * const packagesHeroWithIdOnly = await prisma.packagesHero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackagesHeroCreateManyAndReturnArgs>(args?: SelectSubset<T, PackagesHeroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackagesHero.
     * @param {PackagesHeroDeleteArgs} args - Arguments to delete one PackagesHero.
     * @example
     * // Delete one PackagesHero
     * const PackagesHero = await prisma.packagesHero.delete({
     *   where: {
     *     // ... filter to delete one PackagesHero
     *   }
     * })
     * 
     */
    delete<T extends PackagesHeroDeleteArgs>(args: SelectSubset<T, PackagesHeroDeleteArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackagesHero.
     * @param {PackagesHeroUpdateArgs} args - Arguments to update one PackagesHero.
     * @example
     * // Update one PackagesHero
     * const packagesHero = await prisma.packagesHero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackagesHeroUpdateArgs>(args: SelectSubset<T, PackagesHeroUpdateArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackagesHeroes.
     * @param {PackagesHeroDeleteManyArgs} args - Arguments to filter PackagesHeroes to delete.
     * @example
     * // Delete a few PackagesHeroes
     * const { count } = await prisma.packagesHero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackagesHeroDeleteManyArgs>(args?: SelectSubset<T, PackagesHeroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackagesHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackagesHeroes
     * const packagesHero = await prisma.packagesHero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackagesHeroUpdateManyArgs>(args: SelectSubset<T, PackagesHeroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackagesHeroes and returns the data updated in the database.
     * @param {PackagesHeroUpdateManyAndReturnArgs} args - Arguments to update many PackagesHeroes.
     * @example
     * // Update many PackagesHeroes
     * const packagesHero = await prisma.packagesHero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackagesHeroes and only return the `id`
     * const packagesHeroWithIdOnly = await prisma.packagesHero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackagesHeroUpdateManyAndReturnArgs>(args: SelectSubset<T, PackagesHeroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackagesHero.
     * @param {PackagesHeroUpsertArgs} args - Arguments to update or create a PackagesHero.
     * @example
     * // Update or create a PackagesHero
     * const packagesHero = await prisma.packagesHero.upsert({
     *   create: {
     *     // ... data to create a PackagesHero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackagesHero we want to update
     *   }
     * })
     */
    upsert<T extends PackagesHeroUpsertArgs>(args: SelectSubset<T, PackagesHeroUpsertArgs<ExtArgs>>): Prisma__PackagesHeroClient<$Result.GetResult<Prisma.$PackagesHeroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackagesHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroCountArgs} args - Arguments to filter PackagesHeroes to count.
     * @example
     * // Count the number of PackagesHeroes
     * const count = await prisma.packagesHero.count({
     *   where: {
     *     // ... the filter for the PackagesHeroes we want to count
     *   }
     * })
    **/
    count<T extends PackagesHeroCountArgs>(
      args?: Subset<T, PackagesHeroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagesHeroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackagesHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagesHeroAggregateArgs>(args: Subset<T, PackagesHeroAggregateArgs>): Prisma.PrismaPromise<GetPackagesHeroAggregateType<T>>

    /**
     * Group by PackagesHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesHeroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackagesHeroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackagesHeroGroupByArgs['orderBy'] }
        : { orderBy?: PackagesHeroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackagesHeroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagesHeroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackagesHero model
   */
  readonly fields: PackagesHeroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackagesHero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackagesHeroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackagesHero model
   */
  interface PackagesHeroFieldRefs {
    readonly id: FieldRef<"PackagesHero", 'String'>
    readonly image: FieldRef<"PackagesHero", 'String'>
    readonly title: FieldRef<"PackagesHero", 'String'>
    readonly subtitle: FieldRef<"PackagesHero", 'String'>
    readonly description: FieldRef<"PackagesHero", 'String'>
    readonly status: FieldRef<"PackagesHero", 'ContentStatus'>
    readonly publishedAt: FieldRef<"PackagesHero", 'DateTime'>
    readonly createdAt: FieldRef<"PackagesHero", 'DateTime'>
    readonly updatedAt: FieldRef<"PackagesHero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackagesHero findUnique
   */
  export type PackagesHeroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter, which PackagesHero to fetch.
     */
    where: PackagesHeroWhereUniqueInput
  }

  /**
   * PackagesHero findUniqueOrThrow
   */
  export type PackagesHeroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter, which PackagesHero to fetch.
     */
    where: PackagesHeroWhereUniqueInput
  }

  /**
   * PackagesHero findFirst
   */
  export type PackagesHeroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter, which PackagesHero to fetch.
     */
    where?: PackagesHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagesHeroes to fetch.
     */
    orderBy?: PackagesHeroOrderByWithRelationInput | PackagesHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagesHeroes.
     */
    cursor?: PackagesHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagesHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagesHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagesHeroes.
     */
    distinct?: PackagesHeroScalarFieldEnum | PackagesHeroScalarFieldEnum[]
  }

  /**
   * PackagesHero findFirstOrThrow
   */
  export type PackagesHeroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter, which PackagesHero to fetch.
     */
    where?: PackagesHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagesHeroes to fetch.
     */
    orderBy?: PackagesHeroOrderByWithRelationInput | PackagesHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagesHeroes.
     */
    cursor?: PackagesHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagesHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagesHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagesHeroes.
     */
    distinct?: PackagesHeroScalarFieldEnum | PackagesHeroScalarFieldEnum[]
  }

  /**
   * PackagesHero findMany
   */
  export type PackagesHeroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter, which PackagesHeroes to fetch.
     */
    where?: PackagesHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagesHeroes to fetch.
     */
    orderBy?: PackagesHeroOrderByWithRelationInput | PackagesHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackagesHeroes.
     */
    cursor?: PackagesHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagesHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagesHeroes.
     */
    skip?: number
    distinct?: PackagesHeroScalarFieldEnum | PackagesHeroScalarFieldEnum[]
  }

  /**
   * PackagesHero create
   */
  export type PackagesHeroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * The data needed to create a PackagesHero.
     */
    data: XOR<PackagesHeroCreateInput, PackagesHeroUncheckedCreateInput>
  }

  /**
   * PackagesHero createMany
   */
  export type PackagesHeroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackagesHeroes.
     */
    data: PackagesHeroCreateManyInput | PackagesHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackagesHero createManyAndReturn
   */
  export type PackagesHeroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * The data used to create many PackagesHeroes.
     */
    data: PackagesHeroCreateManyInput | PackagesHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackagesHero update
   */
  export type PackagesHeroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * The data needed to update a PackagesHero.
     */
    data: XOR<PackagesHeroUpdateInput, PackagesHeroUncheckedUpdateInput>
    /**
     * Choose, which PackagesHero to update.
     */
    where: PackagesHeroWhereUniqueInput
  }

  /**
   * PackagesHero updateMany
   */
  export type PackagesHeroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackagesHeroes.
     */
    data: XOR<PackagesHeroUpdateManyMutationInput, PackagesHeroUncheckedUpdateManyInput>
    /**
     * Filter which PackagesHeroes to update
     */
    where?: PackagesHeroWhereInput
    /**
     * Limit how many PackagesHeroes to update.
     */
    limit?: number
  }

  /**
   * PackagesHero updateManyAndReturn
   */
  export type PackagesHeroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * The data used to update PackagesHeroes.
     */
    data: XOR<PackagesHeroUpdateManyMutationInput, PackagesHeroUncheckedUpdateManyInput>
    /**
     * Filter which PackagesHeroes to update
     */
    where?: PackagesHeroWhereInput
    /**
     * Limit how many PackagesHeroes to update.
     */
    limit?: number
  }

  /**
   * PackagesHero upsert
   */
  export type PackagesHeroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * The filter to search for the PackagesHero to update in case it exists.
     */
    where: PackagesHeroWhereUniqueInput
    /**
     * In case the PackagesHero found by the `where` argument doesn't exist, create a new PackagesHero with this data.
     */
    create: XOR<PackagesHeroCreateInput, PackagesHeroUncheckedCreateInput>
    /**
     * In case the PackagesHero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackagesHeroUpdateInput, PackagesHeroUncheckedUpdateInput>
  }

  /**
   * PackagesHero delete
   */
  export type PackagesHeroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
    /**
     * Filter which PackagesHero to delete.
     */
    where: PackagesHeroWhereUniqueInput
  }

  /**
   * PackagesHero deleteMany
   */
  export type PackagesHeroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagesHeroes to delete
     */
    where?: PackagesHeroWhereInput
    /**
     * Limit how many PackagesHeroes to delete.
     */
    limit?: number
  }

  /**
   * PackagesHero without action
   */
  export type PackagesHeroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesHero
     */
    select?: PackagesHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackagesHero
     */
    omit?: PackagesHeroOmit<ExtArgs> | null
  }


  /**
   * Model DestinationsHero
   */

  export type AggregateDestinationsHero = {
    _count: DestinationsHeroCountAggregateOutputType | null
    _min: DestinationsHeroMinAggregateOutputType | null
    _max: DestinationsHeroMaxAggregateOutputType | null
  }

  export type DestinationsHeroMinAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationsHeroMaxAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationsHeroCountAggregateOutputType = {
    id: number
    image: number
    title: number
    subtitle: number
    description: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationsHeroMinAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationsHeroMaxAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationsHeroCountAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationsHeroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationsHero to aggregate.
     */
    where?: DestinationsHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsHeroes to fetch.
     */
    orderBy?: DestinationsHeroOrderByWithRelationInput | DestinationsHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationsHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DestinationsHeroes
    **/
    _count?: true | DestinationsHeroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationsHeroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationsHeroMaxAggregateInputType
  }

  export type GetDestinationsHeroAggregateType<T extends DestinationsHeroAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinationsHero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinationsHero[P]>
      : GetScalarType<T[P], AggregateDestinationsHero[P]>
  }




  export type DestinationsHeroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationsHeroWhereInput
    orderBy?: DestinationsHeroOrderByWithAggregationInput | DestinationsHeroOrderByWithAggregationInput[]
    by: DestinationsHeroScalarFieldEnum[] | DestinationsHeroScalarFieldEnum
    having?: DestinationsHeroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationsHeroCountAggregateInputType | true
    _min?: DestinationsHeroMinAggregateInputType
    _max?: DestinationsHeroMaxAggregateInputType
  }

  export type DestinationsHeroGroupByOutputType = {
    id: string
    image: string
    title: string
    subtitle: string
    description: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DestinationsHeroCountAggregateOutputType | null
    _min: DestinationsHeroMinAggregateOutputType | null
    _max: DestinationsHeroMaxAggregateOutputType | null
  }

  type GetDestinationsHeroGroupByPayload<T extends DestinationsHeroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationsHeroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationsHeroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationsHeroGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationsHeroGroupByOutputType[P]>
        }
      >
    >


  export type DestinationsHeroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsHero"]>

  export type DestinationsHeroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsHero"]>

  export type DestinationsHeroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsHero"]>

  export type DestinationsHeroSelectScalar = {
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationsHeroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "title" | "subtitle" | "description" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["destinationsHero"]>

  export type $DestinationsHeroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DestinationsHero"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      title: string
      subtitle: string
      description: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destinationsHero"]>
    composites: {}
  }

  type DestinationsHeroGetPayload<S extends boolean | null | undefined | DestinationsHeroDefaultArgs> = $Result.GetResult<Prisma.$DestinationsHeroPayload, S>

  type DestinationsHeroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationsHeroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationsHeroCountAggregateInputType | true
    }

  export interface DestinationsHeroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DestinationsHero'], meta: { name: 'DestinationsHero' } }
    /**
     * Find zero or one DestinationsHero that matches the filter.
     * @param {DestinationsHeroFindUniqueArgs} args - Arguments to find a DestinationsHero
     * @example
     * // Get one DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationsHeroFindUniqueArgs>(args: SelectSubset<T, DestinationsHeroFindUniqueArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DestinationsHero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationsHeroFindUniqueOrThrowArgs} args - Arguments to find a DestinationsHero
     * @example
     * // Get one DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationsHeroFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationsHeroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationsHero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroFindFirstArgs} args - Arguments to find a DestinationsHero
     * @example
     * // Get one DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationsHeroFindFirstArgs>(args?: SelectSubset<T, DestinationsHeroFindFirstArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationsHero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroFindFirstOrThrowArgs} args - Arguments to find a DestinationsHero
     * @example
     * // Get one DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationsHeroFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationsHeroFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DestinationsHeroes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DestinationsHeroes
     * const destinationsHeroes = await prisma.destinationsHero.findMany()
     * 
     * // Get first 10 DestinationsHeroes
     * const destinationsHeroes = await prisma.destinationsHero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationsHeroWithIdOnly = await prisma.destinationsHero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationsHeroFindManyArgs>(args?: SelectSubset<T, DestinationsHeroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DestinationsHero.
     * @param {DestinationsHeroCreateArgs} args - Arguments to create a DestinationsHero.
     * @example
     * // Create one DestinationsHero
     * const DestinationsHero = await prisma.destinationsHero.create({
     *   data: {
     *     // ... data to create a DestinationsHero
     *   }
     * })
     * 
     */
    create<T extends DestinationsHeroCreateArgs>(args: SelectSubset<T, DestinationsHeroCreateArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DestinationsHeroes.
     * @param {DestinationsHeroCreateManyArgs} args - Arguments to create many DestinationsHeroes.
     * @example
     * // Create many DestinationsHeroes
     * const destinationsHero = await prisma.destinationsHero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationsHeroCreateManyArgs>(args?: SelectSubset<T, DestinationsHeroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DestinationsHeroes and returns the data saved in the database.
     * @param {DestinationsHeroCreateManyAndReturnArgs} args - Arguments to create many DestinationsHeroes.
     * @example
     * // Create many DestinationsHeroes
     * const destinationsHero = await prisma.destinationsHero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DestinationsHeroes and only return the `id`
     * const destinationsHeroWithIdOnly = await prisma.destinationsHero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationsHeroCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationsHeroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DestinationsHero.
     * @param {DestinationsHeroDeleteArgs} args - Arguments to delete one DestinationsHero.
     * @example
     * // Delete one DestinationsHero
     * const DestinationsHero = await prisma.destinationsHero.delete({
     *   where: {
     *     // ... filter to delete one DestinationsHero
     *   }
     * })
     * 
     */
    delete<T extends DestinationsHeroDeleteArgs>(args: SelectSubset<T, DestinationsHeroDeleteArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DestinationsHero.
     * @param {DestinationsHeroUpdateArgs} args - Arguments to update one DestinationsHero.
     * @example
     * // Update one DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationsHeroUpdateArgs>(args: SelectSubset<T, DestinationsHeroUpdateArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DestinationsHeroes.
     * @param {DestinationsHeroDeleteManyArgs} args - Arguments to filter DestinationsHeroes to delete.
     * @example
     * // Delete a few DestinationsHeroes
     * const { count } = await prisma.destinationsHero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationsHeroDeleteManyArgs>(args?: SelectSubset<T, DestinationsHeroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationsHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DestinationsHeroes
     * const destinationsHero = await prisma.destinationsHero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationsHeroUpdateManyArgs>(args: SelectSubset<T, DestinationsHeroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationsHeroes and returns the data updated in the database.
     * @param {DestinationsHeroUpdateManyAndReturnArgs} args - Arguments to update many DestinationsHeroes.
     * @example
     * // Update many DestinationsHeroes
     * const destinationsHero = await prisma.destinationsHero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DestinationsHeroes and only return the `id`
     * const destinationsHeroWithIdOnly = await prisma.destinationsHero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationsHeroUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationsHeroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DestinationsHero.
     * @param {DestinationsHeroUpsertArgs} args - Arguments to update or create a DestinationsHero.
     * @example
     * // Update or create a DestinationsHero
     * const destinationsHero = await prisma.destinationsHero.upsert({
     *   create: {
     *     // ... data to create a DestinationsHero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DestinationsHero we want to update
     *   }
     * })
     */
    upsert<T extends DestinationsHeroUpsertArgs>(args: SelectSubset<T, DestinationsHeroUpsertArgs<ExtArgs>>): Prisma__DestinationsHeroClient<$Result.GetResult<Prisma.$DestinationsHeroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DestinationsHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroCountArgs} args - Arguments to filter DestinationsHeroes to count.
     * @example
     * // Count the number of DestinationsHeroes
     * const count = await prisma.destinationsHero.count({
     *   where: {
     *     // ... the filter for the DestinationsHeroes we want to count
     *   }
     * })
    **/
    count<T extends DestinationsHeroCountArgs>(
      args?: Subset<T, DestinationsHeroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationsHeroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DestinationsHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationsHeroAggregateArgs>(args: Subset<T, DestinationsHeroAggregateArgs>): Prisma.PrismaPromise<GetDestinationsHeroAggregateType<T>>

    /**
     * Group by DestinationsHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsHeroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationsHeroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationsHeroGroupByArgs['orderBy'] }
        : { orderBy?: DestinationsHeroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationsHeroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationsHeroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DestinationsHero model
   */
  readonly fields: DestinationsHeroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DestinationsHero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationsHeroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DestinationsHero model
   */
  interface DestinationsHeroFieldRefs {
    readonly id: FieldRef<"DestinationsHero", 'String'>
    readonly image: FieldRef<"DestinationsHero", 'String'>
    readonly title: FieldRef<"DestinationsHero", 'String'>
    readonly subtitle: FieldRef<"DestinationsHero", 'String'>
    readonly description: FieldRef<"DestinationsHero", 'String'>
    readonly status: FieldRef<"DestinationsHero", 'ContentStatus'>
    readonly publishedAt: FieldRef<"DestinationsHero", 'DateTime'>
    readonly createdAt: FieldRef<"DestinationsHero", 'DateTime'>
    readonly updatedAt: FieldRef<"DestinationsHero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DestinationsHero findUnique
   */
  export type DestinationsHeroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsHero to fetch.
     */
    where: DestinationsHeroWhereUniqueInput
  }

  /**
   * DestinationsHero findUniqueOrThrow
   */
  export type DestinationsHeroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsHero to fetch.
     */
    where: DestinationsHeroWhereUniqueInput
  }

  /**
   * DestinationsHero findFirst
   */
  export type DestinationsHeroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsHero to fetch.
     */
    where?: DestinationsHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsHeroes to fetch.
     */
    orderBy?: DestinationsHeroOrderByWithRelationInput | DestinationsHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationsHeroes.
     */
    cursor?: DestinationsHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationsHeroes.
     */
    distinct?: DestinationsHeroScalarFieldEnum | DestinationsHeroScalarFieldEnum[]
  }

  /**
   * DestinationsHero findFirstOrThrow
   */
  export type DestinationsHeroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsHero to fetch.
     */
    where?: DestinationsHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsHeroes to fetch.
     */
    orderBy?: DestinationsHeroOrderByWithRelationInput | DestinationsHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationsHeroes.
     */
    cursor?: DestinationsHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationsHeroes.
     */
    distinct?: DestinationsHeroScalarFieldEnum | DestinationsHeroScalarFieldEnum[]
  }

  /**
   * DestinationsHero findMany
   */
  export type DestinationsHeroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsHeroes to fetch.
     */
    where?: DestinationsHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsHeroes to fetch.
     */
    orderBy?: DestinationsHeroOrderByWithRelationInput | DestinationsHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DestinationsHeroes.
     */
    cursor?: DestinationsHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsHeroes.
     */
    skip?: number
    distinct?: DestinationsHeroScalarFieldEnum | DestinationsHeroScalarFieldEnum[]
  }

  /**
   * DestinationsHero create
   */
  export type DestinationsHeroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * The data needed to create a DestinationsHero.
     */
    data: XOR<DestinationsHeroCreateInput, DestinationsHeroUncheckedCreateInput>
  }

  /**
   * DestinationsHero createMany
   */
  export type DestinationsHeroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DestinationsHeroes.
     */
    data: DestinationsHeroCreateManyInput | DestinationsHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DestinationsHero createManyAndReturn
   */
  export type DestinationsHeroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * The data used to create many DestinationsHeroes.
     */
    data: DestinationsHeroCreateManyInput | DestinationsHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DestinationsHero update
   */
  export type DestinationsHeroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * The data needed to update a DestinationsHero.
     */
    data: XOR<DestinationsHeroUpdateInput, DestinationsHeroUncheckedUpdateInput>
    /**
     * Choose, which DestinationsHero to update.
     */
    where: DestinationsHeroWhereUniqueInput
  }

  /**
   * DestinationsHero updateMany
   */
  export type DestinationsHeroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DestinationsHeroes.
     */
    data: XOR<DestinationsHeroUpdateManyMutationInput, DestinationsHeroUncheckedUpdateManyInput>
    /**
     * Filter which DestinationsHeroes to update
     */
    where?: DestinationsHeroWhereInput
    /**
     * Limit how many DestinationsHeroes to update.
     */
    limit?: number
  }

  /**
   * DestinationsHero updateManyAndReturn
   */
  export type DestinationsHeroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * The data used to update DestinationsHeroes.
     */
    data: XOR<DestinationsHeroUpdateManyMutationInput, DestinationsHeroUncheckedUpdateManyInput>
    /**
     * Filter which DestinationsHeroes to update
     */
    where?: DestinationsHeroWhereInput
    /**
     * Limit how many DestinationsHeroes to update.
     */
    limit?: number
  }

  /**
   * DestinationsHero upsert
   */
  export type DestinationsHeroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * The filter to search for the DestinationsHero to update in case it exists.
     */
    where: DestinationsHeroWhereUniqueInput
    /**
     * In case the DestinationsHero found by the `where` argument doesn't exist, create a new DestinationsHero with this data.
     */
    create: XOR<DestinationsHeroCreateInput, DestinationsHeroUncheckedCreateInput>
    /**
     * In case the DestinationsHero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationsHeroUpdateInput, DestinationsHeroUncheckedUpdateInput>
  }

  /**
   * DestinationsHero delete
   */
  export type DestinationsHeroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
    /**
     * Filter which DestinationsHero to delete.
     */
    where: DestinationsHeroWhereUniqueInput
  }

  /**
   * DestinationsHero deleteMany
   */
  export type DestinationsHeroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationsHeroes to delete
     */
    where?: DestinationsHeroWhereInput
    /**
     * Limit how many DestinationsHeroes to delete.
     */
    limit?: number
  }

  /**
   * DestinationsHero without action
   */
  export type DestinationsHeroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsHero
     */
    select?: DestinationsHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsHero
     */
    omit?: DestinationsHeroOmit<ExtArgs> | null
  }


  /**
   * Model DestinationsCTA
   */

  export type AggregateDestinationsCTA = {
    _count: DestinationsCTACountAggregateOutputType | null
    _min: DestinationsCTAMinAggregateOutputType | null
    _max: DestinationsCTAMaxAggregateOutputType | null
  }

  export type DestinationsCTAMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    buttonText: string | null
    buttonLink: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationsCTAMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    buttonText: string | null
    buttonLink: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationsCTACountAggregateOutputType = {
    id: number
    title: number
    description: number
    buttonText: number
    buttonLink: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationsCTAMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationsCTAMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationsCTACountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationsCTAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationsCTA to aggregate.
     */
    where?: DestinationsCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsCTAS to fetch.
     */
    orderBy?: DestinationsCTAOrderByWithRelationInput | DestinationsCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationsCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DestinationsCTAS
    **/
    _count?: true | DestinationsCTACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationsCTAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationsCTAMaxAggregateInputType
  }

  export type GetDestinationsCTAAggregateType<T extends DestinationsCTAAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinationsCTA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinationsCTA[P]>
      : GetScalarType<T[P], AggregateDestinationsCTA[P]>
  }




  export type DestinationsCTAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationsCTAWhereInput
    orderBy?: DestinationsCTAOrderByWithAggregationInput | DestinationsCTAOrderByWithAggregationInput[]
    by: DestinationsCTAScalarFieldEnum[] | DestinationsCTAScalarFieldEnum
    having?: DestinationsCTAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationsCTACountAggregateInputType | true
    _min?: DestinationsCTAMinAggregateInputType
    _max?: DestinationsCTAMaxAggregateInputType
  }

  export type DestinationsCTAGroupByOutputType = {
    id: string
    title: string
    description: string
    buttonText: string
    buttonLink: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DestinationsCTACountAggregateOutputType | null
    _min: DestinationsCTAMinAggregateOutputType | null
    _max: DestinationsCTAMaxAggregateOutputType | null
  }

  type GetDestinationsCTAGroupByPayload<T extends DestinationsCTAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationsCTAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationsCTAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationsCTAGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationsCTAGroupByOutputType[P]>
        }
      >
    >


  export type DestinationsCTASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsCTA"]>

  export type DestinationsCTASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsCTA"]>

  export type DestinationsCTASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destinationsCTA"]>

  export type DestinationsCTASelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationsCTAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "buttonText" | "buttonLink" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["destinationsCTA"]>

  export type $DestinationsCTAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DestinationsCTA"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      buttonText: string
      buttonLink: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destinationsCTA"]>
    composites: {}
  }

  type DestinationsCTAGetPayload<S extends boolean | null | undefined | DestinationsCTADefaultArgs> = $Result.GetResult<Prisma.$DestinationsCTAPayload, S>

  type DestinationsCTACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationsCTAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationsCTACountAggregateInputType | true
    }

  export interface DestinationsCTADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DestinationsCTA'], meta: { name: 'DestinationsCTA' } }
    /**
     * Find zero or one DestinationsCTA that matches the filter.
     * @param {DestinationsCTAFindUniqueArgs} args - Arguments to find a DestinationsCTA
     * @example
     * // Get one DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationsCTAFindUniqueArgs>(args: SelectSubset<T, DestinationsCTAFindUniqueArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DestinationsCTA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationsCTAFindUniqueOrThrowArgs} args - Arguments to find a DestinationsCTA
     * @example
     * // Get one DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationsCTAFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationsCTAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationsCTA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAFindFirstArgs} args - Arguments to find a DestinationsCTA
     * @example
     * // Get one DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationsCTAFindFirstArgs>(args?: SelectSubset<T, DestinationsCTAFindFirstArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationsCTA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAFindFirstOrThrowArgs} args - Arguments to find a DestinationsCTA
     * @example
     * // Get one DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationsCTAFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationsCTAFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DestinationsCTAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DestinationsCTAS
     * const destinationsCTAS = await prisma.destinationsCTA.findMany()
     * 
     * // Get first 10 DestinationsCTAS
     * const destinationsCTAS = await prisma.destinationsCTA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationsCTAWithIdOnly = await prisma.destinationsCTA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationsCTAFindManyArgs>(args?: SelectSubset<T, DestinationsCTAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DestinationsCTA.
     * @param {DestinationsCTACreateArgs} args - Arguments to create a DestinationsCTA.
     * @example
     * // Create one DestinationsCTA
     * const DestinationsCTA = await prisma.destinationsCTA.create({
     *   data: {
     *     // ... data to create a DestinationsCTA
     *   }
     * })
     * 
     */
    create<T extends DestinationsCTACreateArgs>(args: SelectSubset<T, DestinationsCTACreateArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DestinationsCTAS.
     * @param {DestinationsCTACreateManyArgs} args - Arguments to create many DestinationsCTAS.
     * @example
     * // Create many DestinationsCTAS
     * const destinationsCTA = await prisma.destinationsCTA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationsCTACreateManyArgs>(args?: SelectSubset<T, DestinationsCTACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DestinationsCTAS and returns the data saved in the database.
     * @param {DestinationsCTACreateManyAndReturnArgs} args - Arguments to create many DestinationsCTAS.
     * @example
     * // Create many DestinationsCTAS
     * const destinationsCTA = await prisma.destinationsCTA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DestinationsCTAS and only return the `id`
     * const destinationsCTAWithIdOnly = await prisma.destinationsCTA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationsCTACreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationsCTACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DestinationsCTA.
     * @param {DestinationsCTADeleteArgs} args - Arguments to delete one DestinationsCTA.
     * @example
     * // Delete one DestinationsCTA
     * const DestinationsCTA = await prisma.destinationsCTA.delete({
     *   where: {
     *     // ... filter to delete one DestinationsCTA
     *   }
     * })
     * 
     */
    delete<T extends DestinationsCTADeleteArgs>(args: SelectSubset<T, DestinationsCTADeleteArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DestinationsCTA.
     * @param {DestinationsCTAUpdateArgs} args - Arguments to update one DestinationsCTA.
     * @example
     * // Update one DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationsCTAUpdateArgs>(args: SelectSubset<T, DestinationsCTAUpdateArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DestinationsCTAS.
     * @param {DestinationsCTADeleteManyArgs} args - Arguments to filter DestinationsCTAS to delete.
     * @example
     * // Delete a few DestinationsCTAS
     * const { count } = await prisma.destinationsCTA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationsCTADeleteManyArgs>(args?: SelectSubset<T, DestinationsCTADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationsCTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DestinationsCTAS
     * const destinationsCTA = await prisma.destinationsCTA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationsCTAUpdateManyArgs>(args: SelectSubset<T, DestinationsCTAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationsCTAS and returns the data updated in the database.
     * @param {DestinationsCTAUpdateManyAndReturnArgs} args - Arguments to update many DestinationsCTAS.
     * @example
     * // Update many DestinationsCTAS
     * const destinationsCTA = await prisma.destinationsCTA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DestinationsCTAS and only return the `id`
     * const destinationsCTAWithIdOnly = await prisma.destinationsCTA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationsCTAUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationsCTAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DestinationsCTA.
     * @param {DestinationsCTAUpsertArgs} args - Arguments to update or create a DestinationsCTA.
     * @example
     * // Update or create a DestinationsCTA
     * const destinationsCTA = await prisma.destinationsCTA.upsert({
     *   create: {
     *     // ... data to create a DestinationsCTA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DestinationsCTA we want to update
     *   }
     * })
     */
    upsert<T extends DestinationsCTAUpsertArgs>(args: SelectSubset<T, DestinationsCTAUpsertArgs<ExtArgs>>): Prisma__DestinationsCTAClient<$Result.GetResult<Prisma.$DestinationsCTAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DestinationsCTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTACountArgs} args - Arguments to filter DestinationsCTAS to count.
     * @example
     * // Count the number of DestinationsCTAS
     * const count = await prisma.destinationsCTA.count({
     *   where: {
     *     // ... the filter for the DestinationsCTAS we want to count
     *   }
     * })
    **/
    count<T extends DestinationsCTACountArgs>(
      args?: Subset<T, DestinationsCTACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationsCTACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DestinationsCTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationsCTAAggregateArgs>(args: Subset<T, DestinationsCTAAggregateArgs>): Prisma.PrismaPromise<GetDestinationsCTAAggregateType<T>>

    /**
     * Group by DestinationsCTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationsCTAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationsCTAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationsCTAGroupByArgs['orderBy'] }
        : { orderBy?: DestinationsCTAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationsCTAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationsCTAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DestinationsCTA model
   */
  readonly fields: DestinationsCTAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DestinationsCTA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationsCTAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DestinationsCTA model
   */
  interface DestinationsCTAFieldRefs {
    readonly id: FieldRef<"DestinationsCTA", 'String'>
    readonly title: FieldRef<"DestinationsCTA", 'String'>
    readonly description: FieldRef<"DestinationsCTA", 'String'>
    readonly buttonText: FieldRef<"DestinationsCTA", 'String'>
    readonly buttonLink: FieldRef<"DestinationsCTA", 'String'>
    readonly status: FieldRef<"DestinationsCTA", 'ContentStatus'>
    readonly publishedAt: FieldRef<"DestinationsCTA", 'DateTime'>
    readonly createdAt: FieldRef<"DestinationsCTA", 'DateTime'>
    readonly updatedAt: FieldRef<"DestinationsCTA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DestinationsCTA findUnique
   */
  export type DestinationsCTAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsCTA to fetch.
     */
    where: DestinationsCTAWhereUniqueInput
  }

  /**
   * DestinationsCTA findUniqueOrThrow
   */
  export type DestinationsCTAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsCTA to fetch.
     */
    where: DestinationsCTAWhereUniqueInput
  }

  /**
   * DestinationsCTA findFirst
   */
  export type DestinationsCTAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsCTA to fetch.
     */
    where?: DestinationsCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsCTAS to fetch.
     */
    orderBy?: DestinationsCTAOrderByWithRelationInput | DestinationsCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationsCTAS.
     */
    cursor?: DestinationsCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationsCTAS.
     */
    distinct?: DestinationsCTAScalarFieldEnum | DestinationsCTAScalarFieldEnum[]
  }

  /**
   * DestinationsCTA findFirstOrThrow
   */
  export type DestinationsCTAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsCTA to fetch.
     */
    where?: DestinationsCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsCTAS to fetch.
     */
    orderBy?: DestinationsCTAOrderByWithRelationInput | DestinationsCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationsCTAS.
     */
    cursor?: DestinationsCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationsCTAS.
     */
    distinct?: DestinationsCTAScalarFieldEnum | DestinationsCTAScalarFieldEnum[]
  }

  /**
   * DestinationsCTA findMany
   */
  export type DestinationsCTAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter, which DestinationsCTAS to fetch.
     */
    where?: DestinationsCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationsCTAS to fetch.
     */
    orderBy?: DestinationsCTAOrderByWithRelationInput | DestinationsCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DestinationsCTAS.
     */
    cursor?: DestinationsCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationsCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationsCTAS.
     */
    skip?: number
    distinct?: DestinationsCTAScalarFieldEnum | DestinationsCTAScalarFieldEnum[]
  }

  /**
   * DestinationsCTA create
   */
  export type DestinationsCTACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * The data needed to create a DestinationsCTA.
     */
    data: XOR<DestinationsCTACreateInput, DestinationsCTAUncheckedCreateInput>
  }

  /**
   * DestinationsCTA createMany
   */
  export type DestinationsCTACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DestinationsCTAS.
     */
    data: DestinationsCTACreateManyInput | DestinationsCTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DestinationsCTA createManyAndReturn
   */
  export type DestinationsCTACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * The data used to create many DestinationsCTAS.
     */
    data: DestinationsCTACreateManyInput | DestinationsCTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DestinationsCTA update
   */
  export type DestinationsCTAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * The data needed to update a DestinationsCTA.
     */
    data: XOR<DestinationsCTAUpdateInput, DestinationsCTAUncheckedUpdateInput>
    /**
     * Choose, which DestinationsCTA to update.
     */
    where: DestinationsCTAWhereUniqueInput
  }

  /**
   * DestinationsCTA updateMany
   */
  export type DestinationsCTAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DestinationsCTAS.
     */
    data: XOR<DestinationsCTAUpdateManyMutationInput, DestinationsCTAUncheckedUpdateManyInput>
    /**
     * Filter which DestinationsCTAS to update
     */
    where?: DestinationsCTAWhereInput
    /**
     * Limit how many DestinationsCTAS to update.
     */
    limit?: number
  }

  /**
   * DestinationsCTA updateManyAndReturn
   */
  export type DestinationsCTAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * The data used to update DestinationsCTAS.
     */
    data: XOR<DestinationsCTAUpdateManyMutationInput, DestinationsCTAUncheckedUpdateManyInput>
    /**
     * Filter which DestinationsCTAS to update
     */
    where?: DestinationsCTAWhereInput
    /**
     * Limit how many DestinationsCTAS to update.
     */
    limit?: number
  }

  /**
   * DestinationsCTA upsert
   */
  export type DestinationsCTAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * The filter to search for the DestinationsCTA to update in case it exists.
     */
    where: DestinationsCTAWhereUniqueInput
    /**
     * In case the DestinationsCTA found by the `where` argument doesn't exist, create a new DestinationsCTA with this data.
     */
    create: XOR<DestinationsCTACreateInput, DestinationsCTAUncheckedCreateInput>
    /**
     * In case the DestinationsCTA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationsCTAUpdateInput, DestinationsCTAUncheckedUpdateInput>
  }

  /**
   * DestinationsCTA delete
   */
  export type DestinationsCTADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
    /**
     * Filter which DestinationsCTA to delete.
     */
    where: DestinationsCTAWhereUniqueInput
  }

  /**
   * DestinationsCTA deleteMany
   */
  export type DestinationsCTADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationsCTAS to delete
     */
    where?: DestinationsCTAWhereInput
    /**
     * Limit how many DestinationsCTAS to delete.
     */
    limit?: number
  }

  /**
   * DestinationsCTA without action
   */
  export type DestinationsCTADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationsCTA
     */
    select?: DestinationsCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationsCTA
     */
    omit?: DestinationsCTAOmit<ExtArgs> | null
  }


  /**
   * Model AboutStorySection
   */

  export type AggregateAboutStorySection = {
    _count: AboutStorySectionCountAggregateOutputType | null
    _min: AboutStorySectionMinAggregateOutputType | null
    _max: AboutStorySectionMaxAggregateOutputType | null
  }

  export type AboutStorySectionMinAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    titleHighlight: string | null
    paragraph1: string | null
    paragraph2: string | null
    buttonText: string | null
    buttonLink: string | null
    image: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutStorySectionMaxAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    titleHighlight: string | null
    paragraph1: string | null
    paragraph2: string | null
    buttonText: string | null
    buttonLink: string | null
    image: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutStorySectionCountAggregateOutputType = {
    id: number
    heading: number
    title: number
    titleHighlight: number
    paragraph1: number
    paragraph2: number
    buttonText: number
    buttonLink: number
    image: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutStorySectionMinAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    image?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutStorySectionMaxAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    image?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutStorySectionCountAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    image?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutStorySectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutStorySection to aggregate.
     */
    where?: AboutStorySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStorySections to fetch.
     */
    orderBy?: AboutStorySectionOrderByWithRelationInput | AboutStorySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutStorySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStorySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStorySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutStorySections
    **/
    _count?: true | AboutStorySectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutStorySectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutStorySectionMaxAggregateInputType
  }

  export type GetAboutStorySectionAggregateType<T extends AboutStorySectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutStorySection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutStorySection[P]>
      : GetScalarType<T[P], AggregateAboutStorySection[P]>
  }




  export type AboutStorySectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutStorySectionWhereInput
    orderBy?: AboutStorySectionOrderByWithAggregationInput | AboutStorySectionOrderByWithAggregationInput[]
    by: AboutStorySectionScalarFieldEnum[] | AboutStorySectionScalarFieldEnum
    having?: AboutStorySectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutStorySectionCountAggregateInputType | true
    _min?: AboutStorySectionMinAggregateInputType
    _max?: AboutStorySectionMaxAggregateInputType
  }

  export type AboutStorySectionGroupByOutputType = {
    id: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    image: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AboutStorySectionCountAggregateOutputType | null
    _min: AboutStorySectionMinAggregateOutputType | null
    _max: AboutStorySectionMaxAggregateOutputType | null
  }

  type GetAboutStorySectionGroupByPayload<T extends AboutStorySectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutStorySectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutStorySectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutStorySectionGroupByOutputType[P]>
            : GetScalarType<T[P], AboutStorySectionGroupByOutputType[P]>
        }
      >
    >


  export type AboutStorySectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    image?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStorySection"]>

  export type AboutStorySectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    image?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStorySection"]>

  export type AboutStorySectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    image?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStorySection"]>

  export type AboutStorySectionSelectScalar = {
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    image?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutStorySectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heading" | "title" | "titleHighlight" | "paragraph1" | "paragraph2" | "buttonText" | "buttonLink" | "image" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutStorySection"]>

  export type $AboutStorySectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutStorySection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      heading: string
      title: string
      titleHighlight: string
      paragraph1: string
      paragraph2: string
      buttonText: string
      buttonLink: string
      image: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutStorySection"]>
    composites: {}
  }

  type AboutStorySectionGetPayload<S extends boolean | null | undefined | AboutStorySectionDefaultArgs> = $Result.GetResult<Prisma.$AboutStorySectionPayload, S>

  type AboutStorySectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutStorySectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutStorySectionCountAggregateInputType | true
    }

  export interface AboutStorySectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutStorySection'], meta: { name: 'AboutStorySection' } }
    /**
     * Find zero or one AboutStorySection that matches the filter.
     * @param {AboutStorySectionFindUniqueArgs} args - Arguments to find a AboutStorySection
     * @example
     * // Get one AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutStorySectionFindUniqueArgs>(args: SelectSubset<T, AboutStorySectionFindUniqueArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutStorySection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutStorySectionFindUniqueOrThrowArgs} args - Arguments to find a AboutStorySection
     * @example
     * // Get one AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutStorySectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutStorySectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutStorySection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionFindFirstArgs} args - Arguments to find a AboutStorySection
     * @example
     * // Get one AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutStorySectionFindFirstArgs>(args?: SelectSubset<T, AboutStorySectionFindFirstArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutStorySection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionFindFirstOrThrowArgs} args - Arguments to find a AboutStorySection
     * @example
     * // Get one AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutStorySectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutStorySectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutStorySections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutStorySections
     * const aboutStorySections = await prisma.aboutStorySection.findMany()
     * 
     * // Get first 10 AboutStorySections
     * const aboutStorySections = await prisma.aboutStorySection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutStorySectionWithIdOnly = await prisma.aboutStorySection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutStorySectionFindManyArgs>(args?: SelectSubset<T, AboutStorySectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutStorySection.
     * @param {AboutStorySectionCreateArgs} args - Arguments to create a AboutStorySection.
     * @example
     * // Create one AboutStorySection
     * const AboutStorySection = await prisma.aboutStorySection.create({
     *   data: {
     *     // ... data to create a AboutStorySection
     *   }
     * })
     * 
     */
    create<T extends AboutStorySectionCreateArgs>(args: SelectSubset<T, AboutStorySectionCreateArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutStorySections.
     * @param {AboutStorySectionCreateManyArgs} args - Arguments to create many AboutStorySections.
     * @example
     * // Create many AboutStorySections
     * const aboutStorySection = await prisma.aboutStorySection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutStorySectionCreateManyArgs>(args?: SelectSubset<T, AboutStorySectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutStorySections and returns the data saved in the database.
     * @param {AboutStorySectionCreateManyAndReturnArgs} args - Arguments to create many AboutStorySections.
     * @example
     * // Create many AboutStorySections
     * const aboutStorySection = await prisma.aboutStorySection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutStorySections and only return the `id`
     * const aboutStorySectionWithIdOnly = await prisma.aboutStorySection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutStorySectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AboutStorySectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutStorySection.
     * @param {AboutStorySectionDeleteArgs} args - Arguments to delete one AboutStorySection.
     * @example
     * // Delete one AboutStorySection
     * const AboutStorySection = await prisma.aboutStorySection.delete({
     *   where: {
     *     // ... filter to delete one AboutStorySection
     *   }
     * })
     * 
     */
    delete<T extends AboutStorySectionDeleteArgs>(args: SelectSubset<T, AboutStorySectionDeleteArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutStorySection.
     * @param {AboutStorySectionUpdateArgs} args - Arguments to update one AboutStorySection.
     * @example
     * // Update one AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutStorySectionUpdateArgs>(args: SelectSubset<T, AboutStorySectionUpdateArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutStorySections.
     * @param {AboutStorySectionDeleteManyArgs} args - Arguments to filter AboutStorySections to delete.
     * @example
     * // Delete a few AboutStorySections
     * const { count } = await prisma.aboutStorySection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutStorySectionDeleteManyArgs>(args?: SelectSubset<T, AboutStorySectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutStorySections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutStorySections
     * const aboutStorySection = await prisma.aboutStorySection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutStorySectionUpdateManyArgs>(args: SelectSubset<T, AboutStorySectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutStorySections and returns the data updated in the database.
     * @param {AboutStorySectionUpdateManyAndReturnArgs} args - Arguments to update many AboutStorySections.
     * @example
     * // Update many AboutStorySections
     * const aboutStorySection = await prisma.aboutStorySection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutStorySections and only return the `id`
     * const aboutStorySectionWithIdOnly = await prisma.aboutStorySection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutStorySectionUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutStorySectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutStorySection.
     * @param {AboutStorySectionUpsertArgs} args - Arguments to update or create a AboutStorySection.
     * @example
     * // Update or create a AboutStorySection
     * const aboutStorySection = await prisma.aboutStorySection.upsert({
     *   create: {
     *     // ... data to create a AboutStorySection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutStorySection we want to update
     *   }
     * })
     */
    upsert<T extends AboutStorySectionUpsertArgs>(args: SelectSubset<T, AboutStorySectionUpsertArgs<ExtArgs>>): Prisma__AboutStorySectionClient<$Result.GetResult<Prisma.$AboutStorySectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutStorySections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionCountArgs} args - Arguments to filter AboutStorySections to count.
     * @example
     * // Count the number of AboutStorySections
     * const count = await prisma.aboutStorySection.count({
     *   where: {
     *     // ... the filter for the AboutStorySections we want to count
     *   }
     * })
    **/
    count<T extends AboutStorySectionCountArgs>(
      args?: Subset<T, AboutStorySectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutStorySectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutStorySection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutStorySectionAggregateArgs>(args: Subset<T, AboutStorySectionAggregateArgs>): Prisma.PrismaPromise<GetAboutStorySectionAggregateType<T>>

    /**
     * Group by AboutStorySection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStorySectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutStorySectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutStorySectionGroupByArgs['orderBy'] }
        : { orderBy?: AboutStorySectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutStorySectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutStorySectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutStorySection model
   */
  readonly fields: AboutStorySectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutStorySection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutStorySectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutStorySection model
   */
  interface AboutStorySectionFieldRefs {
    readonly id: FieldRef<"AboutStorySection", 'String'>
    readonly heading: FieldRef<"AboutStorySection", 'String'>
    readonly title: FieldRef<"AboutStorySection", 'String'>
    readonly titleHighlight: FieldRef<"AboutStorySection", 'String'>
    readonly paragraph1: FieldRef<"AboutStorySection", 'String'>
    readonly paragraph2: FieldRef<"AboutStorySection", 'String'>
    readonly buttonText: FieldRef<"AboutStorySection", 'String'>
    readonly buttonLink: FieldRef<"AboutStorySection", 'String'>
    readonly image: FieldRef<"AboutStorySection", 'String'>
    readonly status: FieldRef<"AboutStorySection", 'ContentStatus'>
    readonly publishedAt: FieldRef<"AboutStorySection", 'DateTime'>
    readonly createdAt: FieldRef<"AboutStorySection", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutStorySection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutStorySection findUnique
   */
  export type AboutStorySectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutStorySection to fetch.
     */
    where: AboutStorySectionWhereUniqueInput
  }

  /**
   * AboutStorySection findUniqueOrThrow
   */
  export type AboutStorySectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutStorySection to fetch.
     */
    where: AboutStorySectionWhereUniqueInput
  }

  /**
   * AboutStorySection findFirst
   */
  export type AboutStorySectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutStorySection to fetch.
     */
    where?: AboutStorySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStorySections to fetch.
     */
    orderBy?: AboutStorySectionOrderByWithRelationInput | AboutStorySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutStorySections.
     */
    cursor?: AboutStorySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStorySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStorySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutStorySections.
     */
    distinct?: AboutStorySectionScalarFieldEnum | AboutStorySectionScalarFieldEnum[]
  }

  /**
   * AboutStorySection findFirstOrThrow
   */
  export type AboutStorySectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutStorySection to fetch.
     */
    where?: AboutStorySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStorySections to fetch.
     */
    orderBy?: AboutStorySectionOrderByWithRelationInput | AboutStorySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutStorySections.
     */
    cursor?: AboutStorySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStorySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStorySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutStorySections.
     */
    distinct?: AboutStorySectionScalarFieldEnum | AboutStorySectionScalarFieldEnum[]
  }

  /**
   * AboutStorySection findMany
   */
  export type AboutStorySectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutStorySections to fetch.
     */
    where?: AboutStorySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStorySections to fetch.
     */
    orderBy?: AboutStorySectionOrderByWithRelationInput | AboutStorySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutStorySections.
     */
    cursor?: AboutStorySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStorySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStorySections.
     */
    skip?: number
    distinct?: AboutStorySectionScalarFieldEnum | AboutStorySectionScalarFieldEnum[]
  }

  /**
   * AboutStorySection create
   */
  export type AboutStorySectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutStorySection.
     */
    data: XOR<AboutStorySectionCreateInput, AboutStorySectionUncheckedCreateInput>
  }

  /**
   * AboutStorySection createMany
   */
  export type AboutStorySectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutStorySections.
     */
    data: AboutStorySectionCreateManyInput | AboutStorySectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutStorySection createManyAndReturn
   */
  export type AboutStorySectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * The data used to create many AboutStorySections.
     */
    data: AboutStorySectionCreateManyInput | AboutStorySectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutStorySection update
   */
  export type AboutStorySectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutStorySection.
     */
    data: XOR<AboutStorySectionUpdateInput, AboutStorySectionUncheckedUpdateInput>
    /**
     * Choose, which AboutStorySection to update.
     */
    where: AboutStorySectionWhereUniqueInput
  }

  /**
   * AboutStorySection updateMany
   */
  export type AboutStorySectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutStorySections.
     */
    data: XOR<AboutStorySectionUpdateManyMutationInput, AboutStorySectionUncheckedUpdateManyInput>
    /**
     * Filter which AboutStorySections to update
     */
    where?: AboutStorySectionWhereInput
    /**
     * Limit how many AboutStorySections to update.
     */
    limit?: number
  }

  /**
   * AboutStorySection updateManyAndReturn
   */
  export type AboutStorySectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * The data used to update AboutStorySections.
     */
    data: XOR<AboutStorySectionUpdateManyMutationInput, AboutStorySectionUncheckedUpdateManyInput>
    /**
     * Filter which AboutStorySections to update
     */
    where?: AboutStorySectionWhereInput
    /**
     * Limit how many AboutStorySections to update.
     */
    limit?: number
  }

  /**
   * AboutStorySection upsert
   */
  export type AboutStorySectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutStorySection to update in case it exists.
     */
    where: AboutStorySectionWhereUniqueInput
    /**
     * In case the AboutStorySection found by the `where` argument doesn't exist, create a new AboutStorySection with this data.
     */
    create: XOR<AboutStorySectionCreateInput, AboutStorySectionUncheckedCreateInput>
    /**
     * In case the AboutStorySection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutStorySectionUpdateInput, AboutStorySectionUncheckedUpdateInput>
  }

  /**
   * AboutStorySection delete
   */
  export type AboutStorySectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
    /**
     * Filter which AboutStorySection to delete.
     */
    where: AboutStorySectionWhereUniqueInput
  }

  /**
   * AboutStorySection deleteMany
   */
  export type AboutStorySectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutStorySections to delete
     */
    where?: AboutStorySectionWhereInput
    /**
     * Limit how many AboutStorySections to delete.
     */
    limit?: number
  }

  /**
   * AboutStorySection without action
   */
  export type AboutStorySectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStorySection
     */
    select?: AboutStorySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStorySection
     */
    omit?: AboutStorySectionOmit<ExtArgs> | null
  }


  /**
   * Model AboutCommunitySection
   */

  export type AggregateAboutCommunitySection = {
    _count: AboutCommunitySectionCountAggregateOutputType | null
    _min: AboutCommunitySectionMinAggregateOutputType | null
    _max: AboutCommunitySectionMaxAggregateOutputType | null
  }

  export type AboutCommunitySectionMinAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    titleHighlight: string | null
    paragraph1: string | null
    paragraph2: string | null
    buttonText: string | null
    buttonLink: string | null
    feature1Title: string | null
    feature1Description: string | null
    feature2Title: string | null
    feature2Description: string | null
    feature3Title: string | null
    feature3Description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutCommunitySectionMaxAggregateOutputType = {
    id: string | null
    heading: string | null
    title: string | null
    titleHighlight: string | null
    paragraph1: string | null
    paragraph2: string | null
    buttonText: string | null
    buttonLink: string | null
    feature1Title: string | null
    feature1Description: string | null
    feature2Title: string | null
    feature2Description: string | null
    feature3Title: string | null
    feature3Description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutCommunitySectionCountAggregateOutputType = {
    id: number
    heading: number
    title: number
    titleHighlight: number
    paragraph1: number
    paragraph2: number
    buttonText: number
    buttonLink: number
    feature1Title: number
    feature1Description: number
    feature2Title: number
    feature2Description: number
    feature3Title: number
    feature3Description: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutCommunitySectionMinAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    feature1Title?: true
    feature1Description?: true
    feature2Title?: true
    feature2Description?: true
    feature3Title?: true
    feature3Description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutCommunitySectionMaxAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    feature1Title?: true
    feature1Description?: true
    feature2Title?: true
    feature2Description?: true
    feature3Title?: true
    feature3Description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutCommunitySectionCountAggregateInputType = {
    id?: true
    heading?: true
    title?: true
    titleHighlight?: true
    paragraph1?: true
    paragraph2?: true
    buttonText?: true
    buttonLink?: true
    feature1Title?: true
    feature1Description?: true
    feature2Title?: true
    feature2Description?: true
    feature3Title?: true
    feature3Description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutCommunitySectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutCommunitySection to aggregate.
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCommunitySections to fetch.
     */
    orderBy?: AboutCommunitySectionOrderByWithRelationInput | AboutCommunitySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutCommunitySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCommunitySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCommunitySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutCommunitySections
    **/
    _count?: true | AboutCommunitySectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutCommunitySectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutCommunitySectionMaxAggregateInputType
  }

  export type GetAboutCommunitySectionAggregateType<T extends AboutCommunitySectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutCommunitySection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutCommunitySection[P]>
      : GetScalarType<T[P], AggregateAboutCommunitySection[P]>
  }




  export type AboutCommunitySectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutCommunitySectionWhereInput
    orderBy?: AboutCommunitySectionOrderByWithAggregationInput | AboutCommunitySectionOrderByWithAggregationInput[]
    by: AboutCommunitySectionScalarFieldEnum[] | AboutCommunitySectionScalarFieldEnum
    having?: AboutCommunitySectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutCommunitySectionCountAggregateInputType | true
    _min?: AboutCommunitySectionMinAggregateInputType
    _max?: AboutCommunitySectionMaxAggregateInputType
  }

  export type AboutCommunitySectionGroupByOutputType = {
    id: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    feature1Title: string
    feature1Description: string
    feature2Title: string
    feature2Description: string
    feature3Title: string
    feature3Description: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AboutCommunitySectionCountAggregateOutputType | null
    _min: AboutCommunitySectionMinAggregateOutputType | null
    _max: AboutCommunitySectionMaxAggregateOutputType | null
  }

  type GetAboutCommunitySectionGroupByPayload<T extends AboutCommunitySectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutCommunitySectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutCommunitySectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutCommunitySectionGroupByOutputType[P]>
            : GetScalarType<T[P], AboutCommunitySectionGroupByOutputType[P]>
        }
      >
    >


  export type AboutCommunitySectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    feature1Title?: boolean
    feature1Description?: boolean
    feature2Title?: boolean
    feature2Description?: boolean
    feature3Title?: boolean
    feature3Description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCommunitySection"]>

  export type AboutCommunitySectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    feature1Title?: boolean
    feature1Description?: boolean
    feature2Title?: boolean
    feature2Description?: boolean
    feature3Title?: boolean
    feature3Description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCommunitySection"]>

  export type AboutCommunitySectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    feature1Title?: boolean
    feature1Description?: boolean
    feature2Title?: boolean
    feature2Description?: boolean
    feature3Title?: boolean
    feature3Description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCommunitySection"]>

  export type AboutCommunitySectionSelectScalar = {
    id?: boolean
    heading?: boolean
    title?: boolean
    titleHighlight?: boolean
    paragraph1?: boolean
    paragraph2?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    feature1Title?: boolean
    feature1Description?: boolean
    feature2Title?: boolean
    feature2Description?: boolean
    feature3Title?: boolean
    feature3Description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutCommunitySectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heading" | "title" | "titleHighlight" | "paragraph1" | "paragraph2" | "buttonText" | "buttonLink" | "feature1Title" | "feature1Description" | "feature2Title" | "feature2Description" | "feature3Title" | "feature3Description" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutCommunitySection"]>

  export type $AboutCommunitySectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutCommunitySection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      heading: string
      title: string
      titleHighlight: string
      paragraph1: string
      paragraph2: string
      buttonText: string
      buttonLink: string
      feature1Title: string
      feature1Description: string
      feature2Title: string
      feature2Description: string
      feature3Title: string
      feature3Description: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutCommunitySection"]>
    composites: {}
  }

  type AboutCommunitySectionGetPayload<S extends boolean | null | undefined | AboutCommunitySectionDefaultArgs> = $Result.GetResult<Prisma.$AboutCommunitySectionPayload, S>

  type AboutCommunitySectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutCommunitySectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutCommunitySectionCountAggregateInputType | true
    }

  export interface AboutCommunitySectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutCommunitySection'], meta: { name: 'AboutCommunitySection' } }
    /**
     * Find zero or one AboutCommunitySection that matches the filter.
     * @param {AboutCommunitySectionFindUniqueArgs} args - Arguments to find a AboutCommunitySection
     * @example
     * // Get one AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutCommunitySectionFindUniqueArgs>(args: SelectSubset<T, AboutCommunitySectionFindUniqueArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutCommunitySection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutCommunitySectionFindUniqueOrThrowArgs} args - Arguments to find a AboutCommunitySection
     * @example
     * // Get one AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutCommunitySectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutCommunitySectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutCommunitySection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionFindFirstArgs} args - Arguments to find a AboutCommunitySection
     * @example
     * // Get one AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutCommunitySectionFindFirstArgs>(args?: SelectSubset<T, AboutCommunitySectionFindFirstArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutCommunitySection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionFindFirstOrThrowArgs} args - Arguments to find a AboutCommunitySection
     * @example
     * // Get one AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutCommunitySectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutCommunitySectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutCommunitySections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutCommunitySections
     * const aboutCommunitySections = await prisma.aboutCommunitySection.findMany()
     * 
     * // Get first 10 AboutCommunitySections
     * const aboutCommunitySections = await prisma.aboutCommunitySection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutCommunitySectionWithIdOnly = await prisma.aboutCommunitySection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutCommunitySectionFindManyArgs>(args?: SelectSubset<T, AboutCommunitySectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutCommunitySection.
     * @param {AboutCommunitySectionCreateArgs} args - Arguments to create a AboutCommunitySection.
     * @example
     * // Create one AboutCommunitySection
     * const AboutCommunitySection = await prisma.aboutCommunitySection.create({
     *   data: {
     *     // ... data to create a AboutCommunitySection
     *   }
     * })
     * 
     */
    create<T extends AboutCommunitySectionCreateArgs>(args: SelectSubset<T, AboutCommunitySectionCreateArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutCommunitySections.
     * @param {AboutCommunitySectionCreateManyArgs} args - Arguments to create many AboutCommunitySections.
     * @example
     * // Create many AboutCommunitySections
     * const aboutCommunitySection = await prisma.aboutCommunitySection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutCommunitySectionCreateManyArgs>(args?: SelectSubset<T, AboutCommunitySectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutCommunitySections and returns the data saved in the database.
     * @param {AboutCommunitySectionCreateManyAndReturnArgs} args - Arguments to create many AboutCommunitySections.
     * @example
     * // Create many AboutCommunitySections
     * const aboutCommunitySection = await prisma.aboutCommunitySection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutCommunitySections and only return the `id`
     * const aboutCommunitySectionWithIdOnly = await prisma.aboutCommunitySection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutCommunitySectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AboutCommunitySectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutCommunitySection.
     * @param {AboutCommunitySectionDeleteArgs} args - Arguments to delete one AboutCommunitySection.
     * @example
     * // Delete one AboutCommunitySection
     * const AboutCommunitySection = await prisma.aboutCommunitySection.delete({
     *   where: {
     *     // ... filter to delete one AboutCommunitySection
     *   }
     * })
     * 
     */
    delete<T extends AboutCommunitySectionDeleteArgs>(args: SelectSubset<T, AboutCommunitySectionDeleteArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutCommunitySection.
     * @param {AboutCommunitySectionUpdateArgs} args - Arguments to update one AboutCommunitySection.
     * @example
     * // Update one AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutCommunitySectionUpdateArgs>(args: SelectSubset<T, AboutCommunitySectionUpdateArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutCommunitySections.
     * @param {AboutCommunitySectionDeleteManyArgs} args - Arguments to filter AboutCommunitySections to delete.
     * @example
     * // Delete a few AboutCommunitySections
     * const { count } = await prisma.aboutCommunitySection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutCommunitySectionDeleteManyArgs>(args?: SelectSubset<T, AboutCommunitySectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutCommunitySections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutCommunitySections
     * const aboutCommunitySection = await prisma.aboutCommunitySection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutCommunitySectionUpdateManyArgs>(args: SelectSubset<T, AboutCommunitySectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutCommunitySections and returns the data updated in the database.
     * @param {AboutCommunitySectionUpdateManyAndReturnArgs} args - Arguments to update many AboutCommunitySections.
     * @example
     * // Update many AboutCommunitySections
     * const aboutCommunitySection = await prisma.aboutCommunitySection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutCommunitySections and only return the `id`
     * const aboutCommunitySectionWithIdOnly = await prisma.aboutCommunitySection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutCommunitySectionUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutCommunitySectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutCommunitySection.
     * @param {AboutCommunitySectionUpsertArgs} args - Arguments to update or create a AboutCommunitySection.
     * @example
     * // Update or create a AboutCommunitySection
     * const aboutCommunitySection = await prisma.aboutCommunitySection.upsert({
     *   create: {
     *     // ... data to create a AboutCommunitySection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutCommunitySection we want to update
     *   }
     * })
     */
    upsert<T extends AboutCommunitySectionUpsertArgs>(args: SelectSubset<T, AboutCommunitySectionUpsertArgs<ExtArgs>>): Prisma__AboutCommunitySectionClient<$Result.GetResult<Prisma.$AboutCommunitySectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutCommunitySections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionCountArgs} args - Arguments to filter AboutCommunitySections to count.
     * @example
     * // Count the number of AboutCommunitySections
     * const count = await prisma.aboutCommunitySection.count({
     *   where: {
     *     // ... the filter for the AboutCommunitySections we want to count
     *   }
     * })
    **/
    count<T extends AboutCommunitySectionCountArgs>(
      args?: Subset<T, AboutCommunitySectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutCommunitySectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutCommunitySection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutCommunitySectionAggregateArgs>(args: Subset<T, AboutCommunitySectionAggregateArgs>): Prisma.PrismaPromise<GetAboutCommunitySectionAggregateType<T>>

    /**
     * Group by AboutCommunitySection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCommunitySectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutCommunitySectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutCommunitySectionGroupByArgs['orderBy'] }
        : { orderBy?: AboutCommunitySectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutCommunitySectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutCommunitySectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutCommunitySection model
   */
  readonly fields: AboutCommunitySectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutCommunitySection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutCommunitySectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutCommunitySection model
   */
  interface AboutCommunitySectionFieldRefs {
    readonly id: FieldRef<"AboutCommunitySection", 'String'>
    readonly heading: FieldRef<"AboutCommunitySection", 'String'>
    readonly title: FieldRef<"AboutCommunitySection", 'String'>
    readonly titleHighlight: FieldRef<"AboutCommunitySection", 'String'>
    readonly paragraph1: FieldRef<"AboutCommunitySection", 'String'>
    readonly paragraph2: FieldRef<"AboutCommunitySection", 'String'>
    readonly buttonText: FieldRef<"AboutCommunitySection", 'String'>
    readonly buttonLink: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature1Title: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature1Description: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature2Title: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature2Description: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature3Title: FieldRef<"AboutCommunitySection", 'String'>
    readonly feature3Description: FieldRef<"AboutCommunitySection", 'String'>
    readonly status: FieldRef<"AboutCommunitySection", 'ContentStatus'>
    readonly publishedAt: FieldRef<"AboutCommunitySection", 'DateTime'>
    readonly createdAt: FieldRef<"AboutCommunitySection", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutCommunitySection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutCommunitySection findUnique
   */
  export type AboutCommunitySectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutCommunitySection to fetch.
     */
    where: AboutCommunitySectionWhereUniqueInput
  }

  /**
   * AboutCommunitySection findUniqueOrThrow
   */
  export type AboutCommunitySectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutCommunitySection to fetch.
     */
    where: AboutCommunitySectionWhereUniqueInput
  }

  /**
   * AboutCommunitySection findFirst
   */
  export type AboutCommunitySectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutCommunitySection to fetch.
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCommunitySections to fetch.
     */
    orderBy?: AboutCommunitySectionOrderByWithRelationInput | AboutCommunitySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutCommunitySections.
     */
    cursor?: AboutCommunitySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCommunitySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCommunitySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutCommunitySections.
     */
    distinct?: AboutCommunitySectionScalarFieldEnum | AboutCommunitySectionScalarFieldEnum[]
  }

  /**
   * AboutCommunitySection findFirstOrThrow
   */
  export type AboutCommunitySectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutCommunitySection to fetch.
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCommunitySections to fetch.
     */
    orderBy?: AboutCommunitySectionOrderByWithRelationInput | AboutCommunitySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutCommunitySections.
     */
    cursor?: AboutCommunitySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCommunitySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCommunitySections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutCommunitySections.
     */
    distinct?: AboutCommunitySectionScalarFieldEnum | AboutCommunitySectionScalarFieldEnum[]
  }

  /**
   * AboutCommunitySection findMany
   */
  export type AboutCommunitySectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter, which AboutCommunitySections to fetch.
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCommunitySections to fetch.
     */
    orderBy?: AboutCommunitySectionOrderByWithRelationInput | AboutCommunitySectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutCommunitySections.
     */
    cursor?: AboutCommunitySectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCommunitySections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCommunitySections.
     */
    skip?: number
    distinct?: AboutCommunitySectionScalarFieldEnum | AboutCommunitySectionScalarFieldEnum[]
  }

  /**
   * AboutCommunitySection create
   */
  export type AboutCommunitySectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutCommunitySection.
     */
    data: XOR<AboutCommunitySectionCreateInput, AboutCommunitySectionUncheckedCreateInput>
  }

  /**
   * AboutCommunitySection createMany
   */
  export type AboutCommunitySectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutCommunitySections.
     */
    data: AboutCommunitySectionCreateManyInput | AboutCommunitySectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutCommunitySection createManyAndReturn
   */
  export type AboutCommunitySectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * The data used to create many AboutCommunitySections.
     */
    data: AboutCommunitySectionCreateManyInput | AboutCommunitySectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutCommunitySection update
   */
  export type AboutCommunitySectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutCommunitySection.
     */
    data: XOR<AboutCommunitySectionUpdateInput, AboutCommunitySectionUncheckedUpdateInput>
    /**
     * Choose, which AboutCommunitySection to update.
     */
    where: AboutCommunitySectionWhereUniqueInput
  }

  /**
   * AboutCommunitySection updateMany
   */
  export type AboutCommunitySectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutCommunitySections.
     */
    data: XOR<AboutCommunitySectionUpdateManyMutationInput, AboutCommunitySectionUncheckedUpdateManyInput>
    /**
     * Filter which AboutCommunitySections to update
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * Limit how many AboutCommunitySections to update.
     */
    limit?: number
  }

  /**
   * AboutCommunitySection updateManyAndReturn
   */
  export type AboutCommunitySectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * The data used to update AboutCommunitySections.
     */
    data: XOR<AboutCommunitySectionUpdateManyMutationInput, AboutCommunitySectionUncheckedUpdateManyInput>
    /**
     * Filter which AboutCommunitySections to update
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * Limit how many AboutCommunitySections to update.
     */
    limit?: number
  }

  /**
   * AboutCommunitySection upsert
   */
  export type AboutCommunitySectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutCommunitySection to update in case it exists.
     */
    where: AboutCommunitySectionWhereUniqueInput
    /**
     * In case the AboutCommunitySection found by the `where` argument doesn't exist, create a new AboutCommunitySection with this data.
     */
    create: XOR<AboutCommunitySectionCreateInput, AboutCommunitySectionUncheckedCreateInput>
    /**
     * In case the AboutCommunitySection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutCommunitySectionUpdateInput, AboutCommunitySectionUncheckedUpdateInput>
  }

  /**
   * AboutCommunitySection delete
   */
  export type AboutCommunitySectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
    /**
     * Filter which AboutCommunitySection to delete.
     */
    where: AboutCommunitySectionWhereUniqueInput
  }

  /**
   * AboutCommunitySection deleteMany
   */
  export type AboutCommunitySectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutCommunitySections to delete
     */
    where?: AboutCommunitySectionWhereInput
    /**
     * Limit how many AboutCommunitySections to delete.
     */
    limit?: number
  }

  /**
   * AboutCommunitySection without action
   */
  export type AboutCommunitySectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCommunitySection
     */
    select?: AboutCommunitySectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCommunitySection
     */
    omit?: AboutCommunitySectionOmit<ExtArgs> | null
  }


  /**
   * Model AboutStats
   */

  export type AggregateAboutStats = {
    _count: AboutStatsCountAggregateOutputType | null
    _min: AboutStatsMinAggregateOutputType | null
    _max: AboutStatsMaxAggregateOutputType | null
  }

  export type AboutStatsMinAggregateOutputType = {
    id: string | null
    stat1Number: string | null
    stat1Label: string | null
    stat2Number: string | null
    stat2Label: string | null
    stat3Number: string | null
    stat3Label: string | null
    stat4Number: string | null
    stat4Label: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutStatsMaxAggregateOutputType = {
    id: string | null
    stat1Number: string | null
    stat1Label: string | null
    stat2Number: string | null
    stat2Label: string | null
    stat3Number: string | null
    stat3Label: string | null
    stat4Number: string | null
    stat4Label: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutStatsCountAggregateOutputType = {
    id: number
    stat1Number: number
    stat1Label: number
    stat2Number: number
    stat2Label: number
    stat3Number: number
    stat3Label: number
    stat4Number: number
    stat4Label: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutStatsMinAggregateInputType = {
    id?: true
    stat1Number?: true
    stat1Label?: true
    stat2Number?: true
    stat2Label?: true
    stat3Number?: true
    stat3Label?: true
    stat4Number?: true
    stat4Label?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutStatsMaxAggregateInputType = {
    id?: true
    stat1Number?: true
    stat1Label?: true
    stat2Number?: true
    stat2Label?: true
    stat3Number?: true
    stat3Label?: true
    stat4Number?: true
    stat4Label?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutStatsCountAggregateInputType = {
    id?: true
    stat1Number?: true
    stat1Label?: true
    stat2Number?: true
    stat2Label?: true
    stat3Number?: true
    stat3Label?: true
    stat4Number?: true
    stat4Label?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutStats to aggregate.
     */
    where?: AboutStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStats to fetch.
     */
    orderBy?: AboutStatsOrderByWithRelationInput | AboutStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutStats
    **/
    _count?: true | AboutStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutStatsMaxAggregateInputType
  }

  export type GetAboutStatsAggregateType<T extends AboutStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutStats[P]>
      : GetScalarType<T[P], AggregateAboutStats[P]>
  }




  export type AboutStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutStatsWhereInput
    orderBy?: AboutStatsOrderByWithAggregationInput | AboutStatsOrderByWithAggregationInput[]
    by: AboutStatsScalarFieldEnum[] | AboutStatsScalarFieldEnum
    having?: AboutStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutStatsCountAggregateInputType | true
    _min?: AboutStatsMinAggregateInputType
    _max?: AboutStatsMaxAggregateInputType
  }

  export type AboutStatsGroupByOutputType = {
    id: string
    stat1Number: string
    stat1Label: string
    stat2Number: string
    stat2Label: string
    stat3Number: string
    stat3Label: string
    stat4Number: string
    stat4Label: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AboutStatsCountAggregateOutputType | null
    _min: AboutStatsMinAggregateOutputType | null
    _max: AboutStatsMaxAggregateOutputType | null
  }

  type GetAboutStatsGroupByPayload<T extends AboutStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutStatsGroupByOutputType[P]>
            : GetScalarType<T[P], AboutStatsGroupByOutputType[P]>
        }
      >
    >


  export type AboutStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stat1Number?: boolean
    stat1Label?: boolean
    stat2Number?: boolean
    stat2Label?: boolean
    stat3Number?: boolean
    stat3Label?: boolean
    stat4Number?: boolean
    stat4Label?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStats"]>

  export type AboutStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stat1Number?: boolean
    stat1Label?: boolean
    stat2Number?: boolean
    stat2Label?: boolean
    stat3Number?: boolean
    stat3Label?: boolean
    stat4Number?: boolean
    stat4Label?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStats"]>

  export type AboutStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stat1Number?: boolean
    stat1Label?: boolean
    stat2Number?: boolean
    stat2Label?: boolean
    stat3Number?: boolean
    stat3Label?: boolean
    stat4Number?: boolean
    stat4Label?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutStats"]>

  export type AboutStatsSelectScalar = {
    id?: boolean
    stat1Number?: boolean
    stat1Label?: boolean
    stat2Number?: boolean
    stat2Label?: boolean
    stat3Number?: boolean
    stat3Label?: boolean
    stat4Number?: boolean
    stat4Label?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stat1Number" | "stat1Label" | "stat2Number" | "stat2Label" | "stat3Number" | "stat3Label" | "stat4Number" | "stat4Label" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutStats"]>

  export type $AboutStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stat1Number: string
      stat1Label: string
      stat2Number: string
      stat2Label: string
      stat3Number: string
      stat3Label: string
      stat4Number: string
      stat4Label: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutStats"]>
    composites: {}
  }

  type AboutStatsGetPayload<S extends boolean | null | undefined | AboutStatsDefaultArgs> = $Result.GetResult<Prisma.$AboutStatsPayload, S>

  type AboutStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutStatsCountAggregateInputType | true
    }

  export interface AboutStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutStats'], meta: { name: 'AboutStats' } }
    /**
     * Find zero or one AboutStats that matches the filter.
     * @param {AboutStatsFindUniqueArgs} args - Arguments to find a AboutStats
     * @example
     * // Get one AboutStats
     * const aboutStats = await prisma.aboutStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutStatsFindUniqueArgs>(args: SelectSubset<T, AboutStatsFindUniqueArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutStatsFindUniqueOrThrowArgs} args - Arguments to find a AboutStats
     * @example
     * // Get one AboutStats
     * const aboutStats = await prisma.aboutStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsFindFirstArgs} args - Arguments to find a AboutStats
     * @example
     * // Get one AboutStats
     * const aboutStats = await prisma.aboutStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutStatsFindFirstArgs>(args?: SelectSubset<T, AboutStatsFindFirstArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsFindFirstOrThrowArgs} args - Arguments to find a AboutStats
     * @example
     * // Get one AboutStats
     * const aboutStats = await prisma.aboutStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutStats
     * const aboutStats = await prisma.aboutStats.findMany()
     * 
     * // Get first 10 AboutStats
     * const aboutStats = await prisma.aboutStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutStatsWithIdOnly = await prisma.aboutStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutStatsFindManyArgs>(args?: SelectSubset<T, AboutStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutStats.
     * @param {AboutStatsCreateArgs} args - Arguments to create a AboutStats.
     * @example
     * // Create one AboutStats
     * const AboutStats = await prisma.aboutStats.create({
     *   data: {
     *     // ... data to create a AboutStats
     *   }
     * })
     * 
     */
    create<T extends AboutStatsCreateArgs>(args: SelectSubset<T, AboutStatsCreateArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutStats.
     * @param {AboutStatsCreateManyArgs} args - Arguments to create many AboutStats.
     * @example
     * // Create many AboutStats
     * const aboutStats = await prisma.aboutStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutStatsCreateManyArgs>(args?: SelectSubset<T, AboutStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutStats and returns the data saved in the database.
     * @param {AboutStatsCreateManyAndReturnArgs} args - Arguments to create many AboutStats.
     * @example
     * // Create many AboutStats
     * const aboutStats = await prisma.aboutStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutStats and only return the `id`
     * const aboutStatsWithIdOnly = await prisma.aboutStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, AboutStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutStats.
     * @param {AboutStatsDeleteArgs} args - Arguments to delete one AboutStats.
     * @example
     * // Delete one AboutStats
     * const AboutStats = await prisma.aboutStats.delete({
     *   where: {
     *     // ... filter to delete one AboutStats
     *   }
     * })
     * 
     */
    delete<T extends AboutStatsDeleteArgs>(args: SelectSubset<T, AboutStatsDeleteArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutStats.
     * @param {AboutStatsUpdateArgs} args - Arguments to update one AboutStats.
     * @example
     * // Update one AboutStats
     * const aboutStats = await prisma.aboutStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutStatsUpdateArgs>(args: SelectSubset<T, AboutStatsUpdateArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutStats.
     * @param {AboutStatsDeleteManyArgs} args - Arguments to filter AboutStats to delete.
     * @example
     * // Delete a few AboutStats
     * const { count } = await prisma.aboutStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutStatsDeleteManyArgs>(args?: SelectSubset<T, AboutStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutStats
     * const aboutStats = await prisma.aboutStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutStatsUpdateManyArgs>(args: SelectSubset<T, AboutStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutStats and returns the data updated in the database.
     * @param {AboutStatsUpdateManyAndReturnArgs} args - Arguments to update many AboutStats.
     * @example
     * // Update many AboutStats
     * const aboutStats = await prisma.aboutStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutStats and only return the `id`
     * const aboutStatsWithIdOnly = await prisma.aboutStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutStats.
     * @param {AboutStatsUpsertArgs} args - Arguments to update or create a AboutStats.
     * @example
     * // Update or create a AboutStats
     * const aboutStats = await prisma.aboutStats.upsert({
     *   create: {
     *     // ... data to create a AboutStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutStats we want to update
     *   }
     * })
     */
    upsert<T extends AboutStatsUpsertArgs>(args: SelectSubset<T, AboutStatsUpsertArgs<ExtArgs>>): Prisma__AboutStatsClient<$Result.GetResult<Prisma.$AboutStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsCountArgs} args - Arguments to filter AboutStats to count.
     * @example
     * // Count the number of AboutStats
     * const count = await prisma.aboutStats.count({
     *   where: {
     *     // ... the filter for the AboutStats we want to count
     *   }
     * })
    **/
    count<T extends AboutStatsCountArgs>(
      args?: Subset<T, AboutStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutStatsAggregateArgs>(args: Subset<T, AboutStatsAggregateArgs>): Prisma.PrismaPromise<GetAboutStatsAggregateType<T>>

    /**
     * Group by AboutStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutStatsGroupByArgs['orderBy'] }
        : { orderBy?: AboutStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutStats model
   */
  readonly fields: AboutStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutStats model
   */
  interface AboutStatsFieldRefs {
    readonly id: FieldRef<"AboutStats", 'String'>
    readonly stat1Number: FieldRef<"AboutStats", 'String'>
    readonly stat1Label: FieldRef<"AboutStats", 'String'>
    readonly stat2Number: FieldRef<"AboutStats", 'String'>
    readonly stat2Label: FieldRef<"AboutStats", 'String'>
    readonly stat3Number: FieldRef<"AboutStats", 'String'>
    readonly stat3Label: FieldRef<"AboutStats", 'String'>
    readonly stat4Number: FieldRef<"AboutStats", 'String'>
    readonly stat4Label: FieldRef<"AboutStats", 'String'>
    readonly status: FieldRef<"AboutStats", 'ContentStatus'>
    readonly publishedAt: FieldRef<"AboutStats", 'DateTime'>
    readonly createdAt: FieldRef<"AboutStats", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutStats findUnique
   */
  export type AboutStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter, which AboutStats to fetch.
     */
    where: AboutStatsWhereUniqueInput
  }

  /**
   * AboutStats findUniqueOrThrow
   */
  export type AboutStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter, which AboutStats to fetch.
     */
    where: AboutStatsWhereUniqueInput
  }

  /**
   * AboutStats findFirst
   */
  export type AboutStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter, which AboutStats to fetch.
     */
    where?: AboutStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStats to fetch.
     */
    orderBy?: AboutStatsOrderByWithRelationInput | AboutStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutStats.
     */
    cursor?: AboutStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutStats.
     */
    distinct?: AboutStatsScalarFieldEnum | AboutStatsScalarFieldEnum[]
  }

  /**
   * AboutStats findFirstOrThrow
   */
  export type AboutStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter, which AboutStats to fetch.
     */
    where?: AboutStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStats to fetch.
     */
    orderBy?: AboutStatsOrderByWithRelationInput | AboutStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutStats.
     */
    cursor?: AboutStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutStats.
     */
    distinct?: AboutStatsScalarFieldEnum | AboutStatsScalarFieldEnum[]
  }

  /**
   * AboutStats findMany
   */
  export type AboutStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter, which AboutStats to fetch.
     */
    where?: AboutStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutStats to fetch.
     */
    orderBy?: AboutStatsOrderByWithRelationInput | AboutStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutStats.
     */
    cursor?: AboutStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutStats.
     */
    skip?: number
    distinct?: AboutStatsScalarFieldEnum | AboutStatsScalarFieldEnum[]
  }

  /**
   * AboutStats create
   */
  export type AboutStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutStats.
     */
    data: XOR<AboutStatsCreateInput, AboutStatsUncheckedCreateInput>
  }

  /**
   * AboutStats createMany
   */
  export type AboutStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutStats.
     */
    data: AboutStatsCreateManyInput | AboutStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutStats createManyAndReturn
   */
  export type AboutStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * The data used to create many AboutStats.
     */
    data: AboutStatsCreateManyInput | AboutStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutStats update
   */
  export type AboutStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutStats.
     */
    data: XOR<AboutStatsUpdateInput, AboutStatsUncheckedUpdateInput>
    /**
     * Choose, which AboutStats to update.
     */
    where: AboutStatsWhereUniqueInput
  }

  /**
   * AboutStats updateMany
   */
  export type AboutStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutStats.
     */
    data: XOR<AboutStatsUpdateManyMutationInput, AboutStatsUncheckedUpdateManyInput>
    /**
     * Filter which AboutStats to update
     */
    where?: AboutStatsWhereInput
    /**
     * Limit how many AboutStats to update.
     */
    limit?: number
  }

  /**
   * AboutStats updateManyAndReturn
   */
  export type AboutStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * The data used to update AboutStats.
     */
    data: XOR<AboutStatsUpdateManyMutationInput, AboutStatsUncheckedUpdateManyInput>
    /**
     * Filter which AboutStats to update
     */
    where?: AboutStatsWhereInput
    /**
     * Limit how many AboutStats to update.
     */
    limit?: number
  }

  /**
   * AboutStats upsert
   */
  export type AboutStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutStats to update in case it exists.
     */
    where: AboutStatsWhereUniqueInput
    /**
     * In case the AboutStats found by the `where` argument doesn't exist, create a new AboutStats with this data.
     */
    create: XOR<AboutStatsCreateInput, AboutStatsUncheckedCreateInput>
    /**
     * In case the AboutStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutStatsUpdateInput, AboutStatsUncheckedUpdateInput>
  }

  /**
   * AboutStats delete
   */
  export type AboutStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
    /**
     * Filter which AboutStats to delete.
     */
    where: AboutStatsWhereUniqueInput
  }

  /**
   * AboutStats deleteMany
   */
  export type AboutStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutStats to delete
     */
    where?: AboutStatsWhereInput
    /**
     * Limit how many AboutStats to delete.
     */
    limit?: number
  }

  /**
   * AboutStats without action
   */
  export type AboutStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutStats
     */
    select?: AboutStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutStats
     */
    omit?: AboutStatsOmit<ExtArgs> | null
  }


  /**
   * Model AboutValue
   */

  export type AggregateAboutValue = {
    _count: AboutValueCountAggregateOutputType | null
    _avg: AboutValueAvgAggregateOutputType | null
    _sum: AboutValueSumAggregateOutputType | null
    _min: AboutValueMinAggregateOutputType | null
    _max: AboutValueMaxAggregateOutputType | null
  }

  export type AboutValueAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type AboutValueSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type AboutValueMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutValueMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutValueCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    displayOrder: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutValueAvgAggregateInputType = {
    displayOrder?: true
  }

  export type AboutValueSumAggregateInputType = {
    displayOrder?: true
  }

  export type AboutValueMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutValueMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutValueCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutValue to aggregate.
     */
    where?: AboutValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutValues to fetch.
     */
    orderBy?: AboutValueOrderByWithRelationInput | AboutValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutValues
    **/
    _count?: true | AboutValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AboutValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AboutValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutValueMaxAggregateInputType
  }

  export type GetAboutValueAggregateType<T extends AboutValueAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutValue[P]>
      : GetScalarType<T[P], AggregateAboutValue[P]>
  }




  export type AboutValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutValueWhereInput
    orderBy?: AboutValueOrderByWithAggregationInput | AboutValueOrderByWithAggregationInput[]
    by: AboutValueScalarFieldEnum[] | AboutValueScalarFieldEnum
    having?: AboutValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutValueCountAggregateInputType | true
    _avg?: AboutValueAvgAggregateInputType
    _sum?: AboutValueSumAggregateInputType
    _min?: AboutValueMinAggregateInputType
    _max?: AboutValueMaxAggregateInputType
  }

  export type AboutValueGroupByOutputType = {
    id: string
    title: string
    description: string
    icon: string
    displayOrder: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: AboutValueCountAggregateOutputType | null
    _avg: AboutValueAvgAggregateOutputType | null
    _sum: AboutValueSumAggregateOutputType | null
    _min: AboutValueMinAggregateOutputType | null
    _max: AboutValueMaxAggregateOutputType | null
  }

  type GetAboutValueGroupByPayload<T extends AboutValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutValueGroupByOutputType[P]>
            : GetScalarType<T[P], AboutValueGroupByOutputType[P]>
        }
      >
    >


  export type AboutValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutValue"]>

  export type AboutValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutValue"]>

  export type AboutValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutValue"]>

  export type AboutValueSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "icon" | "displayOrder" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutValue"]>

  export type $AboutValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutValue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      icon: string
      displayOrder: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutValue"]>
    composites: {}
  }

  type AboutValueGetPayload<S extends boolean | null | undefined | AboutValueDefaultArgs> = $Result.GetResult<Prisma.$AboutValuePayload, S>

  type AboutValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutValueCountAggregateInputType | true
    }

  export interface AboutValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutValue'], meta: { name: 'AboutValue' } }
    /**
     * Find zero or one AboutValue that matches the filter.
     * @param {AboutValueFindUniqueArgs} args - Arguments to find a AboutValue
     * @example
     * // Get one AboutValue
     * const aboutValue = await prisma.aboutValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutValueFindUniqueArgs>(args: SelectSubset<T, AboutValueFindUniqueArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutValueFindUniqueOrThrowArgs} args - Arguments to find a AboutValue
     * @example
     * // Get one AboutValue
     * const aboutValue = await prisma.aboutValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutValueFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueFindFirstArgs} args - Arguments to find a AboutValue
     * @example
     * // Get one AboutValue
     * const aboutValue = await prisma.aboutValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutValueFindFirstArgs>(args?: SelectSubset<T, AboutValueFindFirstArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueFindFirstOrThrowArgs} args - Arguments to find a AboutValue
     * @example
     * // Get one AboutValue
     * const aboutValue = await prisma.aboutValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutValueFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutValues
     * const aboutValues = await prisma.aboutValue.findMany()
     * 
     * // Get first 10 AboutValues
     * const aboutValues = await prisma.aboutValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutValueWithIdOnly = await prisma.aboutValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutValueFindManyArgs>(args?: SelectSubset<T, AboutValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutValue.
     * @param {AboutValueCreateArgs} args - Arguments to create a AboutValue.
     * @example
     * // Create one AboutValue
     * const AboutValue = await prisma.aboutValue.create({
     *   data: {
     *     // ... data to create a AboutValue
     *   }
     * })
     * 
     */
    create<T extends AboutValueCreateArgs>(args: SelectSubset<T, AboutValueCreateArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutValues.
     * @param {AboutValueCreateManyArgs} args - Arguments to create many AboutValues.
     * @example
     * // Create many AboutValues
     * const aboutValue = await prisma.aboutValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutValueCreateManyArgs>(args?: SelectSubset<T, AboutValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutValues and returns the data saved in the database.
     * @param {AboutValueCreateManyAndReturnArgs} args - Arguments to create many AboutValues.
     * @example
     * // Create many AboutValues
     * const aboutValue = await prisma.aboutValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutValues and only return the `id`
     * const aboutValueWithIdOnly = await prisma.aboutValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutValueCreateManyAndReturnArgs>(args?: SelectSubset<T, AboutValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutValue.
     * @param {AboutValueDeleteArgs} args - Arguments to delete one AboutValue.
     * @example
     * // Delete one AboutValue
     * const AboutValue = await prisma.aboutValue.delete({
     *   where: {
     *     // ... filter to delete one AboutValue
     *   }
     * })
     * 
     */
    delete<T extends AboutValueDeleteArgs>(args: SelectSubset<T, AboutValueDeleteArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutValue.
     * @param {AboutValueUpdateArgs} args - Arguments to update one AboutValue.
     * @example
     * // Update one AboutValue
     * const aboutValue = await prisma.aboutValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutValueUpdateArgs>(args: SelectSubset<T, AboutValueUpdateArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutValues.
     * @param {AboutValueDeleteManyArgs} args - Arguments to filter AboutValues to delete.
     * @example
     * // Delete a few AboutValues
     * const { count } = await prisma.aboutValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutValueDeleteManyArgs>(args?: SelectSubset<T, AboutValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutValues
     * const aboutValue = await prisma.aboutValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutValueUpdateManyArgs>(args: SelectSubset<T, AboutValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutValues and returns the data updated in the database.
     * @param {AboutValueUpdateManyAndReturnArgs} args - Arguments to update many AboutValues.
     * @example
     * // Update many AboutValues
     * const aboutValue = await prisma.aboutValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutValues and only return the `id`
     * const aboutValueWithIdOnly = await prisma.aboutValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutValueUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutValue.
     * @param {AboutValueUpsertArgs} args - Arguments to update or create a AboutValue.
     * @example
     * // Update or create a AboutValue
     * const aboutValue = await prisma.aboutValue.upsert({
     *   create: {
     *     // ... data to create a AboutValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutValue we want to update
     *   }
     * })
     */
    upsert<T extends AboutValueUpsertArgs>(args: SelectSubset<T, AboutValueUpsertArgs<ExtArgs>>): Prisma__AboutValueClient<$Result.GetResult<Prisma.$AboutValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueCountArgs} args - Arguments to filter AboutValues to count.
     * @example
     * // Count the number of AboutValues
     * const count = await prisma.aboutValue.count({
     *   where: {
     *     // ... the filter for the AboutValues we want to count
     *   }
     * })
    **/
    count<T extends AboutValueCountArgs>(
      args?: Subset<T, AboutValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutValueAggregateArgs>(args: Subset<T, AboutValueAggregateArgs>): Prisma.PrismaPromise<GetAboutValueAggregateType<T>>

    /**
     * Group by AboutValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutValueGroupByArgs['orderBy'] }
        : { orderBy?: AboutValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutValue model
   */
  readonly fields: AboutValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutValue model
   */
  interface AboutValueFieldRefs {
    readonly id: FieldRef<"AboutValue", 'String'>
    readonly title: FieldRef<"AboutValue", 'String'>
    readonly description: FieldRef<"AboutValue", 'String'>
    readonly icon: FieldRef<"AboutValue", 'String'>
    readonly displayOrder: FieldRef<"AboutValue", 'Int'>
    readonly active: FieldRef<"AboutValue", 'Boolean'>
    readonly createdAt: FieldRef<"AboutValue", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutValue findUnique
   */
  export type AboutValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter, which AboutValue to fetch.
     */
    where: AboutValueWhereUniqueInput
  }

  /**
   * AboutValue findUniqueOrThrow
   */
  export type AboutValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter, which AboutValue to fetch.
     */
    where: AboutValueWhereUniqueInput
  }

  /**
   * AboutValue findFirst
   */
  export type AboutValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter, which AboutValue to fetch.
     */
    where?: AboutValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutValues to fetch.
     */
    orderBy?: AboutValueOrderByWithRelationInput | AboutValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutValues.
     */
    cursor?: AboutValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutValues.
     */
    distinct?: AboutValueScalarFieldEnum | AboutValueScalarFieldEnum[]
  }

  /**
   * AboutValue findFirstOrThrow
   */
  export type AboutValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter, which AboutValue to fetch.
     */
    where?: AboutValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutValues to fetch.
     */
    orderBy?: AboutValueOrderByWithRelationInput | AboutValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutValues.
     */
    cursor?: AboutValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutValues.
     */
    distinct?: AboutValueScalarFieldEnum | AboutValueScalarFieldEnum[]
  }

  /**
   * AboutValue findMany
   */
  export type AboutValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter, which AboutValues to fetch.
     */
    where?: AboutValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutValues to fetch.
     */
    orderBy?: AboutValueOrderByWithRelationInput | AboutValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutValues.
     */
    cursor?: AboutValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutValues.
     */
    skip?: number
    distinct?: AboutValueScalarFieldEnum | AboutValueScalarFieldEnum[]
  }

  /**
   * AboutValue create
   */
  export type AboutValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutValue.
     */
    data: XOR<AboutValueCreateInput, AboutValueUncheckedCreateInput>
  }

  /**
   * AboutValue createMany
   */
  export type AboutValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutValues.
     */
    data: AboutValueCreateManyInput | AboutValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutValue createManyAndReturn
   */
  export type AboutValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * The data used to create many AboutValues.
     */
    data: AboutValueCreateManyInput | AboutValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutValue update
   */
  export type AboutValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutValue.
     */
    data: XOR<AboutValueUpdateInput, AboutValueUncheckedUpdateInput>
    /**
     * Choose, which AboutValue to update.
     */
    where: AboutValueWhereUniqueInput
  }

  /**
   * AboutValue updateMany
   */
  export type AboutValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutValues.
     */
    data: XOR<AboutValueUpdateManyMutationInput, AboutValueUncheckedUpdateManyInput>
    /**
     * Filter which AboutValues to update
     */
    where?: AboutValueWhereInput
    /**
     * Limit how many AboutValues to update.
     */
    limit?: number
  }

  /**
   * AboutValue updateManyAndReturn
   */
  export type AboutValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * The data used to update AboutValues.
     */
    data: XOR<AboutValueUpdateManyMutationInput, AboutValueUncheckedUpdateManyInput>
    /**
     * Filter which AboutValues to update
     */
    where?: AboutValueWhereInput
    /**
     * Limit how many AboutValues to update.
     */
    limit?: number
  }

  /**
   * AboutValue upsert
   */
  export type AboutValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutValue to update in case it exists.
     */
    where: AboutValueWhereUniqueInput
    /**
     * In case the AboutValue found by the `where` argument doesn't exist, create a new AboutValue with this data.
     */
    create: XOR<AboutValueCreateInput, AboutValueUncheckedCreateInput>
    /**
     * In case the AboutValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutValueUpdateInput, AboutValueUncheckedUpdateInput>
  }

  /**
   * AboutValue delete
   */
  export type AboutValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
    /**
     * Filter which AboutValue to delete.
     */
    where: AboutValueWhereUniqueInput
  }

  /**
   * AboutValue deleteMany
   */
  export type AboutValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutValues to delete
     */
    where?: AboutValueWhereInput
    /**
     * Limit how many AboutValues to delete.
     */
    limit?: number
  }

  /**
   * AboutValue without action
   */
  export type AboutValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutValue
     */
    select?: AboutValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutValue
     */
    omit?: AboutValueOmit<ExtArgs> | null
  }


  /**
   * Model AboutHero
   */

  export type AggregateAboutHero = {
    _count: AboutHeroCountAggregateOutputType | null
    _min: AboutHeroMinAggregateOutputType | null
    _max: AboutHeroMaxAggregateOutputType | null
  }

  export type AboutHeroMinAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutHeroMaxAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutHeroCountAggregateOutputType = {
    id: number
    image: number
    title: number
    subtitle: number
    description: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutHeroMinAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutHeroMaxAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutHeroCountAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutHeroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutHero to aggregate.
     */
    where?: AboutHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutHeroes to fetch.
     */
    orderBy?: AboutHeroOrderByWithRelationInput | AboutHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutHeroes
    **/
    _count?: true | AboutHeroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutHeroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutHeroMaxAggregateInputType
  }

  export type GetAboutHeroAggregateType<T extends AboutHeroAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutHero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutHero[P]>
      : GetScalarType<T[P], AggregateAboutHero[P]>
  }




  export type AboutHeroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutHeroWhereInput
    orderBy?: AboutHeroOrderByWithAggregationInput | AboutHeroOrderByWithAggregationInput[]
    by: AboutHeroScalarFieldEnum[] | AboutHeroScalarFieldEnum
    having?: AboutHeroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutHeroCountAggregateInputType | true
    _min?: AboutHeroMinAggregateInputType
    _max?: AboutHeroMaxAggregateInputType
  }

  export type AboutHeroGroupByOutputType = {
    id: string
    image: string
    title: string
    subtitle: string
    description: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AboutHeroCountAggregateOutputType | null
    _min: AboutHeroMinAggregateOutputType | null
    _max: AboutHeroMaxAggregateOutputType | null
  }

  type GetAboutHeroGroupByPayload<T extends AboutHeroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutHeroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutHeroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutHeroGroupByOutputType[P]>
            : GetScalarType<T[P], AboutHeroGroupByOutputType[P]>
        }
      >
    >


  export type AboutHeroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutHero"]>

  export type AboutHeroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutHero"]>

  export type AboutHeroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutHero"]>

  export type AboutHeroSelectScalar = {
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutHeroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "title" | "subtitle" | "description" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutHero"]>

  export type $AboutHeroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutHero"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      title: string
      subtitle: string
      description: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutHero"]>
    composites: {}
  }

  type AboutHeroGetPayload<S extends boolean | null | undefined | AboutHeroDefaultArgs> = $Result.GetResult<Prisma.$AboutHeroPayload, S>

  type AboutHeroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutHeroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutHeroCountAggregateInputType | true
    }

  export interface AboutHeroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutHero'], meta: { name: 'AboutHero' } }
    /**
     * Find zero or one AboutHero that matches the filter.
     * @param {AboutHeroFindUniqueArgs} args - Arguments to find a AboutHero
     * @example
     * // Get one AboutHero
     * const aboutHero = await prisma.aboutHero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutHeroFindUniqueArgs>(args: SelectSubset<T, AboutHeroFindUniqueArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutHero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutHeroFindUniqueOrThrowArgs} args - Arguments to find a AboutHero
     * @example
     * // Get one AboutHero
     * const aboutHero = await prisma.aboutHero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutHeroFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutHeroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutHero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroFindFirstArgs} args - Arguments to find a AboutHero
     * @example
     * // Get one AboutHero
     * const aboutHero = await prisma.aboutHero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutHeroFindFirstArgs>(args?: SelectSubset<T, AboutHeroFindFirstArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutHero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroFindFirstOrThrowArgs} args - Arguments to find a AboutHero
     * @example
     * // Get one AboutHero
     * const aboutHero = await prisma.aboutHero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutHeroFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutHeroFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutHeroes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutHeroes
     * const aboutHeroes = await prisma.aboutHero.findMany()
     * 
     * // Get first 10 AboutHeroes
     * const aboutHeroes = await prisma.aboutHero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutHeroWithIdOnly = await prisma.aboutHero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutHeroFindManyArgs>(args?: SelectSubset<T, AboutHeroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutHero.
     * @param {AboutHeroCreateArgs} args - Arguments to create a AboutHero.
     * @example
     * // Create one AboutHero
     * const AboutHero = await prisma.aboutHero.create({
     *   data: {
     *     // ... data to create a AboutHero
     *   }
     * })
     * 
     */
    create<T extends AboutHeroCreateArgs>(args: SelectSubset<T, AboutHeroCreateArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutHeroes.
     * @param {AboutHeroCreateManyArgs} args - Arguments to create many AboutHeroes.
     * @example
     * // Create many AboutHeroes
     * const aboutHero = await prisma.aboutHero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutHeroCreateManyArgs>(args?: SelectSubset<T, AboutHeroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutHeroes and returns the data saved in the database.
     * @param {AboutHeroCreateManyAndReturnArgs} args - Arguments to create many AboutHeroes.
     * @example
     * // Create many AboutHeroes
     * const aboutHero = await prisma.aboutHero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutHeroes and only return the `id`
     * const aboutHeroWithIdOnly = await prisma.aboutHero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutHeroCreateManyAndReturnArgs>(args?: SelectSubset<T, AboutHeroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutHero.
     * @param {AboutHeroDeleteArgs} args - Arguments to delete one AboutHero.
     * @example
     * // Delete one AboutHero
     * const AboutHero = await prisma.aboutHero.delete({
     *   where: {
     *     // ... filter to delete one AboutHero
     *   }
     * })
     * 
     */
    delete<T extends AboutHeroDeleteArgs>(args: SelectSubset<T, AboutHeroDeleteArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutHero.
     * @param {AboutHeroUpdateArgs} args - Arguments to update one AboutHero.
     * @example
     * // Update one AboutHero
     * const aboutHero = await prisma.aboutHero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutHeroUpdateArgs>(args: SelectSubset<T, AboutHeroUpdateArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutHeroes.
     * @param {AboutHeroDeleteManyArgs} args - Arguments to filter AboutHeroes to delete.
     * @example
     * // Delete a few AboutHeroes
     * const { count } = await prisma.aboutHero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutHeroDeleteManyArgs>(args?: SelectSubset<T, AboutHeroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutHeroes
     * const aboutHero = await prisma.aboutHero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutHeroUpdateManyArgs>(args: SelectSubset<T, AboutHeroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutHeroes and returns the data updated in the database.
     * @param {AboutHeroUpdateManyAndReturnArgs} args - Arguments to update many AboutHeroes.
     * @example
     * // Update many AboutHeroes
     * const aboutHero = await prisma.aboutHero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutHeroes and only return the `id`
     * const aboutHeroWithIdOnly = await prisma.aboutHero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutHeroUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutHeroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutHero.
     * @param {AboutHeroUpsertArgs} args - Arguments to update or create a AboutHero.
     * @example
     * // Update or create a AboutHero
     * const aboutHero = await prisma.aboutHero.upsert({
     *   create: {
     *     // ... data to create a AboutHero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutHero we want to update
     *   }
     * })
     */
    upsert<T extends AboutHeroUpsertArgs>(args: SelectSubset<T, AboutHeroUpsertArgs<ExtArgs>>): Prisma__AboutHeroClient<$Result.GetResult<Prisma.$AboutHeroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroCountArgs} args - Arguments to filter AboutHeroes to count.
     * @example
     * // Count the number of AboutHeroes
     * const count = await prisma.aboutHero.count({
     *   where: {
     *     // ... the filter for the AboutHeroes we want to count
     *   }
     * })
    **/
    count<T extends AboutHeroCountArgs>(
      args?: Subset<T, AboutHeroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutHeroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutHeroAggregateArgs>(args: Subset<T, AboutHeroAggregateArgs>): Prisma.PrismaPromise<GetAboutHeroAggregateType<T>>

    /**
     * Group by AboutHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutHeroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutHeroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutHeroGroupByArgs['orderBy'] }
        : { orderBy?: AboutHeroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutHeroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutHeroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutHero model
   */
  readonly fields: AboutHeroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutHero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutHeroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutHero model
   */
  interface AboutHeroFieldRefs {
    readonly id: FieldRef<"AboutHero", 'String'>
    readonly image: FieldRef<"AboutHero", 'String'>
    readonly title: FieldRef<"AboutHero", 'String'>
    readonly subtitle: FieldRef<"AboutHero", 'String'>
    readonly description: FieldRef<"AboutHero", 'String'>
    readonly status: FieldRef<"AboutHero", 'ContentStatus'>
    readonly publishedAt: FieldRef<"AboutHero", 'DateTime'>
    readonly createdAt: FieldRef<"AboutHero", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutHero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutHero findUnique
   */
  export type AboutHeroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter, which AboutHero to fetch.
     */
    where: AboutHeroWhereUniqueInput
  }

  /**
   * AboutHero findUniqueOrThrow
   */
  export type AboutHeroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter, which AboutHero to fetch.
     */
    where: AboutHeroWhereUniqueInput
  }

  /**
   * AboutHero findFirst
   */
  export type AboutHeroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter, which AboutHero to fetch.
     */
    where?: AboutHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutHeroes to fetch.
     */
    orderBy?: AboutHeroOrderByWithRelationInput | AboutHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutHeroes.
     */
    cursor?: AboutHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutHeroes.
     */
    distinct?: AboutHeroScalarFieldEnum | AboutHeroScalarFieldEnum[]
  }

  /**
   * AboutHero findFirstOrThrow
   */
  export type AboutHeroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter, which AboutHero to fetch.
     */
    where?: AboutHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutHeroes to fetch.
     */
    orderBy?: AboutHeroOrderByWithRelationInput | AboutHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutHeroes.
     */
    cursor?: AboutHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutHeroes.
     */
    distinct?: AboutHeroScalarFieldEnum | AboutHeroScalarFieldEnum[]
  }

  /**
   * AboutHero findMany
   */
  export type AboutHeroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter, which AboutHeroes to fetch.
     */
    where?: AboutHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutHeroes to fetch.
     */
    orderBy?: AboutHeroOrderByWithRelationInput | AboutHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutHeroes.
     */
    cursor?: AboutHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutHeroes.
     */
    skip?: number
    distinct?: AboutHeroScalarFieldEnum | AboutHeroScalarFieldEnum[]
  }

  /**
   * AboutHero create
   */
  export type AboutHeroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutHero.
     */
    data: XOR<AboutHeroCreateInput, AboutHeroUncheckedCreateInput>
  }

  /**
   * AboutHero createMany
   */
  export type AboutHeroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutHeroes.
     */
    data: AboutHeroCreateManyInput | AboutHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutHero createManyAndReturn
   */
  export type AboutHeroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * The data used to create many AboutHeroes.
     */
    data: AboutHeroCreateManyInput | AboutHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutHero update
   */
  export type AboutHeroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutHero.
     */
    data: XOR<AboutHeroUpdateInput, AboutHeroUncheckedUpdateInput>
    /**
     * Choose, which AboutHero to update.
     */
    where: AboutHeroWhereUniqueInput
  }

  /**
   * AboutHero updateMany
   */
  export type AboutHeroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutHeroes.
     */
    data: XOR<AboutHeroUpdateManyMutationInput, AboutHeroUncheckedUpdateManyInput>
    /**
     * Filter which AboutHeroes to update
     */
    where?: AboutHeroWhereInput
    /**
     * Limit how many AboutHeroes to update.
     */
    limit?: number
  }

  /**
   * AboutHero updateManyAndReturn
   */
  export type AboutHeroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * The data used to update AboutHeroes.
     */
    data: XOR<AboutHeroUpdateManyMutationInput, AboutHeroUncheckedUpdateManyInput>
    /**
     * Filter which AboutHeroes to update
     */
    where?: AboutHeroWhereInput
    /**
     * Limit how many AboutHeroes to update.
     */
    limit?: number
  }

  /**
   * AboutHero upsert
   */
  export type AboutHeroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutHero to update in case it exists.
     */
    where: AboutHeroWhereUniqueInput
    /**
     * In case the AboutHero found by the `where` argument doesn't exist, create a new AboutHero with this data.
     */
    create: XOR<AboutHeroCreateInput, AboutHeroUncheckedCreateInput>
    /**
     * In case the AboutHero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutHeroUpdateInput, AboutHeroUncheckedUpdateInput>
  }

  /**
   * AboutHero delete
   */
  export type AboutHeroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
    /**
     * Filter which AboutHero to delete.
     */
    where: AboutHeroWhereUniqueInput
  }

  /**
   * AboutHero deleteMany
   */
  export type AboutHeroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutHeroes to delete
     */
    where?: AboutHeroWhereInput
    /**
     * Limit how many AboutHeroes to delete.
     */
    limit?: number
  }

  /**
   * AboutHero without action
   */
  export type AboutHeroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutHero
     */
    select?: AboutHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutHero
     */
    omit?: AboutHeroOmit<ExtArgs> | null
  }


  /**
   * Model AboutCTA
   */

  export type AggregateAboutCTA = {
    _count: AboutCTACountAggregateOutputType | null
    _min: AboutCTAMinAggregateOutputType | null
    _max: AboutCTAMaxAggregateOutputType | null
  }

  export type AboutCTAMinAggregateOutputType = {
    id: string | null
    badge: string | null
    heading: string | null
    headingHighlight: string | null
    description: string | null
    button1Text: string | null
    button1Link: string | null
    button2Text: string | null
    button2Link: string | null
    footerText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutCTAMaxAggregateOutputType = {
    id: string | null
    badge: string | null
    heading: string | null
    headingHighlight: string | null
    description: string | null
    button1Text: string | null
    button1Link: string | null
    button2Text: string | null
    button2Link: string | null
    footerText: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutCTACountAggregateOutputType = {
    id: number
    badge: number
    heading: number
    headingHighlight: number
    description: number
    button1Text: number
    button1Link: number
    button2Text: number
    button2Link: number
    footerText: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutCTAMinAggregateInputType = {
    id?: true
    badge?: true
    heading?: true
    headingHighlight?: true
    description?: true
    button1Text?: true
    button1Link?: true
    button2Text?: true
    button2Link?: true
    footerText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutCTAMaxAggregateInputType = {
    id?: true
    badge?: true
    heading?: true
    headingHighlight?: true
    description?: true
    button1Text?: true
    button1Link?: true
    button2Text?: true
    button2Link?: true
    footerText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutCTACountAggregateInputType = {
    id?: true
    badge?: true
    heading?: true
    headingHighlight?: true
    description?: true
    button1Text?: true
    button1Link?: true
    button2Text?: true
    button2Link?: true
    footerText?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutCTAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutCTA to aggregate.
     */
    where?: AboutCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCTAS to fetch.
     */
    orderBy?: AboutCTAOrderByWithRelationInput | AboutCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutCTAS
    **/
    _count?: true | AboutCTACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutCTAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutCTAMaxAggregateInputType
  }

  export type GetAboutCTAAggregateType<T extends AboutCTAAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutCTA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutCTA[P]>
      : GetScalarType<T[P], AggregateAboutCTA[P]>
  }




  export type AboutCTAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AboutCTAWhereInput
    orderBy?: AboutCTAOrderByWithAggregationInput | AboutCTAOrderByWithAggregationInput[]
    by: AboutCTAScalarFieldEnum[] | AboutCTAScalarFieldEnum
    having?: AboutCTAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutCTACountAggregateInputType | true
    _min?: AboutCTAMinAggregateInputType
    _max?: AboutCTAMaxAggregateInputType
  }

  export type AboutCTAGroupByOutputType = {
    id: string
    badge: string
    heading: string
    headingHighlight: string
    description: string
    button1Text: string
    button1Link: string
    button2Text: string
    button2Link: string
    footerText: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AboutCTACountAggregateOutputType | null
    _min: AboutCTAMinAggregateOutputType | null
    _max: AboutCTAMaxAggregateOutputType | null
  }

  type GetAboutCTAGroupByPayload<T extends AboutCTAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutCTAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutCTAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutCTAGroupByOutputType[P]>
            : GetScalarType<T[P], AboutCTAGroupByOutputType[P]>
        }
      >
    >


  export type AboutCTASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    badge?: boolean
    heading?: boolean
    headingHighlight?: boolean
    description?: boolean
    button1Text?: boolean
    button1Link?: boolean
    button2Text?: boolean
    button2Link?: boolean
    footerText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCTA"]>

  export type AboutCTASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    badge?: boolean
    heading?: boolean
    headingHighlight?: boolean
    description?: boolean
    button1Text?: boolean
    button1Link?: boolean
    button2Text?: boolean
    button2Link?: boolean
    footerText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCTA"]>

  export type AboutCTASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    badge?: boolean
    heading?: boolean
    headingHighlight?: boolean
    description?: boolean
    button1Text?: boolean
    button1Link?: boolean
    button2Text?: boolean
    button2Link?: boolean
    footerText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aboutCTA"]>

  export type AboutCTASelectScalar = {
    id?: boolean
    badge?: boolean
    heading?: boolean
    headingHighlight?: boolean
    description?: boolean
    button1Text?: boolean
    button1Link?: boolean
    button2Text?: boolean
    button2Link?: boolean
    footerText?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AboutCTAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "badge" | "heading" | "headingHighlight" | "description" | "button1Text" | "button1Link" | "button2Text" | "button2Link" | "footerText" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aboutCTA"]>

  export type $AboutCTAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AboutCTA"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      badge: string
      heading: string
      headingHighlight: string
      description: string
      button1Text: string
      button1Link: string
      button2Text: string
      button2Link: string
      footerText: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aboutCTA"]>
    composites: {}
  }

  type AboutCTAGetPayload<S extends boolean | null | undefined | AboutCTADefaultArgs> = $Result.GetResult<Prisma.$AboutCTAPayload, S>

  type AboutCTACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AboutCTAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AboutCTACountAggregateInputType | true
    }

  export interface AboutCTADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AboutCTA'], meta: { name: 'AboutCTA' } }
    /**
     * Find zero or one AboutCTA that matches the filter.
     * @param {AboutCTAFindUniqueArgs} args - Arguments to find a AboutCTA
     * @example
     * // Get one AboutCTA
     * const aboutCTA = await prisma.aboutCTA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AboutCTAFindUniqueArgs>(args: SelectSubset<T, AboutCTAFindUniqueArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AboutCTA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AboutCTAFindUniqueOrThrowArgs} args - Arguments to find a AboutCTA
     * @example
     * // Get one AboutCTA
     * const aboutCTA = await prisma.aboutCTA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AboutCTAFindUniqueOrThrowArgs>(args: SelectSubset<T, AboutCTAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutCTA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAFindFirstArgs} args - Arguments to find a AboutCTA
     * @example
     * // Get one AboutCTA
     * const aboutCTA = await prisma.aboutCTA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AboutCTAFindFirstArgs>(args?: SelectSubset<T, AboutCTAFindFirstArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AboutCTA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAFindFirstOrThrowArgs} args - Arguments to find a AboutCTA
     * @example
     * // Get one AboutCTA
     * const aboutCTA = await prisma.aboutCTA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AboutCTAFindFirstOrThrowArgs>(args?: SelectSubset<T, AboutCTAFindFirstOrThrowArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AboutCTAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutCTAS
     * const aboutCTAS = await prisma.aboutCTA.findMany()
     * 
     * // Get first 10 AboutCTAS
     * const aboutCTAS = await prisma.aboutCTA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutCTAWithIdOnly = await prisma.aboutCTA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AboutCTAFindManyArgs>(args?: SelectSubset<T, AboutCTAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AboutCTA.
     * @param {AboutCTACreateArgs} args - Arguments to create a AboutCTA.
     * @example
     * // Create one AboutCTA
     * const AboutCTA = await prisma.aboutCTA.create({
     *   data: {
     *     // ... data to create a AboutCTA
     *   }
     * })
     * 
     */
    create<T extends AboutCTACreateArgs>(args: SelectSubset<T, AboutCTACreateArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AboutCTAS.
     * @param {AboutCTACreateManyArgs} args - Arguments to create many AboutCTAS.
     * @example
     * // Create many AboutCTAS
     * const aboutCTA = await prisma.aboutCTA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AboutCTACreateManyArgs>(args?: SelectSubset<T, AboutCTACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AboutCTAS and returns the data saved in the database.
     * @param {AboutCTACreateManyAndReturnArgs} args - Arguments to create many AboutCTAS.
     * @example
     * // Create many AboutCTAS
     * const aboutCTA = await prisma.aboutCTA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AboutCTAS and only return the `id`
     * const aboutCTAWithIdOnly = await prisma.aboutCTA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AboutCTACreateManyAndReturnArgs>(args?: SelectSubset<T, AboutCTACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AboutCTA.
     * @param {AboutCTADeleteArgs} args - Arguments to delete one AboutCTA.
     * @example
     * // Delete one AboutCTA
     * const AboutCTA = await prisma.aboutCTA.delete({
     *   where: {
     *     // ... filter to delete one AboutCTA
     *   }
     * })
     * 
     */
    delete<T extends AboutCTADeleteArgs>(args: SelectSubset<T, AboutCTADeleteArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AboutCTA.
     * @param {AboutCTAUpdateArgs} args - Arguments to update one AboutCTA.
     * @example
     * // Update one AboutCTA
     * const aboutCTA = await prisma.aboutCTA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AboutCTAUpdateArgs>(args: SelectSubset<T, AboutCTAUpdateArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AboutCTAS.
     * @param {AboutCTADeleteManyArgs} args - Arguments to filter AboutCTAS to delete.
     * @example
     * // Delete a few AboutCTAS
     * const { count } = await prisma.aboutCTA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AboutCTADeleteManyArgs>(args?: SelectSubset<T, AboutCTADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutCTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutCTAS
     * const aboutCTA = await prisma.aboutCTA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AboutCTAUpdateManyArgs>(args: SelectSubset<T, AboutCTAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutCTAS and returns the data updated in the database.
     * @param {AboutCTAUpdateManyAndReturnArgs} args - Arguments to update many AboutCTAS.
     * @example
     * // Update many AboutCTAS
     * const aboutCTA = await prisma.aboutCTA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AboutCTAS and only return the `id`
     * const aboutCTAWithIdOnly = await prisma.aboutCTA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AboutCTAUpdateManyAndReturnArgs>(args: SelectSubset<T, AboutCTAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AboutCTA.
     * @param {AboutCTAUpsertArgs} args - Arguments to update or create a AboutCTA.
     * @example
     * // Update or create a AboutCTA
     * const aboutCTA = await prisma.aboutCTA.upsert({
     *   create: {
     *     // ... data to create a AboutCTA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutCTA we want to update
     *   }
     * })
     */
    upsert<T extends AboutCTAUpsertArgs>(args: SelectSubset<T, AboutCTAUpsertArgs<ExtArgs>>): Prisma__AboutCTAClient<$Result.GetResult<Prisma.$AboutCTAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AboutCTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTACountArgs} args - Arguments to filter AboutCTAS to count.
     * @example
     * // Count the number of AboutCTAS
     * const count = await prisma.aboutCTA.count({
     *   where: {
     *     // ... the filter for the AboutCTAS we want to count
     *   }
     * })
    **/
    count<T extends AboutCTACountArgs>(
      args?: Subset<T, AboutCTACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutCTACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutCTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutCTAAggregateArgs>(args: Subset<T, AboutCTAAggregateArgs>): Prisma.PrismaPromise<GetAboutCTAAggregateType<T>>

    /**
     * Group by AboutCTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCTAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutCTAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutCTAGroupByArgs['orderBy'] }
        : { orderBy?: AboutCTAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutCTAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutCTAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AboutCTA model
   */
  readonly fields: AboutCTAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutCTA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AboutCTAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AboutCTA model
   */
  interface AboutCTAFieldRefs {
    readonly id: FieldRef<"AboutCTA", 'String'>
    readonly badge: FieldRef<"AboutCTA", 'String'>
    readonly heading: FieldRef<"AboutCTA", 'String'>
    readonly headingHighlight: FieldRef<"AboutCTA", 'String'>
    readonly description: FieldRef<"AboutCTA", 'String'>
    readonly button1Text: FieldRef<"AboutCTA", 'String'>
    readonly button1Link: FieldRef<"AboutCTA", 'String'>
    readonly button2Text: FieldRef<"AboutCTA", 'String'>
    readonly button2Link: FieldRef<"AboutCTA", 'String'>
    readonly footerText: FieldRef<"AboutCTA", 'String'>
    readonly status: FieldRef<"AboutCTA", 'ContentStatus'>
    readonly publishedAt: FieldRef<"AboutCTA", 'DateTime'>
    readonly createdAt: FieldRef<"AboutCTA", 'DateTime'>
    readonly updatedAt: FieldRef<"AboutCTA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AboutCTA findUnique
   */
  export type AboutCTAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter, which AboutCTA to fetch.
     */
    where: AboutCTAWhereUniqueInput
  }

  /**
   * AboutCTA findUniqueOrThrow
   */
  export type AboutCTAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter, which AboutCTA to fetch.
     */
    where: AboutCTAWhereUniqueInput
  }

  /**
   * AboutCTA findFirst
   */
  export type AboutCTAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter, which AboutCTA to fetch.
     */
    where?: AboutCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCTAS to fetch.
     */
    orderBy?: AboutCTAOrderByWithRelationInput | AboutCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutCTAS.
     */
    cursor?: AboutCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutCTAS.
     */
    distinct?: AboutCTAScalarFieldEnum | AboutCTAScalarFieldEnum[]
  }

  /**
   * AboutCTA findFirstOrThrow
   */
  export type AboutCTAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter, which AboutCTA to fetch.
     */
    where?: AboutCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCTAS to fetch.
     */
    orderBy?: AboutCTAOrderByWithRelationInput | AboutCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutCTAS.
     */
    cursor?: AboutCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutCTAS.
     */
    distinct?: AboutCTAScalarFieldEnum | AboutCTAScalarFieldEnum[]
  }

  /**
   * AboutCTA findMany
   */
  export type AboutCTAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter, which AboutCTAS to fetch.
     */
    where?: AboutCTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutCTAS to fetch.
     */
    orderBy?: AboutCTAOrderByWithRelationInput | AboutCTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutCTAS.
     */
    cursor?: AboutCTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutCTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutCTAS.
     */
    skip?: number
    distinct?: AboutCTAScalarFieldEnum | AboutCTAScalarFieldEnum[]
  }

  /**
   * AboutCTA create
   */
  export type AboutCTACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * The data needed to create a AboutCTA.
     */
    data: XOR<AboutCTACreateInput, AboutCTAUncheckedCreateInput>
  }

  /**
   * AboutCTA createMany
   */
  export type AboutCTACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AboutCTAS.
     */
    data: AboutCTACreateManyInput | AboutCTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutCTA createManyAndReturn
   */
  export type AboutCTACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * The data used to create many AboutCTAS.
     */
    data: AboutCTACreateManyInput | AboutCTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AboutCTA update
   */
  export type AboutCTAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * The data needed to update a AboutCTA.
     */
    data: XOR<AboutCTAUpdateInput, AboutCTAUncheckedUpdateInput>
    /**
     * Choose, which AboutCTA to update.
     */
    where: AboutCTAWhereUniqueInput
  }

  /**
   * AboutCTA updateMany
   */
  export type AboutCTAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AboutCTAS.
     */
    data: XOR<AboutCTAUpdateManyMutationInput, AboutCTAUncheckedUpdateManyInput>
    /**
     * Filter which AboutCTAS to update
     */
    where?: AboutCTAWhereInput
    /**
     * Limit how many AboutCTAS to update.
     */
    limit?: number
  }

  /**
   * AboutCTA updateManyAndReturn
   */
  export type AboutCTAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * The data used to update AboutCTAS.
     */
    data: XOR<AboutCTAUpdateManyMutationInput, AboutCTAUncheckedUpdateManyInput>
    /**
     * Filter which AboutCTAS to update
     */
    where?: AboutCTAWhereInput
    /**
     * Limit how many AboutCTAS to update.
     */
    limit?: number
  }

  /**
   * AboutCTA upsert
   */
  export type AboutCTAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * The filter to search for the AboutCTA to update in case it exists.
     */
    where: AboutCTAWhereUniqueInput
    /**
     * In case the AboutCTA found by the `where` argument doesn't exist, create a new AboutCTA with this data.
     */
    create: XOR<AboutCTACreateInput, AboutCTAUncheckedCreateInput>
    /**
     * In case the AboutCTA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutCTAUpdateInput, AboutCTAUncheckedUpdateInput>
  }

  /**
   * AboutCTA delete
   */
  export type AboutCTADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
    /**
     * Filter which AboutCTA to delete.
     */
    where: AboutCTAWhereUniqueInput
  }

  /**
   * AboutCTA deleteMany
   */
  export type AboutCTADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AboutCTAS to delete
     */
    where?: AboutCTAWhereInput
    /**
     * Limit how many AboutCTAS to delete.
     */
    limit?: number
  }

  /**
   * AboutCTA without action
   */
  export type AboutCTADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AboutCTA
     */
    select?: AboutCTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the AboutCTA
     */
    omit?: AboutCTAOmit<ExtArgs> | null
  }


  /**
   * Model ContactHero
   */

  export type AggregateContactHero = {
    _count: ContactHeroCountAggregateOutputType | null
    _min: ContactHeroMinAggregateOutputType | null
    _max: ContactHeroMaxAggregateOutputType | null
  }

  export type ContactHeroMinAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactHeroMaxAggregateOutputType = {
    id: string | null
    image: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactHeroCountAggregateOutputType = {
    id: number
    image: number
    title: number
    subtitle: number
    description: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactHeroMinAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactHeroMaxAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactHeroCountAggregateInputType = {
    id?: true
    image?: true
    title?: true
    subtitle?: true
    description?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactHeroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactHero to aggregate.
     */
    where?: ContactHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactHeroes to fetch.
     */
    orderBy?: ContactHeroOrderByWithRelationInput | ContactHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactHeroes
    **/
    _count?: true | ContactHeroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactHeroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactHeroMaxAggregateInputType
  }

  export type GetContactHeroAggregateType<T extends ContactHeroAggregateArgs> = {
        [P in keyof T & keyof AggregateContactHero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactHero[P]>
      : GetScalarType<T[P], AggregateContactHero[P]>
  }




  export type ContactHeroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactHeroWhereInput
    orderBy?: ContactHeroOrderByWithAggregationInput | ContactHeroOrderByWithAggregationInput[]
    by: ContactHeroScalarFieldEnum[] | ContactHeroScalarFieldEnum
    having?: ContactHeroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactHeroCountAggregateInputType | true
    _min?: ContactHeroMinAggregateInputType
    _max?: ContactHeroMaxAggregateInputType
  }

  export type ContactHeroGroupByOutputType = {
    id: string
    image: string
    title: string
    subtitle: string
    description: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContactHeroCountAggregateOutputType | null
    _min: ContactHeroMinAggregateOutputType | null
    _max: ContactHeroMaxAggregateOutputType | null
  }

  type GetContactHeroGroupByPayload<T extends ContactHeroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactHeroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactHeroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactHeroGroupByOutputType[P]>
            : GetScalarType<T[P], ContactHeroGroupByOutputType[P]>
        }
      >
    >


  export type ContactHeroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactHero"]>

  export type ContactHeroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactHero"]>

  export type ContactHeroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactHero"]>

  export type ContactHeroSelectScalar = {
    id?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactHeroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "title" | "subtitle" | "description" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["contactHero"]>

  export type $ContactHeroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactHero"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      title: string
      subtitle: string
      description: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactHero"]>
    composites: {}
  }

  type ContactHeroGetPayload<S extends boolean | null | undefined | ContactHeroDefaultArgs> = $Result.GetResult<Prisma.$ContactHeroPayload, S>

  type ContactHeroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactHeroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactHeroCountAggregateInputType | true
    }

  export interface ContactHeroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactHero'], meta: { name: 'ContactHero' } }
    /**
     * Find zero or one ContactHero that matches the filter.
     * @param {ContactHeroFindUniqueArgs} args - Arguments to find a ContactHero
     * @example
     * // Get one ContactHero
     * const contactHero = await prisma.contactHero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactHeroFindUniqueArgs>(args: SelectSubset<T, ContactHeroFindUniqueArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactHero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactHeroFindUniqueOrThrowArgs} args - Arguments to find a ContactHero
     * @example
     * // Get one ContactHero
     * const contactHero = await prisma.contactHero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactHeroFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactHeroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactHero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroFindFirstArgs} args - Arguments to find a ContactHero
     * @example
     * // Get one ContactHero
     * const contactHero = await prisma.contactHero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactHeroFindFirstArgs>(args?: SelectSubset<T, ContactHeroFindFirstArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactHero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroFindFirstOrThrowArgs} args - Arguments to find a ContactHero
     * @example
     * // Get one ContactHero
     * const contactHero = await prisma.contactHero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactHeroFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactHeroFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactHeroes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactHeroes
     * const contactHeroes = await prisma.contactHero.findMany()
     * 
     * // Get first 10 ContactHeroes
     * const contactHeroes = await prisma.contactHero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactHeroWithIdOnly = await prisma.contactHero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactHeroFindManyArgs>(args?: SelectSubset<T, ContactHeroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactHero.
     * @param {ContactHeroCreateArgs} args - Arguments to create a ContactHero.
     * @example
     * // Create one ContactHero
     * const ContactHero = await prisma.contactHero.create({
     *   data: {
     *     // ... data to create a ContactHero
     *   }
     * })
     * 
     */
    create<T extends ContactHeroCreateArgs>(args: SelectSubset<T, ContactHeroCreateArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactHeroes.
     * @param {ContactHeroCreateManyArgs} args - Arguments to create many ContactHeroes.
     * @example
     * // Create many ContactHeroes
     * const contactHero = await prisma.contactHero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactHeroCreateManyArgs>(args?: SelectSubset<T, ContactHeroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactHeroes and returns the data saved in the database.
     * @param {ContactHeroCreateManyAndReturnArgs} args - Arguments to create many ContactHeroes.
     * @example
     * // Create many ContactHeroes
     * const contactHero = await prisma.contactHero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactHeroes and only return the `id`
     * const contactHeroWithIdOnly = await prisma.contactHero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactHeroCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactHeroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactHero.
     * @param {ContactHeroDeleteArgs} args - Arguments to delete one ContactHero.
     * @example
     * // Delete one ContactHero
     * const ContactHero = await prisma.contactHero.delete({
     *   where: {
     *     // ... filter to delete one ContactHero
     *   }
     * })
     * 
     */
    delete<T extends ContactHeroDeleteArgs>(args: SelectSubset<T, ContactHeroDeleteArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactHero.
     * @param {ContactHeroUpdateArgs} args - Arguments to update one ContactHero.
     * @example
     * // Update one ContactHero
     * const contactHero = await prisma.contactHero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactHeroUpdateArgs>(args: SelectSubset<T, ContactHeroUpdateArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactHeroes.
     * @param {ContactHeroDeleteManyArgs} args - Arguments to filter ContactHeroes to delete.
     * @example
     * // Delete a few ContactHeroes
     * const { count } = await prisma.contactHero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactHeroDeleteManyArgs>(args?: SelectSubset<T, ContactHeroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactHeroes
     * const contactHero = await prisma.contactHero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactHeroUpdateManyArgs>(args: SelectSubset<T, ContactHeroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactHeroes and returns the data updated in the database.
     * @param {ContactHeroUpdateManyAndReturnArgs} args - Arguments to update many ContactHeroes.
     * @example
     * // Update many ContactHeroes
     * const contactHero = await prisma.contactHero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactHeroes and only return the `id`
     * const contactHeroWithIdOnly = await prisma.contactHero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactHeroUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactHeroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactHero.
     * @param {ContactHeroUpsertArgs} args - Arguments to update or create a ContactHero.
     * @example
     * // Update or create a ContactHero
     * const contactHero = await prisma.contactHero.upsert({
     *   create: {
     *     // ... data to create a ContactHero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactHero we want to update
     *   }
     * })
     */
    upsert<T extends ContactHeroUpsertArgs>(args: SelectSubset<T, ContactHeroUpsertArgs<ExtArgs>>): Prisma__ContactHeroClient<$Result.GetResult<Prisma.$ContactHeroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactHeroes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroCountArgs} args - Arguments to filter ContactHeroes to count.
     * @example
     * // Count the number of ContactHeroes
     * const count = await prisma.contactHero.count({
     *   where: {
     *     // ... the filter for the ContactHeroes we want to count
     *   }
     * })
    **/
    count<T extends ContactHeroCountArgs>(
      args?: Subset<T, ContactHeroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactHeroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactHeroAggregateArgs>(args: Subset<T, ContactHeroAggregateArgs>): Prisma.PrismaPromise<GetContactHeroAggregateType<T>>

    /**
     * Group by ContactHero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactHeroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactHeroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactHeroGroupByArgs['orderBy'] }
        : { orderBy?: ContactHeroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactHeroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactHeroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactHero model
   */
  readonly fields: ContactHeroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactHero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactHeroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactHero model
   */
  interface ContactHeroFieldRefs {
    readonly id: FieldRef<"ContactHero", 'String'>
    readonly image: FieldRef<"ContactHero", 'String'>
    readonly title: FieldRef<"ContactHero", 'String'>
    readonly subtitle: FieldRef<"ContactHero", 'String'>
    readonly description: FieldRef<"ContactHero", 'String'>
    readonly status: FieldRef<"ContactHero", 'ContentStatus'>
    readonly publishedAt: FieldRef<"ContactHero", 'DateTime'>
    readonly createdAt: FieldRef<"ContactHero", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactHero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactHero findUnique
   */
  export type ContactHeroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter, which ContactHero to fetch.
     */
    where: ContactHeroWhereUniqueInput
  }

  /**
   * ContactHero findUniqueOrThrow
   */
  export type ContactHeroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter, which ContactHero to fetch.
     */
    where: ContactHeroWhereUniqueInput
  }

  /**
   * ContactHero findFirst
   */
  export type ContactHeroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter, which ContactHero to fetch.
     */
    where?: ContactHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactHeroes to fetch.
     */
    orderBy?: ContactHeroOrderByWithRelationInput | ContactHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactHeroes.
     */
    cursor?: ContactHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactHeroes.
     */
    distinct?: ContactHeroScalarFieldEnum | ContactHeroScalarFieldEnum[]
  }

  /**
   * ContactHero findFirstOrThrow
   */
  export type ContactHeroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter, which ContactHero to fetch.
     */
    where?: ContactHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactHeroes to fetch.
     */
    orderBy?: ContactHeroOrderByWithRelationInput | ContactHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactHeroes.
     */
    cursor?: ContactHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactHeroes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactHeroes.
     */
    distinct?: ContactHeroScalarFieldEnum | ContactHeroScalarFieldEnum[]
  }

  /**
   * ContactHero findMany
   */
  export type ContactHeroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter, which ContactHeroes to fetch.
     */
    where?: ContactHeroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactHeroes to fetch.
     */
    orderBy?: ContactHeroOrderByWithRelationInput | ContactHeroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactHeroes.
     */
    cursor?: ContactHeroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactHeroes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactHeroes.
     */
    skip?: number
    distinct?: ContactHeroScalarFieldEnum | ContactHeroScalarFieldEnum[]
  }

  /**
   * ContactHero create
   */
  export type ContactHeroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactHero.
     */
    data: XOR<ContactHeroCreateInput, ContactHeroUncheckedCreateInput>
  }

  /**
   * ContactHero createMany
   */
  export type ContactHeroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactHeroes.
     */
    data: ContactHeroCreateManyInput | ContactHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactHero createManyAndReturn
   */
  export type ContactHeroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * The data used to create many ContactHeroes.
     */
    data: ContactHeroCreateManyInput | ContactHeroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactHero update
   */
  export type ContactHeroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactHero.
     */
    data: XOR<ContactHeroUpdateInput, ContactHeroUncheckedUpdateInput>
    /**
     * Choose, which ContactHero to update.
     */
    where: ContactHeroWhereUniqueInput
  }

  /**
   * ContactHero updateMany
   */
  export type ContactHeroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactHeroes.
     */
    data: XOR<ContactHeroUpdateManyMutationInput, ContactHeroUncheckedUpdateManyInput>
    /**
     * Filter which ContactHeroes to update
     */
    where?: ContactHeroWhereInput
    /**
     * Limit how many ContactHeroes to update.
     */
    limit?: number
  }

  /**
   * ContactHero updateManyAndReturn
   */
  export type ContactHeroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * The data used to update ContactHeroes.
     */
    data: XOR<ContactHeroUpdateManyMutationInput, ContactHeroUncheckedUpdateManyInput>
    /**
     * Filter which ContactHeroes to update
     */
    where?: ContactHeroWhereInput
    /**
     * Limit how many ContactHeroes to update.
     */
    limit?: number
  }

  /**
   * ContactHero upsert
   */
  export type ContactHeroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactHero to update in case it exists.
     */
    where: ContactHeroWhereUniqueInput
    /**
     * In case the ContactHero found by the `where` argument doesn't exist, create a new ContactHero with this data.
     */
    create: XOR<ContactHeroCreateInput, ContactHeroUncheckedCreateInput>
    /**
     * In case the ContactHero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactHeroUpdateInput, ContactHeroUncheckedUpdateInput>
  }

  /**
   * ContactHero delete
   */
  export type ContactHeroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
    /**
     * Filter which ContactHero to delete.
     */
    where: ContactHeroWhereUniqueInput
  }

  /**
   * ContactHero deleteMany
   */
  export type ContactHeroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactHeroes to delete
     */
    where?: ContactHeroWhereInput
    /**
     * Limit how many ContactHeroes to delete.
     */
    limit?: number
  }

  /**
   * ContactHero without action
   */
  export type ContactHeroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactHero
     */
    select?: ContactHeroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactHero
     */
    omit?: ContactHeroOmit<ExtArgs> | null
  }


  /**
   * Model ContactInfo
   */

  export type AggregateContactInfo = {
    _count: ContactInfoCountAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  export type ContactInfoMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    whatsapp: string | null
    office: string | null
    quickResponse: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInfoMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    whatsapp: string | null
    office: string | null
    quickResponse: string | null
    status: $Enums.ContentStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInfoCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    whatsapp: number
    office: number
    businessHours: number
    quickResponse: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactInfoMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    whatsapp?: true
    office?: true
    quickResponse?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInfoMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    whatsapp?: true
    office?: true
    quickResponse?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInfoCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    whatsapp?: true
    office?: true
    businessHours?: true
    quickResponse?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfo to aggregate.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInfos
    **/
    _count?: true | ContactInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInfoMaxAggregateInputType
  }

  export type GetContactInfoAggregateType<T extends ContactInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInfo[P]>
      : GetScalarType<T[P], AggregateContactInfo[P]>
  }




  export type ContactInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoWhereInput
    orderBy?: ContactInfoOrderByWithAggregationInput | ContactInfoOrderByWithAggregationInput[]
    by: ContactInfoScalarFieldEnum[] | ContactInfoScalarFieldEnum
    having?: ContactInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInfoCountAggregateInputType | true
    _min?: ContactInfoMinAggregateInputType
    _max?: ContactInfoMaxAggregateInputType
  }

  export type ContactInfoGroupByOutputType = {
    id: string
    email: string
    phone: string
    whatsapp: string
    office: string
    businessHours: JsonValue
    quickResponse: string
    status: $Enums.ContentStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContactInfoCountAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  type GetContactInfoGroupByPayload<T extends ContactInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
        }
      >
    >


  export type ContactInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    whatsapp?: boolean
    office?: boolean
    businessHours?: boolean
    quickResponse?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    whatsapp?: boolean
    office?: boolean
    businessHours?: boolean
    quickResponse?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    whatsapp?: boolean
    office?: boolean
    businessHours?: boolean
    quickResponse?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    whatsapp?: boolean
    office?: boolean
    businessHours?: boolean
    quickResponse?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "whatsapp" | "office" | "businessHours" | "quickResponse" | "status" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["contactInfo"]>

  export type $ContactInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      phone: string
      whatsapp: string
      office: string
      businessHours: Prisma.JsonValue
      quickResponse: string
      status: $Enums.ContentStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactInfo"]>
    composites: {}
  }

  type ContactInfoGetPayload<S extends boolean | null | undefined | ContactInfoDefaultArgs> = $Result.GetResult<Prisma.$ContactInfoPayload, S>

  type ContactInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactInfoCountAggregateInputType | true
    }

  export interface ContactInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInfo'], meta: { name: 'ContactInfo' } }
    /**
     * Find zero or one ContactInfo that matches the filter.
     * @param {ContactInfoFindUniqueArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactInfoFindUniqueArgs>(args: SelectSubset<T, ContactInfoFindUniqueArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactInfoFindUniqueOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactInfoFindFirstArgs>(args?: SelectSubset<T, ContactInfoFindFirstArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany()
     * 
     * // Get first 10 ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactInfoFindManyArgs>(args?: SelectSubset<T, ContactInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactInfo.
     * @param {ContactInfoCreateArgs} args - Arguments to create a ContactInfo.
     * @example
     * // Create one ContactInfo
     * const ContactInfo = await prisma.contactInfo.create({
     *   data: {
     *     // ... data to create a ContactInfo
     *   }
     * })
     * 
     */
    create<T extends ContactInfoCreateArgs>(args: SelectSubset<T, ContactInfoCreateArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactInfos.
     * @param {ContactInfoCreateManyArgs} args - Arguments to create many ContactInfos.
     * @example
     * // Create many ContactInfos
     * const contactInfo = await prisma.contactInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactInfoCreateManyArgs>(args?: SelectSubset<T, ContactInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactInfos and returns the data saved in the database.
     * @param {ContactInfoCreateManyAndReturnArgs} args - Arguments to create many ContactInfos.
     * @example
     * // Create many ContactInfos
     * const contactInfo = await prisma.contactInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactInfos and only return the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactInfo.
     * @param {ContactInfoDeleteArgs} args - Arguments to delete one ContactInfo.
     * @example
     * // Delete one ContactInfo
     * const ContactInfo = await prisma.contactInfo.delete({
     *   where: {
     *     // ... filter to delete one ContactInfo
     *   }
     * })
     * 
     */
    delete<T extends ContactInfoDeleteArgs>(args: SelectSubset<T, ContactInfoDeleteArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactInfo.
     * @param {ContactInfoUpdateArgs} args - Arguments to update one ContactInfo.
     * @example
     * // Update one ContactInfo
     * const contactInfo = await prisma.contactInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactInfoUpdateArgs>(args: SelectSubset<T, ContactInfoUpdateArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactInfos.
     * @param {ContactInfoDeleteManyArgs} args - Arguments to filter ContactInfos to delete.
     * @example
     * // Delete a few ContactInfos
     * const { count } = await prisma.contactInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactInfoDeleteManyArgs>(args?: SelectSubset<T, ContactInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInfos
     * const contactInfo = await prisma.contactInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactInfoUpdateManyArgs>(args: SelectSubset<T, ContactInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfos and returns the data updated in the database.
     * @param {ContactInfoUpdateManyAndReturnArgs} args - Arguments to update many ContactInfos.
     * @example
     * // Update many ContactInfos
     * const contactInfo = await prisma.contactInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactInfos and only return the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactInfo.
     * @param {ContactInfoUpsertArgs} args - Arguments to update or create a ContactInfo.
     * @example
     * // Update or create a ContactInfo
     * const contactInfo = await prisma.contactInfo.upsert({
     *   create: {
     *     // ... data to create a ContactInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInfo we want to update
     *   }
     * })
     */
    upsert<T extends ContactInfoUpsertArgs>(args: SelectSubset<T, ContactInfoUpsertArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoCountArgs} args - Arguments to filter ContactInfos to count.
     * @example
     * // Count the number of ContactInfos
     * const count = await prisma.contactInfo.count({
     *   where: {
     *     // ... the filter for the ContactInfos we want to count
     *   }
     * })
    **/
    count<T extends ContactInfoCountArgs>(
      args?: Subset<T, ContactInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInfoAggregateArgs>(args: Subset<T, ContactInfoAggregateArgs>): Prisma.PrismaPromise<GetContactInfoAggregateType<T>>

    /**
     * Group by ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInfoGroupByArgs['orderBy'] }
        : { orderBy?: ContactInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInfo model
   */
  readonly fields: ContactInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactInfo model
   */
  interface ContactInfoFieldRefs {
    readonly id: FieldRef<"ContactInfo", 'String'>
    readonly email: FieldRef<"ContactInfo", 'String'>
    readonly phone: FieldRef<"ContactInfo", 'String'>
    readonly whatsapp: FieldRef<"ContactInfo", 'String'>
    readonly office: FieldRef<"ContactInfo", 'String'>
    readonly businessHours: FieldRef<"ContactInfo", 'Json'>
    readonly quickResponse: FieldRef<"ContactInfo", 'String'>
    readonly status: FieldRef<"ContactInfo", 'ContentStatus'>
    readonly publishedAt: FieldRef<"ContactInfo", 'DateTime'>
    readonly createdAt: FieldRef<"ContactInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactInfo findUnique
   */
  export type ContactInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo findUniqueOrThrow
   */
  export type ContactInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo findFirst
   */
  export type ContactInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo findFirstOrThrow
   */
  export type ContactInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo findMany
   */
  export type ContactInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfos to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo create
   */
  export type ContactInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactInfo.
     */
    data: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
  }

  /**
   * ContactInfo createMany
   */
  export type ContactInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInfos.
     */
    data: ContactInfoCreateManyInput | ContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInfo createManyAndReturn
   */
  export type ContactInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data used to create many ContactInfos.
     */
    data: ContactInfoCreateManyInput | ContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInfo update
   */
  export type ContactInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactInfo.
     */
    data: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
    /**
     * Choose, which ContactInfo to update.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo updateMany
   */
  export type ContactInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInfos.
     */
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfos to update
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to update.
     */
    limit?: number
  }

  /**
   * ContactInfo updateManyAndReturn
   */
  export type ContactInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data used to update ContactInfos.
     */
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfos to update
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to update.
     */
    limit?: number
  }

  /**
   * ContactInfo upsert
   */
  export type ContactInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactInfo to update in case it exists.
     */
    where: ContactInfoWhereUniqueInput
    /**
     * In case the ContactInfo found by the `where` argument doesn't exist, create a new ContactInfo with this data.
     */
    create: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
    /**
     * In case the ContactInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
  }

  /**
   * ContactInfo delete
   */
  export type ContactInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter which ContactInfo to delete.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo deleteMany
   */
  export type ContactInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfos to delete
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to delete.
     */
    limit?: number
  }

  /**
   * ContactInfo without action
   */
  export type ContactInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
  }


  /**
   * Model ContactResource
   */

  export type AggregateContactResource = {
    _count: ContactResourceCountAggregateOutputType | null
    _avg: ContactResourceAvgAggregateOutputType | null
    _sum: ContactResourceSumAggregateOutputType | null
    _min: ContactResourceMinAggregateOutputType | null
    _max: ContactResourceMaxAggregateOutputType | null
  }

  export type ContactResourceAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ContactResourceSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ContactResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    linkText: string | null
    linkUrl: string | null
    isExternal: boolean | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    linkText: string | null
    linkUrl: string | null
    isExternal: boolean | null
    displayOrder: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    linkText: number
    linkUrl: number
    isExternal: number
    displayOrder: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactResourceAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ContactResourceSumAggregateInputType = {
    displayOrder?: true
  }

  export type ContactResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    linkText?: true
    linkUrl?: true
    isExternal?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    linkText?: true
    linkUrl?: true
    isExternal?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    linkText?: true
    linkUrl?: true
    isExternal?: true
    displayOrder?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactResource to aggregate.
     */
    where?: ContactResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactResources to fetch.
     */
    orderBy?: ContactResourceOrderByWithRelationInput | ContactResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactResources
    **/
    _count?: true | ContactResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactResourceMaxAggregateInputType
  }

  export type GetContactResourceAggregateType<T extends ContactResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateContactResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactResource[P]>
      : GetScalarType<T[P], AggregateContactResource[P]>
  }




  export type ContactResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactResourceWhereInput
    orderBy?: ContactResourceOrderByWithAggregationInput | ContactResourceOrderByWithAggregationInput[]
    by: ContactResourceScalarFieldEnum[] | ContactResourceScalarFieldEnum
    having?: ContactResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactResourceCountAggregateInputType | true
    _avg?: ContactResourceAvgAggregateInputType
    _sum?: ContactResourceSumAggregateInputType
    _min?: ContactResourceMinAggregateInputType
    _max?: ContactResourceMaxAggregateInputType
  }

  export type ContactResourceGroupByOutputType = {
    id: string
    title: string
    description: string
    icon: string
    linkText: string
    linkUrl: string
    isExternal: boolean
    displayOrder: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactResourceCountAggregateOutputType | null
    _avg: ContactResourceAvgAggregateOutputType | null
    _sum: ContactResourceSumAggregateOutputType | null
    _min: ContactResourceMinAggregateOutputType | null
    _max: ContactResourceMaxAggregateOutputType | null
  }

  type GetContactResourceGroupByPayload<T extends ContactResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ContactResourceGroupByOutputType[P]>
        }
      >
    >


  export type ContactResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    linkText?: boolean
    linkUrl?: boolean
    isExternal?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactResource"]>

  export type ContactResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    linkText?: boolean
    linkUrl?: boolean
    isExternal?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactResource"]>

  export type ContactResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    linkText?: boolean
    linkUrl?: boolean
    isExternal?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactResource"]>

  export type ContactResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    linkText?: boolean
    linkUrl?: boolean
    isExternal?: boolean
    displayOrder?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "icon" | "linkText" | "linkUrl" | "isExternal" | "displayOrder" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["contactResource"]>

  export type $ContactResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactResource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      icon: string
      linkText: string
      linkUrl: string
      isExternal: boolean
      displayOrder: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactResource"]>
    composites: {}
  }

  type ContactResourceGetPayload<S extends boolean | null | undefined | ContactResourceDefaultArgs> = $Result.GetResult<Prisma.$ContactResourcePayload, S>

  type ContactResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactResourceCountAggregateInputType | true
    }

  export interface ContactResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactResource'], meta: { name: 'ContactResource' } }
    /**
     * Find zero or one ContactResource that matches the filter.
     * @param {ContactResourceFindUniqueArgs} args - Arguments to find a ContactResource
     * @example
     * // Get one ContactResource
     * const contactResource = await prisma.contactResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactResourceFindUniqueArgs>(args: SelectSubset<T, ContactResourceFindUniqueArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactResourceFindUniqueOrThrowArgs} args - Arguments to find a ContactResource
     * @example
     * // Get one ContactResource
     * const contactResource = await prisma.contactResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceFindFirstArgs} args - Arguments to find a ContactResource
     * @example
     * // Get one ContactResource
     * const contactResource = await prisma.contactResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactResourceFindFirstArgs>(args?: SelectSubset<T, ContactResourceFindFirstArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceFindFirstOrThrowArgs} args - Arguments to find a ContactResource
     * @example
     * // Get one ContactResource
     * const contactResource = await prisma.contactResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactResources
     * const contactResources = await prisma.contactResource.findMany()
     * 
     * // Get first 10 ContactResources
     * const contactResources = await prisma.contactResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactResourceWithIdOnly = await prisma.contactResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactResourceFindManyArgs>(args?: SelectSubset<T, ContactResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactResource.
     * @param {ContactResourceCreateArgs} args - Arguments to create a ContactResource.
     * @example
     * // Create one ContactResource
     * const ContactResource = await prisma.contactResource.create({
     *   data: {
     *     // ... data to create a ContactResource
     *   }
     * })
     * 
     */
    create<T extends ContactResourceCreateArgs>(args: SelectSubset<T, ContactResourceCreateArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactResources.
     * @param {ContactResourceCreateManyArgs} args - Arguments to create many ContactResources.
     * @example
     * // Create many ContactResources
     * const contactResource = await prisma.contactResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactResourceCreateManyArgs>(args?: SelectSubset<T, ContactResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactResources and returns the data saved in the database.
     * @param {ContactResourceCreateManyAndReturnArgs} args - Arguments to create many ContactResources.
     * @example
     * // Create many ContactResources
     * const contactResource = await prisma.contactResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactResources and only return the `id`
     * const contactResourceWithIdOnly = await prisma.contactResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactResource.
     * @param {ContactResourceDeleteArgs} args - Arguments to delete one ContactResource.
     * @example
     * // Delete one ContactResource
     * const ContactResource = await prisma.contactResource.delete({
     *   where: {
     *     // ... filter to delete one ContactResource
     *   }
     * })
     * 
     */
    delete<T extends ContactResourceDeleteArgs>(args: SelectSubset<T, ContactResourceDeleteArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactResource.
     * @param {ContactResourceUpdateArgs} args - Arguments to update one ContactResource.
     * @example
     * // Update one ContactResource
     * const contactResource = await prisma.contactResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactResourceUpdateArgs>(args: SelectSubset<T, ContactResourceUpdateArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactResources.
     * @param {ContactResourceDeleteManyArgs} args - Arguments to filter ContactResources to delete.
     * @example
     * // Delete a few ContactResources
     * const { count } = await prisma.contactResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactResourceDeleteManyArgs>(args?: SelectSubset<T, ContactResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactResources
     * const contactResource = await prisma.contactResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactResourceUpdateManyArgs>(args: SelectSubset<T, ContactResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactResources and returns the data updated in the database.
     * @param {ContactResourceUpdateManyAndReturnArgs} args - Arguments to update many ContactResources.
     * @example
     * // Update many ContactResources
     * const contactResource = await prisma.contactResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactResources and only return the `id`
     * const contactResourceWithIdOnly = await prisma.contactResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactResource.
     * @param {ContactResourceUpsertArgs} args - Arguments to update or create a ContactResource.
     * @example
     * // Update or create a ContactResource
     * const contactResource = await prisma.contactResource.upsert({
     *   create: {
     *     // ... data to create a ContactResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactResource we want to update
     *   }
     * })
     */
    upsert<T extends ContactResourceUpsertArgs>(args: SelectSubset<T, ContactResourceUpsertArgs<ExtArgs>>): Prisma__ContactResourceClient<$Result.GetResult<Prisma.$ContactResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceCountArgs} args - Arguments to filter ContactResources to count.
     * @example
     * // Count the number of ContactResources
     * const count = await prisma.contactResource.count({
     *   where: {
     *     // ... the filter for the ContactResources we want to count
     *   }
     * })
    **/
    count<T extends ContactResourceCountArgs>(
      args?: Subset<T, ContactResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactResourceAggregateArgs>(args: Subset<T, ContactResourceAggregateArgs>): Prisma.PrismaPromise<GetContactResourceAggregateType<T>>

    /**
     * Group by ContactResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactResourceGroupByArgs['orderBy'] }
        : { orderBy?: ContactResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactResource model
   */
  readonly fields: ContactResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactResource model
   */
  interface ContactResourceFieldRefs {
    readonly id: FieldRef<"ContactResource", 'String'>
    readonly title: FieldRef<"ContactResource", 'String'>
    readonly description: FieldRef<"ContactResource", 'String'>
    readonly icon: FieldRef<"ContactResource", 'String'>
    readonly linkText: FieldRef<"ContactResource", 'String'>
    readonly linkUrl: FieldRef<"ContactResource", 'String'>
    readonly isExternal: FieldRef<"ContactResource", 'Boolean'>
    readonly displayOrder: FieldRef<"ContactResource", 'Int'>
    readonly active: FieldRef<"ContactResource", 'Boolean'>
    readonly createdAt: FieldRef<"ContactResource", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactResource findUnique
   */
  export type ContactResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter, which ContactResource to fetch.
     */
    where: ContactResourceWhereUniqueInput
  }

  /**
   * ContactResource findUniqueOrThrow
   */
  export type ContactResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter, which ContactResource to fetch.
     */
    where: ContactResourceWhereUniqueInput
  }

  /**
   * ContactResource findFirst
   */
  export type ContactResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter, which ContactResource to fetch.
     */
    where?: ContactResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactResources to fetch.
     */
    orderBy?: ContactResourceOrderByWithRelationInput | ContactResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactResources.
     */
    cursor?: ContactResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactResources.
     */
    distinct?: ContactResourceScalarFieldEnum | ContactResourceScalarFieldEnum[]
  }

  /**
   * ContactResource findFirstOrThrow
   */
  export type ContactResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter, which ContactResource to fetch.
     */
    where?: ContactResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactResources to fetch.
     */
    orderBy?: ContactResourceOrderByWithRelationInput | ContactResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactResources.
     */
    cursor?: ContactResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactResources.
     */
    distinct?: ContactResourceScalarFieldEnum | ContactResourceScalarFieldEnum[]
  }

  /**
   * ContactResource findMany
   */
  export type ContactResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter, which ContactResources to fetch.
     */
    where?: ContactResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactResources to fetch.
     */
    orderBy?: ContactResourceOrderByWithRelationInput | ContactResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactResources.
     */
    cursor?: ContactResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactResources.
     */
    skip?: number
    distinct?: ContactResourceScalarFieldEnum | ContactResourceScalarFieldEnum[]
  }

  /**
   * ContactResource create
   */
  export type ContactResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactResource.
     */
    data: XOR<ContactResourceCreateInput, ContactResourceUncheckedCreateInput>
  }

  /**
   * ContactResource createMany
   */
  export type ContactResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactResources.
     */
    data: ContactResourceCreateManyInput | ContactResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactResource createManyAndReturn
   */
  export type ContactResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * The data used to create many ContactResources.
     */
    data: ContactResourceCreateManyInput | ContactResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactResource update
   */
  export type ContactResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactResource.
     */
    data: XOR<ContactResourceUpdateInput, ContactResourceUncheckedUpdateInput>
    /**
     * Choose, which ContactResource to update.
     */
    where: ContactResourceWhereUniqueInput
  }

  /**
   * ContactResource updateMany
   */
  export type ContactResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactResources.
     */
    data: XOR<ContactResourceUpdateManyMutationInput, ContactResourceUncheckedUpdateManyInput>
    /**
     * Filter which ContactResources to update
     */
    where?: ContactResourceWhereInput
    /**
     * Limit how many ContactResources to update.
     */
    limit?: number
  }

  /**
   * ContactResource updateManyAndReturn
   */
  export type ContactResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * The data used to update ContactResources.
     */
    data: XOR<ContactResourceUpdateManyMutationInput, ContactResourceUncheckedUpdateManyInput>
    /**
     * Filter which ContactResources to update
     */
    where?: ContactResourceWhereInput
    /**
     * Limit how many ContactResources to update.
     */
    limit?: number
  }

  /**
   * ContactResource upsert
   */
  export type ContactResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactResource to update in case it exists.
     */
    where: ContactResourceWhereUniqueInput
    /**
     * In case the ContactResource found by the `where` argument doesn't exist, create a new ContactResource with this data.
     */
    create: XOR<ContactResourceCreateInput, ContactResourceUncheckedCreateInput>
    /**
     * In case the ContactResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactResourceUpdateInput, ContactResourceUncheckedUpdateInput>
  }

  /**
   * ContactResource delete
   */
  export type ContactResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
    /**
     * Filter which ContactResource to delete.
     */
    where: ContactResourceWhereUniqueInput
  }

  /**
   * ContactResource deleteMany
   */
  export type ContactResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactResources to delete
     */
    where?: ContactResourceWhereInput
    /**
     * Limit how many ContactResources to delete.
     */
    limit?: number
  }

  /**
   * ContactResource without action
   */
  export type ContactResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactResource
     */
    select?: ContactResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactResource
     */
    omit?: ContactResourceOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    country: 'country',
    region: 'region',
    price: 'price',
    rating: 'rating',
    duration: 'duration',
    groupSize: 'groupSize',
    minTravelers: 'minTravelers',
    maxTravelers: 'maxTravelers',
    description: 'description',
    image: 'image',
    images: 'images',
    gallery2Images: 'gallery2Images',
    featured: 'featured',
    historyTitle: 'historyTitle',
    historyContent: 'historyContent',
    geographyDescription: 'geographyDescription',
    geographyClimate: 'geographyClimate',
    wildlifeDescription: 'wildlifeDescription',
    wildlifeMammals: 'wildlifeMammals',
    wildlifeBirds: 'wildlifeBirds',
    wildlifeFlora: 'wildlifeFlora',
    cultureDescription: 'cultureDescription',
    cultureExperiences: 'cultureExperiences',
    bestTimeDescription: 'bestTimeDescription',
    drySeasonTitle: 'drySeasonTitle',
    drySeasonDescription: 'drySeasonDescription',
    wetSeasonTitle: 'wetSeasonTitle',
    wetSeasonDescription: 'wetSeasonDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationScalarFieldEnum = (typeof DestinationScalarFieldEnum)[keyof typeof DestinationScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    confirmationNumber: 'confirmationNumber',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    country: 'country',
    packageId: 'packageId',
    destinationId: 'destinationId',
    bookingType: 'bookingType',
    numberOfTravelers: 'numberOfTravelers',
    specialRequests: 'specialRequests',
    travelDateFrom: 'travelDateFrom',
    travelDateTo: 'travelDateTo',
    pricePerPerson: 'pricePerPerson',
    totalPrice: 'totalPrice',
    status: 'status',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    paymentReference: 'paymentReference',
    paymentIntentId: 'paymentIntentId',
    stripeCustomerId: 'stripeCustomerId',
    adminNotes: 'adminNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const ContactInquiryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    status: 'status',
    responseNotes: 'responseNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactInquiryScalarFieldEnum = (typeof ContactInquiryScalarFieldEnum)[keyof typeof ContactInquiryScalarFieldEnum]


  export const NewsletterSubscriptionScalarFieldEnum: {
    id: 'id',
    email: 'email',
    status: 'status',
    subscribedAt: 'subscribedAt',
    unsubscribedAt: 'unsubscribedAt'
  };

  export type NewsletterSubscriptionScalarFieldEnum = (typeof NewsletterSubscriptionScalarFieldEnum)[keyof typeof NewsletterSubscriptionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    profileImageUrl: 'profileImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    destinationId: 'destinationId',
    createdAt: 'createdAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    category: 'category',
    duration: 'duration',
    price: 'price',
    description: 'description',
    shortDesc: 'shortDesc',
    image: 'image',
    images: 'images',
    gallery2Images: 'gallery2Images',
    highlights: 'highlights',
    itinerary: 'itinerary',
    included: 'included',
    excluded: 'excluded',
    minTravelers: 'minTravelers',
    maxTravelers: 'maxTravelers',
    difficulty: 'difficulty',
    featured: 'featured',
    popular: 'popular',
    active: 'active',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const CustomPackageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contactName: 'contactName',
    email: 'email',
    phone: 'phone',
    destinations: 'destinations',
    duration: 'duration',
    numberOfPeople: 'numberOfPeople',
    travelDate: 'travelDate',
    specialRequests: 'specialRequests',
    budget: 'budget',
    status: 'status',
    quotedPrice: 'quotedPrice',
    quoteNotes: 'quoteNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomPackageScalarFieldEnum = (typeof CustomPackageScalarFieldEnum)[keyof typeof CustomPackageScalarFieldEnum]


  export const PackageBundleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    numberOfPeople: 'numberOfPeople',
    travelDate: 'travelDate',
    specialRequests: 'specialRequests',
    status: 'status',
    quotedPrice: 'quotedPrice',
    quoteNotes: 'quoteNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageBundleScalarFieldEnum = (typeof PackageBundleScalarFieldEnum)[keyof typeof PackageBundleScalarFieldEnum]


  export const PackageBundleItemScalarFieldEnum: {
    id: 'id',
    bundleId: 'bundleId',
    packageId: 'packageId',
    notes: 'notes'
  };

  export type PackageBundleItemScalarFieldEnum = (typeof PackageBundleItemScalarFieldEnum)[keyof typeof PackageBundleItemScalarFieldEnum]


  export const CMSImageScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    url: 'url',
    altText: 'altText',
    category: 'category',
    width: 'width',
    height: 'height',
    fileSize: 'fileSize',
    format: 'format',
    usedIn: 'usedIn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CMSImageScalarFieldEnum = (typeof CMSImageScalarFieldEnum)[keyof typeof CMSImageScalarFieldEnum]


  export const HeroSlideScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    image: 'image',
    displayOrder: 'displayOrder',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroSlideScalarFieldEnum = (typeof HeroSlideScalarFieldEnum)[keyof typeof HeroSlideScalarFieldEnum]


  export const CMSDestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    category: 'category',
    region: 'region',
    country: 'country',
    description: 'description',
    shortDesc: 'shortDesc',
    heroImage: 'heroImage',
    gallery: 'gallery',
    history: 'history',
    geography: 'geography',
    climate: 'climate',
    wildlife: 'wildlife',
    keyWildlife: 'keyWildlife',
    flora: 'flora',
    cultural: 'cultural',
    bestTime: 'bestTime',
    featured: 'featured',
    active: 'active',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CMSDestinationScalarFieldEnum = (typeof CMSDestinationScalarFieldEnum)[keyof typeof CMSDestinationScalarFieldEnum]


  export const SiteSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SiteSettingsScalarFieldEnum = (typeof SiteSettingsScalarFieldEnum)[keyof typeof SiteSettingsScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    bio: 'bio',
    image: 'image',
    years: 'years',
    specialties: 'specialties',
    displayOrder: 'displayOrder',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    displayOrder: 'displayOrder',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const CMSAuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type CMSAuditLogScalarFieldEnum = (typeof CMSAuditLogScalarFieldEnum)[keyof typeof CMSAuditLogScalarFieldEnum]


  export const ExperienceSectionScalarFieldEnum: {
    id: 'id',
    heading: 'heading',
    title: 'title',
    description: 'description',
    image: 'image',
    stat1Value: 'stat1Value',
    stat1Label: 'stat1Label',
    stat2Value: 'stat2Value',
    stat2Label: 'stat2Label',
    badgeText: 'badgeText',
    backgroundText: 'backgroundText',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExperienceSectionScalarFieldEnum = (typeof ExperienceSectionScalarFieldEnum)[keyof typeof ExperienceSectionScalarFieldEnum]


  export const TourGuideSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    mapImage: 'mapImage',
    buttonText: 'buttonText',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourGuideSectionScalarFieldEnum = (typeof TourGuideSectionScalarFieldEnum)[keyof typeof TourGuideSectionScalarFieldEnum]


  export const VideoSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoSectionScalarFieldEnum = (typeof VideoSectionScalarFieldEnum)[keyof typeof VideoSectionScalarFieldEnum]


  export const PackagesHeroScalarFieldEnum: {
    id: 'id',
    image: 'image',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackagesHeroScalarFieldEnum = (typeof PackagesHeroScalarFieldEnum)[keyof typeof PackagesHeroScalarFieldEnum]


  export const DestinationsHeroScalarFieldEnum: {
    id: 'id',
    image: 'image',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationsHeroScalarFieldEnum = (typeof DestinationsHeroScalarFieldEnum)[keyof typeof DestinationsHeroScalarFieldEnum]


  export const DestinationsCTAScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    buttonText: 'buttonText',
    buttonLink: 'buttonLink',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationsCTAScalarFieldEnum = (typeof DestinationsCTAScalarFieldEnum)[keyof typeof DestinationsCTAScalarFieldEnum]


  export const AboutStorySectionScalarFieldEnum: {
    id: 'id',
    heading: 'heading',
    title: 'title',
    titleHighlight: 'titleHighlight',
    paragraph1: 'paragraph1',
    paragraph2: 'paragraph2',
    buttonText: 'buttonText',
    buttonLink: 'buttonLink',
    image: 'image',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutStorySectionScalarFieldEnum = (typeof AboutStorySectionScalarFieldEnum)[keyof typeof AboutStorySectionScalarFieldEnum]


  export const AboutCommunitySectionScalarFieldEnum: {
    id: 'id',
    heading: 'heading',
    title: 'title',
    titleHighlight: 'titleHighlight',
    paragraph1: 'paragraph1',
    paragraph2: 'paragraph2',
    buttonText: 'buttonText',
    buttonLink: 'buttonLink',
    feature1Title: 'feature1Title',
    feature1Description: 'feature1Description',
    feature2Title: 'feature2Title',
    feature2Description: 'feature2Description',
    feature3Title: 'feature3Title',
    feature3Description: 'feature3Description',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutCommunitySectionScalarFieldEnum = (typeof AboutCommunitySectionScalarFieldEnum)[keyof typeof AboutCommunitySectionScalarFieldEnum]


  export const AboutStatsScalarFieldEnum: {
    id: 'id',
    stat1Number: 'stat1Number',
    stat1Label: 'stat1Label',
    stat2Number: 'stat2Number',
    stat2Label: 'stat2Label',
    stat3Number: 'stat3Number',
    stat3Label: 'stat3Label',
    stat4Number: 'stat4Number',
    stat4Label: 'stat4Label',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutStatsScalarFieldEnum = (typeof AboutStatsScalarFieldEnum)[keyof typeof AboutStatsScalarFieldEnum]


  export const AboutValueScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    displayOrder: 'displayOrder',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutValueScalarFieldEnum = (typeof AboutValueScalarFieldEnum)[keyof typeof AboutValueScalarFieldEnum]


  export const AboutHeroScalarFieldEnum: {
    id: 'id',
    image: 'image',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutHeroScalarFieldEnum = (typeof AboutHeroScalarFieldEnum)[keyof typeof AboutHeroScalarFieldEnum]


  export const AboutCTAScalarFieldEnum: {
    id: 'id',
    badge: 'badge',
    heading: 'heading',
    headingHighlight: 'headingHighlight',
    description: 'description',
    button1Text: 'button1Text',
    button1Link: 'button1Link',
    button2Text: 'button2Text',
    button2Link: 'button2Link',
    footerText: 'footerText',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutCTAScalarFieldEnum = (typeof AboutCTAScalarFieldEnum)[keyof typeof AboutCTAScalarFieldEnum]


  export const ContactHeroScalarFieldEnum: {
    id: 'id',
    image: 'image',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactHeroScalarFieldEnum = (typeof ContactHeroScalarFieldEnum)[keyof typeof ContactHeroScalarFieldEnum]


  export const ContactInfoScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    whatsapp: 'whatsapp',
    office: 'office',
    businessHours: 'businessHours',
    quickResponse: 'quickResponse',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactInfoScalarFieldEnum = (typeof ContactInfoScalarFieldEnum)[keyof typeof ContactInfoScalarFieldEnum]


  export const ContactResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    linkText: 'linkText',
    linkUrl: 'linkUrl',
    isExternal: 'isExternal',
    displayOrder: 'displayOrder',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactResourceScalarFieldEnum = (typeof ContactResourceScalarFieldEnum)[keyof typeof ContactResourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BookingType'
   */
  export type EnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType'>
    


  /**
   * Reference to a field of type 'BookingType[]'
   */
  export type ListEnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'InquiryStatus'
   */
  export type EnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus'>
    


  /**
   * Reference to a field of type 'InquiryStatus[]'
   */
  export type ListEnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DifficultyLevel'
   */
  export type EnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel'>
    


  /**
   * Reference to a field of type 'DifficultyLevel[]'
   */
  export type ListEnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel[]'>
    


  /**
   * Reference to a field of type 'CustomPackageStatus'
   */
  export type EnumCustomPackageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPackageStatus'>
    


  /**
   * Reference to a field of type 'CustomPackageStatus[]'
   */
  export type ListEnumCustomPackageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPackageStatus[]'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DestinationWhereInput = {
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    id?: IntFilter<"Destination"> | number
    name?: StringFilter<"Destination"> | string
    category?: StringFilter<"Destination"> | string
    country?: StringFilter<"Destination"> | string
    region?: StringNullableFilter<"Destination"> | string | null
    price?: DecimalFilter<"Destination"> | Decimal | DecimalJsLike | number | string
    rating?: IntFilter<"Destination"> | number
    duration?: StringFilter<"Destination"> | string
    groupSize?: IntFilter<"Destination"> | number
    minTravelers?: IntNullableFilter<"Destination"> | number | null
    maxTravelers?: IntNullableFilter<"Destination"> | number | null
    description?: StringFilter<"Destination"> | string
    image?: StringFilter<"Destination"> | string
    images?: StringNullableListFilter<"Destination">
    gallery2Images?: StringNullableListFilter<"Destination">
    featured?: BoolFilter<"Destination"> | boolean
    historyTitle?: StringNullableFilter<"Destination"> | string | null
    historyContent?: StringNullableListFilter<"Destination">
    geographyDescription?: StringNullableFilter<"Destination"> | string | null
    geographyClimate?: StringNullableFilter<"Destination"> | string | null
    wildlifeDescription?: StringNullableFilter<"Destination"> | string | null
    wildlifeMammals?: StringNullableListFilter<"Destination">
    wildlifeBirds?: StringNullableListFilter<"Destination">
    wildlifeFlora?: StringNullableListFilter<"Destination">
    cultureDescription?: StringNullableFilter<"Destination"> | string | null
    cultureExperiences?: StringNullableListFilter<"Destination">
    bestTimeDescription?: StringNullableFilter<"Destination"> | string | null
    drySeasonTitle?: StringNullableFilter<"Destination"> | string | null
    drySeasonDescription?: StringNullableFilter<"Destination"> | string | null
    wetSeasonTitle?: StringNullableFilter<"Destination"> | string | null
    wetSeasonDescription?: StringNullableFilter<"Destination"> | string | null
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    bookings?: BookingListRelationFilter
    favorites?: UserFavoriteListRelationFilter
  }

  export type DestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    country?: SortOrder
    region?: SortOrderInput | SortOrder
    price?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrderInput | SortOrder
    maxTravelers?: SortOrderInput | SortOrder
    description?: SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    featured?: SortOrder
    historyTitle?: SortOrderInput | SortOrder
    historyContent?: SortOrder
    geographyDescription?: SortOrderInput | SortOrder
    geographyClimate?: SortOrderInput | SortOrder
    wildlifeDescription?: SortOrderInput | SortOrder
    wildlifeMammals?: SortOrder
    wildlifeBirds?: SortOrder
    wildlifeFlora?: SortOrder
    cultureDescription?: SortOrderInput | SortOrder
    cultureExperiences?: SortOrder
    bestTimeDescription?: SortOrderInput | SortOrder
    drySeasonTitle?: SortOrderInput | SortOrder
    drySeasonDescription?: SortOrderInput | SortOrder
    wetSeasonTitle?: SortOrderInput | SortOrder
    wetSeasonDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    favorites?: UserFavoriteOrderByRelationAggregateInput
  }

  export type DestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    name?: StringFilter<"Destination"> | string
    category?: StringFilter<"Destination"> | string
    country?: StringFilter<"Destination"> | string
    region?: StringNullableFilter<"Destination"> | string | null
    price?: DecimalFilter<"Destination"> | Decimal | DecimalJsLike | number | string
    rating?: IntFilter<"Destination"> | number
    duration?: StringFilter<"Destination"> | string
    groupSize?: IntFilter<"Destination"> | number
    minTravelers?: IntNullableFilter<"Destination"> | number | null
    maxTravelers?: IntNullableFilter<"Destination"> | number | null
    description?: StringFilter<"Destination"> | string
    image?: StringFilter<"Destination"> | string
    images?: StringNullableListFilter<"Destination">
    gallery2Images?: StringNullableListFilter<"Destination">
    featured?: BoolFilter<"Destination"> | boolean
    historyTitle?: StringNullableFilter<"Destination"> | string | null
    historyContent?: StringNullableListFilter<"Destination">
    geographyDescription?: StringNullableFilter<"Destination"> | string | null
    geographyClimate?: StringNullableFilter<"Destination"> | string | null
    wildlifeDescription?: StringNullableFilter<"Destination"> | string | null
    wildlifeMammals?: StringNullableListFilter<"Destination">
    wildlifeBirds?: StringNullableListFilter<"Destination">
    wildlifeFlora?: StringNullableListFilter<"Destination">
    cultureDescription?: StringNullableFilter<"Destination"> | string | null
    cultureExperiences?: StringNullableListFilter<"Destination">
    bestTimeDescription?: StringNullableFilter<"Destination"> | string | null
    drySeasonTitle?: StringNullableFilter<"Destination"> | string | null
    drySeasonDescription?: StringNullableFilter<"Destination"> | string | null
    wetSeasonTitle?: StringNullableFilter<"Destination"> | string | null
    wetSeasonDescription?: StringNullableFilter<"Destination"> | string | null
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    bookings?: BookingListRelationFilter
    favorites?: UserFavoriteListRelationFilter
  }, "id">

  export type DestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    country?: SortOrder
    region?: SortOrderInput | SortOrder
    price?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrderInput | SortOrder
    maxTravelers?: SortOrderInput | SortOrder
    description?: SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    featured?: SortOrder
    historyTitle?: SortOrderInput | SortOrder
    historyContent?: SortOrder
    geographyDescription?: SortOrderInput | SortOrder
    geographyClimate?: SortOrderInput | SortOrder
    wildlifeDescription?: SortOrderInput | SortOrder
    wildlifeMammals?: SortOrder
    wildlifeBirds?: SortOrder
    wildlifeFlora?: SortOrder
    cultureDescription?: SortOrderInput | SortOrder
    cultureExperiences?: SortOrder
    bestTimeDescription?: SortOrderInput | SortOrder
    drySeasonTitle?: SortOrderInput | SortOrder
    drySeasonDescription?: SortOrderInput | SortOrder
    wetSeasonTitle?: SortOrderInput | SortOrder
    wetSeasonDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationCountOrderByAggregateInput
    _avg?: DestinationAvgOrderByAggregateInput
    _max?: DestinationMaxOrderByAggregateInput
    _min?: DestinationMinOrderByAggregateInput
    _sum?: DestinationSumOrderByAggregateInput
  }

  export type DestinationScalarWhereWithAggregatesInput = {
    AND?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    OR?: DestinationScalarWhereWithAggregatesInput[]
    NOT?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Destination"> | number
    name?: StringWithAggregatesFilter<"Destination"> | string
    category?: StringWithAggregatesFilter<"Destination"> | string
    country?: StringWithAggregatesFilter<"Destination"> | string
    region?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    price?: DecimalWithAggregatesFilter<"Destination"> | Decimal | DecimalJsLike | number | string
    rating?: IntWithAggregatesFilter<"Destination"> | number
    duration?: StringWithAggregatesFilter<"Destination"> | string
    groupSize?: IntWithAggregatesFilter<"Destination"> | number
    minTravelers?: IntNullableWithAggregatesFilter<"Destination"> | number | null
    maxTravelers?: IntNullableWithAggregatesFilter<"Destination"> | number | null
    description?: StringWithAggregatesFilter<"Destination"> | string
    image?: StringWithAggregatesFilter<"Destination"> | string
    images?: StringNullableListFilter<"Destination">
    gallery2Images?: StringNullableListFilter<"Destination">
    featured?: BoolWithAggregatesFilter<"Destination"> | boolean
    historyTitle?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    historyContent?: StringNullableListFilter<"Destination">
    geographyDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    geographyClimate?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    wildlifeDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    wildlifeMammals?: StringNullableListFilter<"Destination">
    wildlifeBirds?: StringNullableListFilter<"Destination">
    wildlifeFlora?: StringNullableListFilter<"Destination">
    cultureDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    cultureExperiences?: StringNullableListFilter<"Destination">
    bestTimeDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    drySeasonTitle?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    drySeasonDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    wetSeasonTitle?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    wetSeasonDescription?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    confirmationNumber?: StringFilter<"Booking"> | string
    userId?: StringNullableFilter<"Booking"> | string | null
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringFilter<"Booking"> | string
    country?: StringNullableFilter<"Booking"> | string | null
    packageId?: IntNullableFilter<"Booking"> | number | null
    destinationId?: IntNullableFilter<"Booking"> | number | null
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    numberOfTravelers?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    travelDateFrom?: DateTimeFilter<"Booking"> | Date | string
    travelDateTo?: DateTimeFilter<"Booking"> | Date | string
    pricePerPerson?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    paymentReference?: StringNullableFilter<"Booking"> | string | null
    paymentIntentId?: StringNullableFilter<"Booking"> | string | null
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    adminNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    confirmationNumber?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    country?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    destinationId?: SortOrderInput | SortOrder
    bookingType?: SortOrder
    numberOfTravelers?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    travelDateFrom?: SortOrder
    travelDateTo?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentReference?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    confirmationNumber?: string
    paymentIntentId?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringNullableFilter<"Booking"> | string | null
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringFilter<"Booking"> | string
    country?: StringNullableFilter<"Booking"> | string | null
    packageId?: IntNullableFilter<"Booking"> | number | null
    destinationId?: IntNullableFilter<"Booking"> | number | null
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    numberOfTravelers?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    travelDateFrom?: DateTimeFilter<"Booking"> | Date | string
    travelDateTo?: DateTimeFilter<"Booking"> | Date | string
    pricePerPerson?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    paymentReference?: StringNullableFilter<"Booking"> | string | null
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    adminNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
  }, "id" | "confirmationNumber" | "paymentIntentId">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    confirmationNumber?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    country?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    destinationId?: SortOrderInput | SortOrder
    bookingType?: SortOrder
    numberOfTravelers?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    travelDateFrom?: SortOrder
    travelDateTo?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentReference?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    confirmationNumber?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    firstName?: StringWithAggregatesFilter<"Booking"> | string
    lastName?: StringWithAggregatesFilter<"Booking"> | string
    email?: StringWithAggregatesFilter<"Booking"> | string
    phone?: StringWithAggregatesFilter<"Booking"> | string
    country?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    packageId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    destinationId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    bookingType?: EnumBookingTypeWithAggregatesFilter<"Booking"> | $Enums.BookingType
    numberOfTravelers?: IntWithAggregatesFilter<"Booking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    travelDateFrom?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    travelDateTo?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    pricePerPerson?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Booking"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    paymentReference?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type ContactInquiryWhereInput = {
    AND?: ContactInquiryWhereInput | ContactInquiryWhereInput[]
    OR?: ContactInquiryWhereInput[]
    NOT?: ContactInquiryWhereInput | ContactInquiryWhereInput[]
    id?: IntFilter<"ContactInquiry"> | number
    name?: StringFilter<"ContactInquiry"> | string
    email?: StringFilter<"ContactInquiry"> | string
    subject?: StringFilter<"ContactInquiry"> | string
    message?: StringFilter<"ContactInquiry"> | string
    status?: EnumInquiryStatusFilter<"ContactInquiry"> | $Enums.InquiryStatus
    responseNotes?: StringNullableFilter<"ContactInquiry"> | string | null
    createdAt?: DateTimeFilter<"ContactInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInquiry"> | Date | string
  }

  export type ContactInquiryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responseNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactInquiryWhereInput | ContactInquiryWhereInput[]
    OR?: ContactInquiryWhereInput[]
    NOT?: ContactInquiryWhereInput | ContactInquiryWhereInput[]
    name?: StringFilter<"ContactInquiry"> | string
    email?: StringFilter<"ContactInquiry"> | string
    subject?: StringFilter<"ContactInquiry"> | string
    message?: StringFilter<"ContactInquiry"> | string
    status?: EnumInquiryStatusFilter<"ContactInquiry"> | $Enums.InquiryStatus
    responseNotes?: StringNullableFilter<"ContactInquiry"> | string | null
    createdAt?: DateTimeFilter<"ContactInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInquiry"> | Date | string
  }, "id">

  export type ContactInquiryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responseNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactInquiryCountOrderByAggregateInput
    _avg?: ContactInquiryAvgOrderByAggregateInput
    _max?: ContactInquiryMaxOrderByAggregateInput
    _min?: ContactInquiryMinOrderByAggregateInput
    _sum?: ContactInquirySumOrderByAggregateInput
  }

  export type ContactInquiryScalarWhereWithAggregatesInput = {
    AND?: ContactInquiryScalarWhereWithAggregatesInput | ContactInquiryScalarWhereWithAggregatesInput[]
    OR?: ContactInquiryScalarWhereWithAggregatesInput[]
    NOT?: ContactInquiryScalarWhereWithAggregatesInput | ContactInquiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactInquiry"> | number
    name?: StringWithAggregatesFilter<"ContactInquiry"> | string
    email?: StringWithAggregatesFilter<"ContactInquiry"> | string
    subject?: StringWithAggregatesFilter<"ContactInquiry"> | string
    message?: StringWithAggregatesFilter<"ContactInquiry"> | string
    status?: EnumInquiryStatusWithAggregatesFilter<"ContactInquiry"> | $Enums.InquiryStatus
    responseNotes?: StringNullableWithAggregatesFilter<"ContactInquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactInquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactInquiry"> | Date | string
  }

  export type NewsletterSubscriptionWhereInput = {
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    id?: IntFilter<"NewsletterSubscription"> | number
    email?: StringFilter<"NewsletterSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"NewsletterSubscription"> | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    unsubscribedAt?: DateTimeNullableFilter<"NewsletterSubscription"> | Date | string | null
  }

  export type NewsletterSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    status?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
  }

  export type NewsletterSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    status?: EnumSubscriptionStatusFilter<"NewsletterSubscription"> | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    unsubscribedAt?: DateTimeNullableFilter<"NewsletterSubscription"> | Date | string | null
  }, "id" | "email">

  export type NewsletterSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    status?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
    _count?: NewsletterSubscriptionCountOrderByAggregateInput
    _avg?: NewsletterSubscriptionAvgOrderByAggregateInput
    _max?: NewsletterSubscriptionMaxOrderByAggregateInput
    _min?: NewsletterSubscriptionMinOrderByAggregateInput
    _sum?: NewsletterSubscriptionSumOrderByAggregateInput
  }

  export type NewsletterSubscriptionScalarWhereWithAggregatesInput = {
    AND?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    OR?: NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NewsletterSubscription"> | number
    email?: StringWithAggregatesFilter<"NewsletterSubscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"NewsletterSubscription"> | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeWithAggregatesFilter<"NewsletterSubscription"> | Date | string
    unsubscribedAt?: DateTimeNullableWithAggregatesFilter<"NewsletterSubscription"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    favorites?: UserFavoriteListRelationFilter
    customPackages?: CustomPackageListRelationFilter
    packageBundles?: PackageBundleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    favorites?: UserFavoriteOrderByRelationAggregateInput
    customPackages?: CustomPackageOrderByRelationAggregateInput
    packageBundles?: PackageBundleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    favorites?: UserFavoriteListRelationFilter
    customPackages?: CustomPackageListRelationFilter
    packageBundles?: PackageBundleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    id?: IntFilter<"UserFavorite"> | number
    userId?: StringFilter<"UserFavorite"> | string
    destinationId?: IntFilter<"UserFavorite"> | number
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_destinationId?: UserFavoriteUserIdDestinationIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    destinationId?: IntFilter<"UserFavorite"> | number
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_destinationId">

  export type UserFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _avg?: UserFavoriteAvgOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
    _sum?: UserFavoriteSumOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserFavorite"> | number
    userId?: StringWithAggregatesFilter<"UserFavorite"> | string
    destinationId?: IntWithAggregatesFilter<"UserFavorite"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: IntFilter<"Package"> | number
    name?: StringFilter<"Package"> | string
    slug?: StringFilter<"Package"> | string
    category?: StringFilter<"Package"> | string
    duration?: StringFilter<"Package"> | string
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Package"> | string
    shortDesc?: StringNullableFilter<"Package"> | string | null
    image?: StringFilter<"Package"> | string
    images?: StringNullableListFilter<"Package">
    gallery2Images?: StringNullableListFilter<"Package">
    highlights?: StringNullableListFilter<"Package">
    itinerary?: JsonFilter<"Package">
    included?: StringNullableListFilter<"Package">
    excluded?: StringNullableListFilter<"Package">
    minTravelers?: IntFilter<"Package"> | number
    maxTravelers?: IntFilter<"Package"> | number
    difficulty?: EnumDifficultyLevelFilter<"Package"> | $Enums.DifficultyLevel
    featured?: BoolFilter<"Package"> | boolean
    popular?: BoolFilter<"Package"> | boolean
    active?: BoolFilter<"Package"> | boolean
    displayOrder?: IntFilter<"Package"> | number
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    bookings?: BookingListRelationFilter
    bundleItems?: PackageBundleItemListRelationFilter
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrderInput | SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    included?: SortOrder
    excluded?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    difficulty?: SortOrder
    featured?: SortOrder
    popular?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    bundleItems?: PackageBundleItemOrderByRelationAggregateInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    name?: StringFilter<"Package"> | string
    category?: StringFilter<"Package"> | string
    duration?: StringFilter<"Package"> | string
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Package"> | string
    shortDesc?: StringNullableFilter<"Package"> | string | null
    image?: StringFilter<"Package"> | string
    images?: StringNullableListFilter<"Package">
    gallery2Images?: StringNullableListFilter<"Package">
    highlights?: StringNullableListFilter<"Package">
    itinerary?: JsonFilter<"Package">
    included?: StringNullableListFilter<"Package">
    excluded?: StringNullableListFilter<"Package">
    minTravelers?: IntFilter<"Package"> | number
    maxTravelers?: IntFilter<"Package"> | number
    difficulty?: EnumDifficultyLevelFilter<"Package"> | $Enums.DifficultyLevel
    featured?: BoolFilter<"Package"> | boolean
    popular?: BoolFilter<"Package"> | boolean
    active?: BoolFilter<"Package"> | boolean
    displayOrder?: IntFilter<"Package"> | number
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    bookings?: BookingListRelationFilter
    bundleItems?: PackageBundleItemListRelationFilter
  }, "id" | "slug">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrderInput | SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    included?: SortOrder
    excluded?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    difficulty?: SortOrder
    featured?: SortOrder
    popular?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Package"> | number
    name?: StringWithAggregatesFilter<"Package"> | string
    slug?: StringWithAggregatesFilter<"Package"> | string
    category?: StringWithAggregatesFilter<"Package"> | string
    duration?: StringWithAggregatesFilter<"Package"> | string
    price?: DecimalWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"Package"> | string
    shortDesc?: StringNullableWithAggregatesFilter<"Package"> | string | null
    image?: StringWithAggregatesFilter<"Package"> | string
    images?: StringNullableListFilter<"Package">
    gallery2Images?: StringNullableListFilter<"Package">
    highlights?: StringNullableListFilter<"Package">
    itinerary?: JsonWithAggregatesFilter<"Package">
    included?: StringNullableListFilter<"Package">
    excluded?: StringNullableListFilter<"Package">
    minTravelers?: IntWithAggregatesFilter<"Package"> | number
    maxTravelers?: IntWithAggregatesFilter<"Package"> | number
    difficulty?: EnumDifficultyLevelWithAggregatesFilter<"Package"> | $Enums.DifficultyLevel
    featured?: BoolWithAggregatesFilter<"Package"> | boolean
    popular?: BoolWithAggregatesFilter<"Package"> | boolean
    active?: BoolWithAggregatesFilter<"Package"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Package"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
  }

  export type CustomPackageWhereInput = {
    AND?: CustomPackageWhereInput | CustomPackageWhereInput[]
    OR?: CustomPackageWhereInput[]
    NOT?: CustomPackageWhereInput | CustomPackageWhereInput[]
    id?: IntFilter<"CustomPackage"> | number
    userId?: StringFilter<"CustomPackage"> | string
    name?: StringFilter<"CustomPackage"> | string
    contactName?: StringFilter<"CustomPackage"> | string
    email?: StringFilter<"CustomPackage"> | string
    phone?: StringFilter<"CustomPackage"> | string
    destinations?: JsonFilter<"CustomPackage">
    duration?: StringNullableFilter<"CustomPackage"> | string | null
    numberOfPeople?: IntFilter<"CustomPackage"> | number
    travelDate?: DateTimeNullableFilter<"CustomPackage"> | Date | string | null
    specialRequests?: StringNullableFilter<"CustomPackage"> | string | null
    budget?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFilter<"CustomPackage"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"CustomPackage"> | string | null
    createdAt?: DateTimeFilter<"CustomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPackage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CustomPackageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    destinations?: SortOrder
    duration?: SortOrderInput | SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    quoteNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CustomPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomPackageWhereInput | CustomPackageWhereInput[]
    OR?: CustomPackageWhereInput[]
    NOT?: CustomPackageWhereInput | CustomPackageWhereInput[]
    userId?: StringFilter<"CustomPackage"> | string
    name?: StringFilter<"CustomPackage"> | string
    contactName?: StringFilter<"CustomPackage"> | string
    email?: StringFilter<"CustomPackage"> | string
    phone?: StringFilter<"CustomPackage"> | string
    destinations?: JsonFilter<"CustomPackage">
    duration?: StringNullableFilter<"CustomPackage"> | string | null
    numberOfPeople?: IntFilter<"CustomPackage"> | number
    travelDate?: DateTimeNullableFilter<"CustomPackage"> | Date | string | null
    specialRequests?: StringNullableFilter<"CustomPackage"> | string | null
    budget?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFilter<"CustomPackage"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"CustomPackage"> | string | null
    createdAt?: DateTimeFilter<"CustomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPackage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CustomPackageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    destinations?: SortOrder
    duration?: SortOrderInput | SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    quoteNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomPackageCountOrderByAggregateInput
    _avg?: CustomPackageAvgOrderByAggregateInput
    _max?: CustomPackageMaxOrderByAggregateInput
    _min?: CustomPackageMinOrderByAggregateInput
    _sum?: CustomPackageSumOrderByAggregateInput
  }

  export type CustomPackageScalarWhereWithAggregatesInput = {
    AND?: CustomPackageScalarWhereWithAggregatesInput | CustomPackageScalarWhereWithAggregatesInput[]
    OR?: CustomPackageScalarWhereWithAggregatesInput[]
    NOT?: CustomPackageScalarWhereWithAggregatesInput | CustomPackageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomPackage"> | number
    userId?: StringWithAggregatesFilter<"CustomPackage"> | string
    name?: StringWithAggregatesFilter<"CustomPackage"> | string
    contactName?: StringWithAggregatesFilter<"CustomPackage"> | string
    email?: StringWithAggregatesFilter<"CustomPackage"> | string
    phone?: StringWithAggregatesFilter<"CustomPackage"> | string
    destinations?: JsonWithAggregatesFilter<"CustomPackage">
    duration?: StringNullableWithAggregatesFilter<"CustomPackage"> | string | null
    numberOfPeople?: IntWithAggregatesFilter<"CustomPackage"> | number
    travelDate?: DateTimeNullableWithAggregatesFilter<"CustomPackage"> | Date | string | null
    specialRequests?: StringNullableWithAggregatesFilter<"CustomPackage"> | string | null
    budget?: DecimalNullableWithAggregatesFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusWithAggregatesFilter<"CustomPackage"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableWithAggregatesFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableWithAggregatesFilter<"CustomPackage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomPackage"> | Date | string
  }

  export type PackageBundleWhereInput = {
    AND?: PackageBundleWhereInput | PackageBundleWhereInput[]
    OR?: PackageBundleWhereInput[]
    NOT?: PackageBundleWhereInput | PackageBundleWhereInput[]
    id?: IntFilter<"PackageBundle"> | number
    userId?: StringFilter<"PackageBundle"> | string
    name?: StringNullableFilter<"PackageBundle"> | string | null
    numberOfPeople?: IntFilter<"PackageBundle"> | number
    travelDate?: DateTimeNullableFilter<"PackageBundle"> | Date | string | null
    specialRequests?: StringNullableFilter<"PackageBundle"> | string | null
    status?: EnumCustomPackageStatusFilter<"PackageBundle"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"PackageBundle"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"PackageBundle"> | string | null
    createdAt?: DateTimeFilter<"PackageBundle"> | Date | string
    updatedAt?: DateTimeFilter<"PackageBundle"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    packages?: PackageBundleItemListRelationFilter
  }

  export type PackageBundleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    quoteNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    packages?: PackageBundleItemOrderByRelationAggregateInput
  }

  export type PackageBundleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PackageBundleWhereInput | PackageBundleWhereInput[]
    OR?: PackageBundleWhereInput[]
    NOT?: PackageBundleWhereInput | PackageBundleWhereInput[]
    userId?: StringFilter<"PackageBundle"> | string
    name?: StringNullableFilter<"PackageBundle"> | string | null
    numberOfPeople?: IntFilter<"PackageBundle"> | number
    travelDate?: DateTimeNullableFilter<"PackageBundle"> | Date | string | null
    specialRequests?: StringNullableFilter<"PackageBundle"> | string | null
    status?: EnumCustomPackageStatusFilter<"PackageBundle"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"PackageBundle"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"PackageBundle"> | string | null
    createdAt?: DateTimeFilter<"PackageBundle"> | Date | string
    updatedAt?: DateTimeFilter<"PackageBundle"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    packages?: PackageBundleItemListRelationFilter
  }, "id">

  export type PackageBundleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    quoteNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageBundleCountOrderByAggregateInput
    _avg?: PackageBundleAvgOrderByAggregateInput
    _max?: PackageBundleMaxOrderByAggregateInput
    _min?: PackageBundleMinOrderByAggregateInput
    _sum?: PackageBundleSumOrderByAggregateInput
  }

  export type PackageBundleScalarWhereWithAggregatesInput = {
    AND?: PackageBundleScalarWhereWithAggregatesInput | PackageBundleScalarWhereWithAggregatesInput[]
    OR?: PackageBundleScalarWhereWithAggregatesInput[]
    NOT?: PackageBundleScalarWhereWithAggregatesInput | PackageBundleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PackageBundle"> | number
    userId?: StringWithAggregatesFilter<"PackageBundle"> | string
    name?: StringNullableWithAggregatesFilter<"PackageBundle"> | string | null
    numberOfPeople?: IntWithAggregatesFilter<"PackageBundle"> | number
    travelDate?: DateTimeNullableWithAggregatesFilter<"PackageBundle"> | Date | string | null
    specialRequests?: StringNullableWithAggregatesFilter<"PackageBundle"> | string | null
    status?: EnumCustomPackageStatusWithAggregatesFilter<"PackageBundle"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableWithAggregatesFilter<"PackageBundle"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableWithAggregatesFilter<"PackageBundle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PackageBundle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackageBundle"> | Date | string
  }

  export type PackageBundleItemWhereInput = {
    AND?: PackageBundleItemWhereInput | PackageBundleItemWhereInput[]
    OR?: PackageBundleItemWhereInput[]
    NOT?: PackageBundleItemWhereInput | PackageBundleItemWhereInput[]
    id?: IntFilter<"PackageBundleItem"> | number
    bundleId?: IntFilter<"PackageBundleItem"> | number
    packageId?: IntFilter<"PackageBundleItem"> | number
    notes?: StringNullableFilter<"PackageBundleItem"> | string | null
    bundle?: XOR<PackageBundleScalarRelationFilter, PackageBundleWhereInput>
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
  }

  export type PackageBundleItemOrderByWithRelationInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
    notes?: SortOrderInput | SortOrder
    bundle?: PackageBundleOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
  }

  export type PackageBundleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bundleId_packageId?: PackageBundleItemBundleIdPackageIdCompoundUniqueInput
    AND?: PackageBundleItemWhereInput | PackageBundleItemWhereInput[]
    OR?: PackageBundleItemWhereInput[]
    NOT?: PackageBundleItemWhereInput | PackageBundleItemWhereInput[]
    bundleId?: IntFilter<"PackageBundleItem"> | number
    packageId?: IntFilter<"PackageBundleItem"> | number
    notes?: StringNullableFilter<"PackageBundleItem"> | string | null
    bundle?: XOR<PackageBundleScalarRelationFilter, PackageBundleWhereInput>
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
  }, "id" | "bundleId_packageId">

  export type PackageBundleItemOrderByWithAggregationInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PackageBundleItemCountOrderByAggregateInput
    _avg?: PackageBundleItemAvgOrderByAggregateInput
    _max?: PackageBundleItemMaxOrderByAggregateInput
    _min?: PackageBundleItemMinOrderByAggregateInput
    _sum?: PackageBundleItemSumOrderByAggregateInput
  }

  export type PackageBundleItemScalarWhereWithAggregatesInput = {
    AND?: PackageBundleItemScalarWhereWithAggregatesInput | PackageBundleItemScalarWhereWithAggregatesInput[]
    OR?: PackageBundleItemScalarWhereWithAggregatesInput[]
    NOT?: PackageBundleItemScalarWhereWithAggregatesInput | PackageBundleItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PackageBundleItem"> | number
    bundleId?: IntWithAggregatesFilter<"PackageBundleItem"> | number
    packageId?: IntWithAggregatesFilter<"PackageBundleItem"> | number
    notes?: StringNullableWithAggregatesFilter<"PackageBundleItem"> | string | null
  }

  export type CMSImageWhereInput = {
    AND?: CMSImageWhereInput | CMSImageWhereInput[]
    OR?: CMSImageWhereInput[]
    NOT?: CMSImageWhereInput | CMSImageWhereInput[]
    id?: StringFilter<"CMSImage"> | string
    filename?: StringFilter<"CMSImage"> | string
    url?: StringFilter<"CMSImage"> | string
    altText?: StringNullableFilter<"CMSImage"> | string | null
    category?: StringNullableFilter<"CMSImage"> | string | null
    width?: IntFilter<"CMSImage"> | number
    height?: IntFilter<"CMSImage"> | number
    fileSize?: IntFilter<"CMSImage"> | number
    format?: StringFilter<"CMSImage"> | string
    usedIn?: JsonNullableFilter<"CMSImage">
    createdAt?: DateTimeFilter<"CMSImage"> | Date | string
    updatedAt?: DateTimeFilter<"CMSImage"> | Date | string
  }

  export type CMSImageOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    usedIn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CMSImageWhereInput | CMSImageWhereInput[]
    OR?: CMSImageWhereInput[]
    NOT?: CMSImageWhereInput | CMSImageWhereInput[]
    filename?: StringFilter<"CMSImage"> | string
    url?: StringFilter<"CMSImage"> | string
    altText?: StringNullableFilter<"CMSImage"> | string | null
    category?: StringNullableFilter<"CMSImage"> | string | null
    width?: IntFilter<"CMSImage"> | number
    height?: IntFilter<"CMSImage"> | number
    fileSize?: IntFilter<"CMSImage"> | number
    format?: StringFilter<"CMSImage"> | string
    usedIn?: JsonNullableFilter<"CMSImage">
    createdAt?: DateTimeFilter<"CMSImage"> | Date | string
    updatedAt?: DateTimeFilter<"CMSImage"> | Date | string
  }, "id">

  export type CMSImageOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    usedIn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CMSImageCountOrderByAggregateInput
    _avg?: CMSImageAvgOrderByAggregateInput
    _max?: CMSImageMaxOrderByAggregateInput
    _min?: CMSImageMinOrderByAggregateInput
    _sum?: CMSImageSumOrderByAggregateInput
  }

  export type CMSImageScalarWhereWithAggregatesInput = {
    AND?: CMSImageScalarWhereWithAggregatesInput | CMSImageScalarWhereWithAggregatesInput[]
    OR?: CMSImageScalarWhereWithAggregatesInput[]
    NOT?: CMSImageScalarWhereWithAggregatesInput | CMSImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CMSImage"> | string
    filename?: StringWithAggregatesFilter<"CMSImage"> | string
    url?: StringWithAggregatesFilter<"CMSImage"> | string
    altText?: StringNullableWithAggregatesFilter<"CMSImage"> | string | null
    category?: StringNullableWithAggregatesFilter<"CMSImage"> | string | null
    width?: IntWithAggregatesFilter<"CMSImage"> | number
    height?: IntWithAggregatesFilter<"CMSImage"> | number
    fileSize?: IntWithAggregatesFilter<"CMSImage"> | number
    format?: StringWithAggregatesFilter<"CMSImage"> | string
    usedIn?: JsonNullableWithAggregatesFilter<"CMSImage">
    createdAt?: DateTimeWithAggregatesFilter<"CMSImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CMSImage"> | Date | string
  }

  export type HeroSlideWhereInput = {
    AND?: HeroSlideWhereInput | HeroSlideWhereInput[]
    OR?: HeroSlideWhereInput[]
    NOT?: HeroSlideWhereInput | HeroSlideWhereInput[]
    id?: StringFilter<"HeroSlide"> | string
    title?: StringFilter<"HeroSlide"> | string
    subtitle?: StringFilter<"HeroSlide"> | string
    description?: StringFilter<"HeroSlide"> | string
    image?: StringFilter<"HeroSlide"> | string
    displayOrder?: IntFilter<"HeroSlide"> | number
    active?: BoolFilter<"HeroSlide"> | boolean
    createdAt?: DateTimeFilter<"HeroSlide"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSlide"> | Date | string
  }

  export type HeroSlideOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    image?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroSlideWhereInput | HeroSlideWhereInput[]
    OR?: HeroSlideWhereInput[]
    NOT?: HeroSlideWhereInput | HeroSlideWhereInput[]
    title?: StringFilter<"HeroSlide"> | string
    subtitle?: StringFilter<"HeroSlide"> | string
    description?: StringFilter<"HeroSlide"> | string
    image?: StringFilter<"HeroSlide"> | string
    displayOrder?: IntFilter<"HeroSlide"> | number
    active?: BoolFilter<"HeroSlide"> | boolean
    createdAt?: DateTimeFilter<"HeroSlide"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSlide"> | Date | string
  }, "id">

  export type HeroSlideOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    image?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroSlideCountOrderByAggregateInput
    _avg?: HeroSlideAvgOrderByAggregateInput
    _max?: HeroSlideMaxOrderByAggregateInput
    _min?: HeroSlideMinOrderByAggregateInput
    _sum?: HeroSlideSumOrderByAggregateInput
  }

  export type HeroSlideScalarWhereWithAggregatesInput = {
    AND?: HeroSlideScalarWhereWithAggregatesInput | HeroSlideScalarWhereWithAggregatesInput[]
    OR?: HeroSlideScalarWhereWithAggregatesInput[]
    NOT?: HeroSlideScalarWhereWithAggregatesInput | HeroSlideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroSlide"> | string
    title?: StringWithAggregatesFilter<"HeroSlide"> | string
    subtitle?: StringWithAggregatesFilter<"HeroSlide"> | string
    description?: StringWithAggregatesFilter<"HeroSlide"> | string
    image?: StringWithAggregatesFilter<"HeroSlide"> | string
    displayOrder?: IntWithAggregatesFilter<"HeroSlide"> | number
    active?: BoolWithAggregatesFilter<"HeroSlide"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HeroSlide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroSlide"> | Date | string
  }

  export type CMSDestinationWhereInput = {
    AND?: CMSDestinationWhereInput | CMSDestinationWhereInput[]
    OR?: CMSDestinationWhereInput[]
    NOT?: CMSDestinationWhereInput | CMSDestinationWhereInput[]
    id?: StringFilter<"CMSDestination"> | string
    name?: StringFilter<"CMSDestination"> | string
    slug?: StringFilter<"CMSDestination"> | string
    category?: StringFilter<"CMSDestination"> | string
    region?: StringFilter<"CMSDestination"> | string
    country?: StringFilter<"CMSDestination"> | string
    description?: StringFilter<"CMSDestination"> | string
    shortDesc?: StringNullableFilter<"CMSDestination"> | string | null
    heroImage?: StringFilter<"CMSDestination"> | string
    gallery?: JsonFilter<"CMSDestination">
    history?: StringNullableFilter<"CMSDestination"> | string | null
    geography?: StringNullableFilter<"CMSDestination"> | string | null
    climate?: StringNullableFilter<"CMSDestination"> | string | null
    wildlife?: StringNullableFilter<"CMSDestination"> | string | null
    keyWildlife?: JsonNullableFilter<"CMSDestination">
    flora?: JsonNullableFilter<"CMSDestination">
    cultural?: JsonNullableFilter<"CMSDestination">
    bestTime?: StringNullableFilter<"CMSDestination"> | string | null
    featured?: BoolFilter<"CMSDestination"> | boolean
    active?: BoolFilter<"CMSDestination"> | boolean
    displayOrder?: IntFilter<"CMSDestination"> | number
    createdAt?: DateTimeFilter<"CMSDestination"> | Date | string
    updatedAt?: DateTimeFilter<"CMSDestination"> | Date | string
  }

  export type CMSDestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    region?: SortOrder
    country?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrderInput | SortOrder
    heroImage?: SortOrder
    gallery?: SortOrder
    history?: SortOrderInput | SortOrder
    geography?: SortOrderInput | SortOrder
    climate?: SortOrderInput | SortOrder
    wildlife?: SortOrderInput | SortOrder
    keyWildlife?: SortOrderInput | SortOrder
    flora?: SortOrderInput | SortOrder
    cultural?: SortOrderInput | SortOrder
    bestTime?: SortOrderInput | SortOrder
    featured?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSDestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CMSDestinationWhereInput | CMSDestinationWhereInput[]
    OR?: CMSDestinationWhereInput[]
    NOT?: CMSDestinationWhereInput | CMSDestinationWhereInput[]
    name?: StringFilter<"CMSDestination"> | string
    category?: StringFilter<"CMSDestination"> | string
    region?: StringFilter<"CMSDestination"> | string
    country?: StringFilter<"CMSDestination"> | string
    description?: StringFilter<"CMSDestination"> | string
    shortDesc?: StringNullableFilter<"CMSDestination"> | string | null
    heroImage?: StringFilter<"CMSDestination"> | string
    gallery?: JsonFilter<"CMSDestination">
    history?: StringNullableFilter<"CMSDestination"> | string | null
    geography?: StringNullableFilter<"CMSDestination"> | string | null
    climate?: StringNullableFilter<"CMSDestination"> | string | null
    wildlife?: StringNullableFilter<"CMSDestination"> | string | null
    keyWildlife?: JsonNullableFilter<"CMSDestination">
    flora?: JsonNullableFilter<"CMSDestination">
    cultural?: JsonNullableFilter<"CMSDestination">
    bestTime?: StringNullableFilter<"CMSDestination"> | string | null
    featured?: BoolFilter<"CMSDestination"> | boolean
    active?: BoolFilter<"CMSDestination"> | boolean
    displayOrder?: IntFilter<"CMSDestination"> | number
    createdAt?: DateTimeFilter<"CMSDestination"> | Date | string
    updatedAt?: DateTimeFilter<"CMSDestination"> | Date | string
  }, "id" | "slug">

  export type CMSDestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    region?: SortOrder
    country?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrderInput | SortOrder
    heroImage?: SortOrder
    gallery?: SortOrder
    history?: SortOrderInput | SortOrder
    geography?: SortOrderInput | SortOrder
    climate?: SortOrderInput | SortOrder
    wildlife?: SortOrderInput | SortOrder
    keyWildlife?: SortOrderInput | SortOrder
    flora?: SortOrderInput | SortOrder
    cultural?: SortOrderInput | SortOrder
    bestTime?: SortOrderInput | SortOrder
    featured?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CMSDestinationCountOrderByAggregateInput
    _avg?: CMSDestinationAvgOrderByAggregateInput
    _max?: CMSDestinationMaxOrderByAggregateInput
    _min?: CMSDestinationMinOrderByAggregateInput
    _sum?: CMSDestinationSumOrderByAggregateInput
  }

  export type CMSDestinationScalarWhereWithAggregatesInput = {
    AND?: CMSDestinationScalarWhereWithAggregatesInput | CMSDestinationScalarWhereWithAggregatesInput[]
    OR?: CMSDestinationScalarWhereWithAggregatesInput[]
    NOT?: CMSDestinationScalarWhereWithAggregatesInput | CMSDestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CMSDestination"> | string
    name?: StringWithAggregatesFilter<"CMSDestination"> | string
    slug?: StringWithAggregatesFilter<"CMSDestination"> | string
    category?: StringWithAggregatesFilter<"CMSDestination"> | string
    region?: StringWithAggregatesFilter<"CMSDestination"> | string
    country?: StringWithAggregatesFilter<"CMSDestination"> | string
    description?: StringWithAggregatesFilter<"CMSDestination"> | string
    shortDesc?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    heroImage?: StringWithAggregatesFilter<"CMSDestination"> | string
    gallery?: JsonWithAggregatesFilter<"CMSDestination">
    history?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    geography?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    climate?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    wildlife?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    keyWildlife?: JsonNullableWithAggregatesFilter<"CMSDestination">
    flora?: JsonNullableWithAggregatesFilter<"CMSDestination">
    cultural?: JsonNullableWithAggregatesFilter<"CMSDestination">
    bestTime?: StringNullableWithAggregatesFilter<"CMSDestination"> | string | null
    featured?: BoolWithAggregatesFilter<"CMSDestination"> | boolean
    active?: BoolWithAggregatesFilter<"CMSDestination"> | boolean
    displayOrder?: IntWithAggregatesFilter<"CMSDestination"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CMSDestination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CMSDestination"> | Date | string
  }

  export type SiteSettingsWhereInput = {
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    id?: StringFilter<"SiteSettings"> | string
    key?: StringFilter<"SiteSettings"> | string
    value?: JsonFilter<"SiteSettings">
    category?: StringNullableFilter<"SiteSettings"> | string | null
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SiteSettings"> | string | null
  }

  export type SiteSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type SiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    value?: JsonFilter<"SiteSettings">
    category?: StringNullableFilter<"SiteSettings"> | string | null
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SiteSettings"> | string | null
  }, "id" | "key">

  export type SiteSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SiteSettingsCountOrderByAggregateInput
    _max?: SiteSettingsMaxOrderByAggregateInput
    _min?: SiteSettingsMinOrderByAggregateInput
  }

  export type SiteSettingsScalarWhereWithAggregatesInput = {
    AND?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    OR?: SiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteSettings"> | string
    key?: StringWithAggregatesFilter<"SiteSettings"> | string
    value?: JsonWithAggregatesFilter<"SiteSettings">
    category?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    bio?: StringFilter<"TeamMember"> | string
    image?: StringFilter<"TeamMember"> | string
    years?: StringFilter<"TeamMember"> | string
    specialties?: JsonFilter<"TeamMember">
    displayOrder?: IntFilter<"TeamMember"> | number
    active?: BoolFilter<"TeamMember"> | boolean
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    years?: SortOrder
    specialties?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    bio?: StringFilter<"TeamMember"> | string
    image?: StringFilter<"TeamMember"> | string
    years?: StringFilter<"TeamMember"> | string
    specialties?: JsonFilter<"TeamMember">
    displayOrder?: IntFilter<"TeamMember"> | number
    active?: BoolFilter<"TeamMember"> | boolean
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }, "id">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    years?: SortOrder
    specialties?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    name?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    bio?: StringWithAggregatesFilter<"TeamMember"> | string
    image?: StringWithAggregatesFilter<"TeamMember"> | string
    years?: StringWithAggregatesFilter<"TeamMember"> | string
    specialties?: JsonWithAggregatesFilter<"TeamMember">
    displayOrder?: IntWithAggregatesFilter<"TeamMember"> | number
    active?: BoolWithAggregatesFilter<"TeamMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: StringFilter<"FAQ"> | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringNullableFilter<"FAQ"> | string | null
    displayOrder?: IntFilter<"FAQ"> | number
    active?: BoolFilter<"FAQ"> | boolean
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringNullableFilter<"FAQ"> | string | null
    displayOrder?: IntFilter<"FAQ"> | number
    active?: BoolFilter<"FAQ"> | boolean
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _avg?: FAQAvgOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
    _sum?: FAQSumOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQ"> | string
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
    category?: StringNullableWithAggregatesFilter<"FAQ"> | string | null
    displayOrder?: IntWithAggregatesFilter<"FAQ"> | number
    active?: BoolWithAggregatesFilter<"FAQ"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
  }

  export type CMSAuditLogWhereInput = {
    AND?: CMSAuditLogWhereInput | CMSAuditLogWhereInput[]
    OR?: CMSAuditLogWhereInput[]
    NOT?: CMSAuditLogWhereInput | CMSAuditLogWhereInput[]
    id?: StringFilter<"CMSAuditLog"> | string
    userId?: StringFilter<"CMSAuditLog"> | string
    userName?: StringNullableFilter<"CMSAuditLog"> | string | null
    action?: StringFilter<"CMSAuditLog"> | string
    entityType?: StringFilter<"CMSAuditLog"> | string
    entityId?: StringFilter<"CMSAuditLog"> | string
    changes?: JsonNullableFilter<"CMSAuditLog">
    ipAddress?: StringNullableFilter<"CMSAuditLog"> | string | null
    userAgent?: StringNullableFilter<"CMSAuditLog"> | string | null
    createdAt?: DateTimeFilter<"CMSAuditLog"> | Date | string
  }

  export type CMSAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CMSAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CMSAuditLogWhereInput | CMSAuditLogWhereInput[]
    OR?: CMSAuditLogWhereInput[]
    NOT?: CMSAuditLogWhereInput | CMSAuditLogWhereInput[]
    userId?: StringFilter<"CMSAuditLog"> | string
    userName?: StringNullableFilter<"CMSAuditLog"> | string | null
    action?: StringFilter<"CMSAuditLog"> | string
    entityType?: StringFilter<"CMSAuditLog"> | string
    entityId?: StringFilter<"CMSAuditLog"> | string
    changes?: JsonNullableFilter<"CMSAuditLog">
    ipAddress?: StringNullableFilter<"CMSAuditLog"> | string | null
    userAgent?: StringNullableFilter<"CMSAuditLog"> | string | null
    createdAt?: DateTimeFilter<"CMSAuditLog"> | Date | string
  }, "id">

  export type CMSAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CMSAuditLogCountOrderByAggregateInput
    _max?: CMSAuditLogMaxOrderByAggregateInput
    _min?: CMSAuditLogMinOrderByAggregateInput
  }

  export type CMSAuditLogScalarWhereWithAggregatesInput = {
    AND?: CMSAuditLogScalarWhereWithAggregatesInput | CMSAuditLogScalarWhereWithAggregatesInput[]
    OR?: CMSAuditLogScalarWhereWithAggregatesInput[]
    NOT?: CMSAuditLogScalarWhereWithAggregatesInput | CMSAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CMSAuditLog"> | string
    userId?: StringWithAggregatesFilter<"CMSAuditLog"> | string
    userName?: StringNullableWithAggregatesFilter<"CMSAuditLog"> | string | null
    action?: StringWithAggregatesFilter<"CMSAuditLog"> | string
    entityType?: StringWithAggregatesFilter<"CMSAuditLog"> | string
    entityId?: StringWithAggregatesFilter<"CMSAuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"CMSAuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"CMSAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"CMSAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CMSAuditLog"> | Date | string
  }

  export type ExperienceSectionWhereInput = {
    AND?: ExperienceSectionWhereInput | ExperienceSectionWhereInput[]
    OR?: ExperienceSectionWhereInput[]
    NOT?: ExperienceSectionWhereInput | ExperienceSectionWhereInput[]
    id?: StringFilter<"ExperienceSection"> | string
    heading?: StringFilter<"ExperienceSection"> | string
    title?: StringFilter<"ExperienceSection"> | string
    description?: StringFilter<"ExperienceSection"> | string
    image?: StringFilter<"ExperienceSection"> | string
    stat1Value?: StringFilter<"ExperienceSection"> | string
    stat1Label?: StringFilter<"ExperienceSection"> | string
    stat2Value?: StringFilter<"ExperienceSection"> | string
    stat2Label?: StringFilter<"ExperienceSection"> | string
    badgeText?: StringFilter<"ExperienceSection"> | string
    backgroundText?: StringFilter<"ExperienceSection"> | string
    status?: EnumContentStatusFilter<"ExperienceSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ExperienceSection"> | Date | string | null
    createdAt?: DateTimeFilter<"ExperienceSection"> | Date | string
    updatedAt?: DateTimeFilter<"ExperienceSection"> | Date | string
  }

  export type ExperienceSectionOrderByWithRelationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    stat1Value?: SortOrder
    stat1Label?: SortOrder
    stat2Value?: SortOrder
    stat2Label?: SortOrder
    badgeText?: SortOrder
    backgroundText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceSectionWhereInput | ExperienceSectionWhereInput[]
    OR?: ExperienceSectionWhereInput[]
    NOT?: ExperienceSectionWhereInput | ExperienceSectionWhereInput[]
    heading?: StringFilter<"ExperienceSection"> | string
    title?: StringFilter<"ExperienceSection"> | string
    description?: StringFilter<"ExperienceSection"> | string
    image?: StringFilter<"ExperienceSection"> | string
    stat1Value?: StringFilter<"ExperienceSection"> | string
    stat1Label?: StringFilter<"ExperienceSection"> | string
    stat2Value?: StringFilter<"ExperienceSection"> | string
    stat2Label?: StringFilter<"ExperienceSection"> | string
    badgeText?: StringFilter<"ExperienceSection"> | string
    backgroundText?: StringFilter<"ExperienceSection"> | string
    status?: EnumContentStatusFilter<"ExperienceSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ExperienceSection"> | Date | string | null
    createdAt?: DateTimeFilter<"ExperienceSection"> | Date | string
    updatedAt?: DateTimeFilter<"ExperienceSection"> | Date | string
  }, "id">

  export type ExperienceSectionOrderByWithAggregationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    stat1Value?: SortOrder
    stat1Label?: SortOrder
    stat2Value?: SortOrder
    stat2Label?: SortOrder
    badgeText?: SortOrder
    backgroundText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExperienceSectionCountOrderByAggregateInput
    _max?: ExperienceSectionMaxOrderByAggregateInput
    _min?: ExperienceSectionMinOrderByAggregateInput
  }

  export type ExperienceSectionScalarWhereWithAggregatesInput = {
    AND?: ExperienceSectionScalarWhereWithAggregatesInput | ExperienceSectionScalarWhereWithAggregatesInput[]
    OR?: ExperienceSectionScalarWhereWithAggregatesInput[]
    NOT?: ExperienceSectionScalarWhereWithAggregatesInput | ExperienceSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExperienceSection"> | string
    heading?: StringWithAggregatesFilter<"ExperienceSection"> | string
    title?: StringWithAggregatesFilter<"ExperienceSection"> | string
    description?: StringWithAggregatesFilter<"ExperienceSection"> | string
    image?: StringWithAggregatesFilter<"ExperienceSection"> | string
    stat1Value?: StringWithAggregatesFilter<"ExperienceSection"> | string
    stat1Label?: StringWithAggregatesFilter<"ExperienceSection"> | string
    stat2Value?: StringWithAggregatesFilter<"ExperienceSection"> | string
    stat2Label?: StringWithAggregatesFilter<"ExperienceSection"> | string
    badgeText?: StringWithAggregatesFilter<"ExperienceSection"> | string
    backgroundText?: StringWithAggregatesFilter<"ExperienceSection"> | string
    status?: EnumContentStatusWithAggregatesFilter<"ExperienceSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ExperienceSection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExperienceSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExperienceSection"> | Date | string
  }

  export type TourGuideSectionWhereInput = {
    AND?: TourGuideSectionWhereInput | TourGuideSectionWhereInput[]
    OR?: TourGuideSectionWhereInput[]
    NOT?: TourGuideSectionWhereInput | TourGuideSectionWhereInput[]
    id?: StringFilter<"TourGuideSection"> | string
    title?: StringFilter<"TourGuideSection"> | string
    subtitle?: StringFilter<"TourGuideSection"> | string
    description?: StringFilter<"TourGuideSection"> | string
    mapImage?: StringFilter<"TourGuideSection"> | string
    buttonText?: StringFilter<"TourGuideSection"> | string
    status?: EnumContentStatusFilter<"TourGuideSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"TourGuideSection"> | Date | string | null
    createdAt?: DateTimeFilter<"TourGuideSection"> | Date | string
    updatedAt?: DateTimeFilter<"TourGuideSection"> | Date | string
  }

  export type TourGuideSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    mapImage?: SortOrder
    buttonText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourGuideSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourGuideSectionWhereInput | TourGuideSectionWhereInput[]
    OR?: TourGuideSectionWhereInput[]
    NOT?: TourGuideSectionWhereInput | TourGuideSectionWhereInput[]
    title?: StringFilter<"TourGuideSection"> | string
    subtitle?: StringFilter<"TourGuideSection"> | string
    description?: StringFilter<"TourGuideSection"> | string
    mapImage?: StringFilter<"TourGuideSection"> | string
    buttonText?: StringFilter<"TourGuideSection"> | string
    status?: EnumContentStatusFilter<"TourGuideSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"TourGuideSection"> | Date | string | null
    createdAt?: DateTimeFilter<"TourGuideSection"> | Date | string
    updatedAt?: DateTimeFilter<"TourGuideSection"> | Date | string
  }, "id">

  export type TourGuideSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    mapImage?: SortOrder
    buttonText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourGuideSectionCountOrderByAggregateInput
    _max?: TourGuideSectionMaxOrderByAggregateInput
    _min?: TourGuideSectionMinOrderByAggregateInput
  }

  export type TourGuideSectionScalarWhereWithAggregatesInput = {
    AND?: TourGuideSectionScalarWhereWithAggregatesInput | TourGuideSectionScalarWhereWithAggregatesInput[]
    OR?: TourGuideSectionScalarWhereWithAggregatesInput[]
    NOT?: TourGuideSectionScalarWhereWithAggregatesInput | TourGuideSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TourGuideSection"> | string
    title?: StringWithAggregatesFilter<"TourGuideSection"> | string
    subtitle?: StringWithAggregatesFilter<"TourGuideSection"> | string
    description?: StringWithAggregatesFilter<"TourGuideSection"> | string
    mapImage?: StringWithAggregatesFilter<"TourGuideSection"> | string
    buttonText?: StringWithAggregatesFilter<"TourGuideSection"> | string
    status?: EnumContentStatusWithAggregatesFilter<"TourGuideSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"TourGuideSection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TourGuideSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TourGuideSection"> | Date | string
  }

  export type VideoSectionWhereInput = {
    AND?: VideoSectionWhereInput | VideoSectionWhereInput[]
    OR?: VideoSectionWhereInput[]
    NOT?: VideoSectionWhereInput | VideoSectionWhereInput[]
    id?: StringFilter<"VideoSection"> | string
    title?: StringFilter<"VideoSection"> | string
    description?: StringFilter<"VideoSection"> | string
    videoUrl?: StringFilter<"VideoSection"> | string
    thumbnailUrl?: StringNullableFilter<"VideoSection"> | string | null
    status?: EnumContentStatusFilter<"VideoSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"VideoSection"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoSection"> | Date | string
    updatedAt?: DateTimeFilter<"VideoSection"> | Date | string
  }

  export type VideoSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoSectionWhereInput | VideoSectionWhereInput[]
    OR?: VideoSectionWhereInput[]
    NOT?: VideoSectionWhereInput | VideoSectionWhereInput[]
    title?: StringFilter<"VideoSection"> | string
    description?: StringFilter<"VideoSection"> | string
    videoUrl?: StringFilter<"VideoSection"> | string
    thumbnailUrl?: StringNullableFilter<"VideoSection"> | string | null
    status?: EnumContentStatusFilter<"VideoSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"VideoSection"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoSection"> | Date | string
    updatedAt?: DateTimeFilter<"VideoSection"> | Date | string
  }, "id">

  export type VideoSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoSectionCountOrderByAggregateInput
    _max?: VideoSectionMaxOrderByAggregateInput
    _min?: VideoSectionMinOrderByAggregateInput
  }

  export type VideoSectionScalarWhereWithAggregatesInput = {
    AND?: VideoSectionScalarWhereWithAggregatesInput | VideoSectionScalarWhereWithAggregatesInput[]
    OR?: VideoSectionScalarWhereWithAggregatesInput[]
    NOT?: VideoSectionScalarWhereWithAggregatesInput | VideoSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoSection"> | string
    title?: StringWithAggregatesFilter<"VideoSection"> | string
    description?: StringWithAggregatesFilter<"VideoSection"> | string
    videoUrl?: StringWithAggregatesFilter<"VideoSection"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"VideoSection"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"VideoSection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"VideoSection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VideoSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoSection"> | Date | string
  }

  export type PackagesHeroWhereInput = {
    AND?: PackagesHeroWhereInput | PackagesHeroWhereInput[]
    OR?: PackagesHeroWhereInput[]
    NOT?: PackagesHeroWhereInput | PackagesHeroWhereInput[]
    id?: StringFilter<"PackagesHero"> | string
    image?: StringFilter<"PackagesHero"> | string
    title?: StringFilter<"PackagesHero"> | string
    subtitle?: StringFilter<"PackagesHero"> | string
    description?: StringFilter<"PackagesHero"> | string
    status?: EnumContentStatusFilter<"PackagesHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"PackagesHero"> | Date | string | null
    createdAt?: DateTimeFilter<"PackagesHero"> | Date | string
    updatedAt?: DateTimeFilter<"PackagesHero"> | Date | string
  }

  export type PackagesHeroOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackagesHeroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackagesHeroWhereInput | PackagesHeroWhereInput[]
    OR?: PackagesHeroWhereInput[]
    NOT?: PackagesHeroWhereInput | PackagesHeroWhereInput[]
    image?: StringFilter<"PackagesHero"> | string
    title?: StringFilter<"PackagesHero"> | string
    subtitle?: StringFilter<"PackagesHero"> | string
    description?: StringFilter<"PackagesHero"> | string
    status?: EnumContentStatusFilter<"PackagesHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"PackagesHero"> | Date | string | null
    createdAt?: DateTimeFilter<"PackagesHero"> | Date | string
    updatedAt?: DateTimeFilter<"PackagesHero"> | Date | string
  }, "id">

  export type PackagesHeroOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackagesHeroCountOrderByAggregateInput
    _max?: PackagesHeroMaxOrderByAggregateInput
    _min?: PackagesHeroMinOrderByAggregateInput
  }

  export type PackagesHeroScalarWhereWithAggregatesInput = {
    AND?: PackagesHeroScalarWhereWithAggregatesInput | PackagesHeroScalarWhereWithAggregatesInput[]
    OR?: PackagesHeroScalarWhereWithAggregatesInput[]
    NOT?: PackagesHeroScalarWhereWithAggregatesInput | PackagesHeroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackagesHero"> | string
    image?: StringWithAggregatesFilter<"PackagesHero"> | string
    title?: StringWithAggregatesFilter<"PackagesHero"> | string
    subtitle?: StringWithAggregatesFilter<"PackagesHero"> | string
    description?: StringWithAggregatesFilter<"PackagesHero"> | string
    status?: EnumContentStatusWithAggregatesFilter<"PackagesHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"PackagesHero"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PackagesHero"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackagesHero"> | Date | string
  }

  export type DestinationsHeroWhereInput = {
    AND?: DestinationsHeroWhereInput | DestinationsHeroWhereInput[]
    OR?: DestinationsHeroWhereInput[]
    NOT?: DestinationsHeroWhereInput | DestinationsHeroWhereInput[]
    id?: StringFilter<"DestinationsHero"> | string
    image?: StringFilter<"DestinationsHero"> | string
    title?: StringFilter<"DestinationsHero"> | string
    subtitle?: StringFilter<"DestinationsHero"> | string
    description?: StringFilter<"DestinationsHero"> | string
    status?: EnumContentStatusFilter<"DestinationsHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"DestinationsHero"> | Date | string | null
    createdAt?: DateTimeFilter<"DestinationsHero"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationsHero"> | Date | string
  }

  export type DestinationsHeroOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsHeroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DestinationsHeroWhereInput | DestinationsHeroWhereInput[]
    OR?: DestinationsHeroWhereInput[]
    NOT?: DestinationsHeroWhereInput | DestinationsHeroWhereInput[]
    image?: StringFilter<"DestinationsHero"> | string
    title?: StringFilter<"DestinationsHero"> | string
    subtitle?: StringFilter<"DestinationsHero"> | string
    description?: StringFilter<"DestinationsHero"> | string
    status?: EnumContentStatusFilter<"DestinationsHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"DestinationsHero"> | Date | string | null
    createdAt?: DateTimeFilter<"DestinationsHero"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationsHero"> | Date | string
  }, "id">

  export type DestinationsHeroOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationsHeroCountOrderByAggregateInput
    _max?: DestinationsHeroMaxOrderByAggregateInput
    _min?: DestinationsHeroMinOrderByAggregateInput
  }

  export type DestinationsHeroScalarWhereWithAggregatesInput = {
    AND?: DestinationsHeroScalarWhereWithAggregatesInput | DestinationsHeroScalarWhereWithAggregatesInput[]
    OR?: DestinationsHeroScalarWhereWithAggregatesInput[]
    NOT?: DestinationsHeroScalarWhereWithAggregatesInput | DestinationsHeroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DestinationsHero"> | string
    image?: StringWithAggregatesFilter<"DestinationsHero"> | string
    title?: StringWithAggregatesFilter<"DestinationsHero"> | string
    subtitle?: StringWithAggregatesFilter<"DestinationsHero"> | string
    description?: StringWithAggregatesFilter<"DestinationsHero"> | string
    status?: EnumContentStatusWithAggregatesFilter<"DestinationsHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"DestinationsHero"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DestinationsHero"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DestinationsHero"> | Date | string
  }

  export type DestinationsCTAWhereInput = {
    AND?: DestinationsCTAWhereInput | DestinationsCTAWhereInput[]
    OR?: DestinationsCTAWhereInput[]
    NOT?: DestinationsCTAWhereInput | DestinationsCTAWhereInput[]
    id?: StringFilter<"DestinationsCTA"> | string
    title?: StringFilter<"DestinationsCTA"> | string
    description?: StringFilter<"DestinationsCTA"> | string
    buttonText?: StringFilter<"DestinationsCTA"> | string
    buttonLink?: StringFilter<"DestinationsCTA"> | string
    status?: EnumContentStatusFilter<"DestinationsCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"DestinationsCTA"> | Date | string | null
    createdAt?: DateTimeFilter<"DestinationsCTA"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationsCTA"> | Date | string
  }

  export type DestinationsCTAOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsCTAWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DestinationsCTAWhereInput | DestinationsCTAWhereInput[]
    OR?: DestinationsCTAWhereInput[]
    NOT?: DestinationsCTAWhereInput | DestinationsCTAWhereInput[]
    title?: StringFilter<"DestinationsCTA"> | string
    description?: StringFilter<"DestinationsCTA"> | string
    buttonText?: StringFilter<"DestinationsCTA"> | string
    buttonLink?: StringFilter<"DestinationsCTA"> | string
    status?: EnumContentStatusFilter<"DestinationsCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"DestinationsCTA"> | Date | string | null
    createdAt?: DateTimeFilter<"DestinationsCTA"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationsCTA"> | Date | string
  }, "id">

  export type DestinationsCTAOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationsCTACountOrderByAggregateInput
    _max?: DestinationsCTAMaxOrderByAggregateInput
    _min?: DestinationsCTAMinOrderByAggregateInput
  }

  export type DestinationsCTAScalarWhereWithAggregatesInput = {
    AND?: DestinationsCTAScalarWhereWithAggregatesInput | DestinationsCTAScalarWhereWithAggregatesInput[]
    OR?: DestinationsCTAScalarWhereWithAggregatesInput[]
    NOT?: DestinationsCTAScalarWhereWithAggregatesInput | DestinationsCTAScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DestinationsCTA"> | string
    title?: StringWithAggregatesFilter<"DestinationsCTA"> | string
    description?: StringWithAggregatesFilter<"DestinationsCTA"> | string
    buttonText?: StringWithAggregatesFilter<"DestinationsCTA"> | string
    buttonLink?: StringWithAggregatesFilter<"DestinationsCTA"> | string
    status?: EnumContentStatusWithAggregatesFilter<"DestinationsCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"DestinationsCTA"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DestinationsCTA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DestinationsCTA"> | Date | string
  }

  export type AboutStorySectionWhereInput = {
    AND?: AboutStorySectionWhereInput | AboutStorySectionWhereInput[]
    OR?: AboutStorySectionWhereInput[]
    NOT?: AboutStorySectionWhereInput | AboutStorySectionWhereInput[]
    id?: StringFilter<"AboutStorySection"> | string
    heading?: StringFilter<"AboutStorySection"> | string
    title?: StringFilter<"AboutStorySection"> | string
    titleHighlight?: StringFilter<"AboutStorySection"> | string
    paragraph1?: StringFilter<"AboutStorySection"> | string
    paragraph2?: StringFilter<"AboutStorySection"> | string
    buttonText?: StringFilter<"AboutStorySection"> | string
    buttonLink?: StringFilter<"AboutStorySection"> | string
    image?: StringFilter<"AboutStorySection"> | string
    status?: EnumContentStatusFilter<"AboutStorySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutStorySection"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutStorySection"> | Date | string
    updatedAt?: DateTimeFilter<"AboutStorySection"> | Date | string
  }

  export type AboutStorySectionOrderByWithRelationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    image?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStorySectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutStorySectionWhereInput | AboutStorySectionWhereInput[]
    OR?: AboutStorySectionWhereInput[]
    NOT?: AboutStorySectionWhereInput | AboutStorySectionWhereInput[]
    heading?: StringFilter<"AboutStorySection"> | string
    title?: StringFilter<"AboutStorySection"> | string
    titleHighlight?: StringFilter<"AboutStorySection"> | string
    paragraph1?: StringFilter<"AboutStorySection"> | string
    paragraph2?: StringFilter<"AboutStorySection"> | string
    buttonText?: StringFilter<"AboutStorySection"> | string
    buttonLink?: StringFilter<"AboutStorySection"> | string
    image?: StringFilter<"AboutStorySection"> | string
    status?: EnumContentStatusFilter<"AboutStorySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutStorySection"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutStorySection"> | Date | string
    updatedAt?: DateTimeFilter<"AboutStorySection"> | Date | string
  }, "id">

  export type AboutStorySectionOrderByWithAggregationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    image?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutStorySectionCountOrderByAggregateInput
    _max?: AboutStorySectionMaxOrderByAggregateInput
    _min?: AboutStorySectionMinOrderByAggregateInput
  }

  export type AboutStorySectionScalarWhereWithAggregatesInput = {
    AND?: AboutStorySectionScalarWhereWithAggregatesInput | AboutStorySectionScalarWhereWithAggregatesInput[]
    OR?: AboutStorySectionScalarWhereWithAggregatesInput[]
    NOT?: AboutStorySectionScalarWhereWithAggregatesInput | AboutStorySectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutStorySection"> | string
    heading?: StringWithAggregatesFilter<"AboutStorySection"> | string
    title?: StringWithAggregatesFilter<"AboutStorySection"> | string
    titleHighlight?: StringWithAggregatesFilter<"AboutStorySection"> | string
    paragraph1?: StringWithAggregatesFilter<"AboutStorySection"> | string
    paragraph2?: StringWithAggregatesFilter<"AboutStorySection"> | string
    buttonText?: StringWithAggregatesFilter<"AboutStorySection"> | string
    buttonLink?: StringWithAggregatesFilter<"AboutStorySection"> | string
    image?: StringWithAggregatesFilter<"AboutStorySection"> | string
    status?: EnumContentStatusWithAggregatesFilter<"AboutStorySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AboutStorySection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AboutStorySection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutStorySection"> | Date | string
  }

  export type AboutCommunitySectionWhereInput = {
    AND?: AboutCommunitySectionWhereInput | AboutCommunitySectionWhereInput[]
    OR?: AboutCommunitySectionWhereInput[]
    NOT?: AboutCommunitySectionWhereInput | AboutCommunitySectionWhereInput[]
    id?: StringFilter<"AboutCommunitySection"> | string
    heading?: StringFilter<"AboutCommunitySection"> | string
    title?: StringFilter<"AboutCommunitySection"> | string
    titleHighlight?: StringFilter<"AboutCommunitySection"> | string
    paragraph1?: StringFilter<"AboutCommunitySection"> | string
    paragraph2?: StringFilter<"AboutCommunitySection"> | string
    buttonText?: StringFilter<"AboutCommunitySection"> | string
    buttonLink?: StringFilter<"AboutCommunitySection"> | string
    feature1Title?: StringFilter<"AboutCommunitySection"> | string
    feature1Description?: StringFilter<"AboutCommunitySection"> | string
    feature2Title?: StringFilter<"AboutCommunitySection"> | string
    feature2Description?: StringFilter<"AboutCommunitySection"> | string
    feature3Title?: StringFilter<"AboutCommunitySection"> | string
    feature3Description?: StringFilter<"AboutCommunitySection"> | string
    status?: EnumContentStatusFilter<"AboutCommunitySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutCommunitySection"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutCommunitySection"> | Date | string
    updatedAt?: DateTimeFilter<"AboutCommunitySection"> | Date | string
  }

  export type AboutCommunitySectionOrderByWithRelationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    feature1Title?: SortOrder
    feature1Description?: SortOrder
    feature2Title?: SortOrder
    feature2Description?: SortOrder
    feature3Title?: SortOrder
    feature3Description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCommunitySectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutCommunitySectionWhereInput | AboutCommunitySectionWhereInput[]
    OR?: AboutCommunitySectionWhereInput[]
    NOT?: AboutCommunitySectionWhereInput | AboutCommunitySectionWhereInput[]
    heading?: StringFilter<"AboutCommunitySection"> | string
    title?: StringFilter<"AboutCommunitySection"> | string
    titleHighlight?: StringFilter<"AboutCommunitySection"> | string
    paragraph1?: StringFilter<"AboutCommunitySection"> | string
    paragraph2?: StringFilter<"AboutCommunitySection"> | string
    buttonText?: StringFilter<"AboutCommunitySection"> | string
    buttonLink?: StringFilter<"AboutCommunitySection"> | string
    feature1Title?: StringFilter<"AboutCommunitySection"> | string
    feature1Description?: StringFilter<"AboutCommunitySection"> | string
    feature2Title?: StringFilter<"AboutCommunitySection"> | string
    feature2Description?: StringFilter<"AboutCommunitySection"> | string
    feature3Title?: StringFilter<"AboutCommunitySection"> | string
    feature3Description?: StringFilter<"AboutCommunitySection"> | string
    status?: EnumContentStatusFilter<"AboutCommunitySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutCommunitySection"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutCommunitySection"> | Date | string
    updatedAt?: DateTimeFilter<"AboutCommunitySection"> | Date | string
  }, "id">

  export type AboutCommunitySectionOrderByWithAggregationInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    feature1Title?: SortOrder
    feature1Description?: SortOrder
    feature2Title?: SortOrder
    feature2Description?: SortOrder
    feature3Title?: SortOrder
    feature3Description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutCommunitySectionCountOrderByAggregateInput
    _max?: AboutCommunitySectionMaxOrderByAggregateInput
    _min?: AboutCommunitySectionMinOrderByAggregateInput
  }

  export type AboutCommunitySectionScalarWhereWithAggregatesInput = {
    AND?: AboutCommunitySectionScalarWhereWithAggregatesInput | AboutCommunitySectionScalarWhereWithAggregatesInput[]
    OR?: AboutCommunitySectionScalarWhereWithAggregatesInput[]
    NOT?: AboutCommunitySectionScalarWhereWithAggregatesInput | AboutCommunitySectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    heading?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    title?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    titleHighlight?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    paragraph1?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    paragraph2?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    buttonText?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    buttonLink?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature1Title?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature1Description?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature2Title?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature2Description?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature3Title?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    feature3Description?: StringWithAggregatesFilter<"AboutCommunitySection"> | string
    status?: EnumContentStatusWithAggregatesFilter<"AboutCommunitySection"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AboutCommunitySection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AboutCommunitySection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutCommunitySection"> | Date | string
  }

  export type AboutStatsWhereInput = {
    AND?: AboutStatsWhereInput | AboutStatsWhereInput[]
    OR?: AboutStatsWhereInput[]
    NOT?: AboutStatsWhereInput | AboutStatsWhereInput[]
    id?: StringFilter<"AboutStats"> | string
    stat1Number?: StringFilter<"AboutStats"> | string
    stat1Label?: StringFilter<"AboutStats"> | string
    stat2Number?: StringFilter<"AboutStats"> | string
    stat2Label?: StringFilter<"AboutStats"> | string
    stat3Number?: StringFilter<"AboutStats"> | string
    stat3Label?: StringFilter<"AboutStats"> | string
    stat4Number?: StringFilter<"AboutStats"> | string
    stat4Label?: StringFilter<"AboutStats"> | string
    status?: EnumContentStatusFilter<"AboutStats"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutStats"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutStats"> | Date | string
    updatedAt?: DateTimeFilter<"AboutStats"> | Date | string
  }

  export type AboutStatsOrderByWithRelationInput = {
    id?: SortOrder
    stat1Number?: SortOrder
    stat1Label?: SortOrder
    stat2Number?: SortOrder
    stat2Label?: SortOrder
    stat3Number?: SortOrder
    stat3Label?: SortOrder
    stat4Number?: SortOrder
    stat4Label?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutStatsWhereInput | AboutStatsWhereInput[]
    OR?: AboutStatsWhereInput[]
    NOT?: AboutStatsWhereInput | AboutStatsWhereInput[]
    stat1Number?: StringFilter<"AboutStats"> | string
    stat1Label?: StringFilter<"AboutStats"> | string
    stat2Number?: StringFilter<"AboutStats"> | string
    stat2Label?: StringFilter<"AboutStats"> | string
    stat3Number?: StringFilter<"AboutStats"> | string
    stat3Label?: StringFilter<"AboutStats"> | string
    stat4Number?: StringFilter<"AboutStats"> | string
    stat4Label?: StringFilter<"AboutStats"> | string
    status?: EnumContentStatusFilter<"AboutStats"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutStats"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutStats"> | Date | string
    updatedAt?: DateTimeFilter<"AboutStats"> | Date | string
  }, "id">

  export type AboutStatsOrderByWithAggregationInput = {
    id?: SortOrder
    stat1Number?: SortOrder
    stat1Label?: SortOrder
    stat2Number?: SortOrder
    stat2Label?: SortOrder
    stat3Number?: SortOrder
    stat3Label?: SortOrder
    stat4Number?: SortOrder
    stat4Label?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutStatsCountOrderByAggregateInput
    _max?: AboutStatsMaxOrderByAggregateInput
    _min?: AboutStatsMinOrderByAggregateInput
  }

  export type AboutStatsScalarWhereWithAggregatesInput = {
    AND?: AboutStatsScalarWhereWithAggregatesInput | AboutStatsScalarWhereWithAggregatesInput[]
    OR?: AboutStatsScalarWhereWithAggregatesInput[]
    NOT?: AboutStatsScalarWhereWithAggregatesInput | AboutStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutStats"> | string
    stat1Number?: StringWithAggregatesFilter<"AboutStats"> | string
    stat1Label?: StringWithAggregatesFilter<"AboutStats"> | string
    stat2Number?: StringWithAggregatesFilter<"AboutStats"> | string
    stat2Label?: StringWithAggregatesFilter<"AboutStats"> | string
    stat3Number?: StringWithAggregatesFilter<"AboutStats"> | string
    stat3Label?: StringWithAggregatesFilter<"AboutStats"> | string
    stat4Number?: StringWithAggregatesFilter<"AboutStats"> | string
    stat4Label?: StringWithAggregatesFilter<"AboutStats"> | string
    status?: EnumContentStatusWithAggregatesFilter<"AboutStats"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AboutStats"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AboutStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutStats"> | Date | string
  }

  export type AboutValueWhereInput = {
    AND?: AboutValueWhereInput | AboutValueWhereInput[]
    OR?: AboutValueWhereInput[]
    NOT?: AboutValueWhereInput | AboutValueWhereInput[]
    id?: StringFilter<"AboutValue"> | string
    title?: StringFilter<"AboutValue"> | string
    description?: StringFilter<"AboutValue"> | string
    icon?: StringFilter<"AboutValue"> | string
    displayOrder?: IntFilter<"AboutValue"> | number
    active?: BoolFilter<"AboutValue"> | boolean
    createdAt?: DateTimeFilter<"AboutValue"> | Date | string
    updatedAt?: DateTimeFilter<"AboutValue"> | Date | string
  }

  export type AboutValueOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutValueWhereInput | AboutValueWhereInput[]
    OR?: AboutValueWhereInput[]
    NOT?: AboutValueWhereInput | AboutValueWhereInput[]
    title?: StringFilter<"AboutValue"> | string
    description?: StringFilter<"AboutValue"> | string
    icon?: StringFilter<"AboutValue"> | string
    displayOrder?: IntFilter<"AboutValue"> | number
    active?: BoolFilter<"AboutValue"> | boolean
    createdAt?: DateTimeFilter<"AboutValue"> | Date | string
    updatedAt?: DateTimeFilter<"AboutValue"> | Date | string
  }, "id">

  export type AboutValueOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutValueCountOrderByAggregateInput
    _avg?: AboutValueAvgOrderByAggregateInput
    _max?: AboutValueMaxOrderByAggregateInput
    _min?: AboutValueMinOrderByAggregateInput
    _sum?: AboutValueSumOrderByAggregateInput
  }

  export type AboutValueScalarWhereWithAggregatesInput = {
    AND?: AboutValueScalarWhereWithAggregatesInput | AboutValueScalarWhereWithAggregatesInput[]
    OR?: AboutValueScalarWhereWithAggregatesInput[]
    NOT?: AboutValueScalarWhereWithAggregatesInput | AboutValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutValue"> | string
    title?: StringWithAggregatesFilter<"AboutValue"> | string
    description?: StringWithAggregatesFilter<"AboutValue"> | string
    icon?: StringWithAggregatesFilter<"AboutValue"> | string
    displayOrder?: IntWithAggregatesFilter<"AboutValue"> | number
    active?: BoolWithAggregatesFilter<"AboutValue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AboutValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutValue"> | Date | string
  }

  export type AboutHeroWhereInput = {
    AND?: AboutHeroWhereInput | AboutHeroWhereInput[]
    OR?: AboutHeroWhereInput[]
    NOT?: AboutHeroWhereInput | AboutHeroWhereInput[]
    id?: StringFilter<"AboutHero"> | string
    image?: StringFilter<"AboutHero"> | string
    title?: StringFilter<"AboutHero"> | string
    subtitle?: StringFilter<"AboutHero"> | string
    description?: StringFilter<"AboutHero"> | string
    status?: EnumContentStatusFilter<"AboutHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutHero"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutHero"> | Date | string
    updatedAt?: DateTimeFilter<"AboutHero"> | Date | string
  }

  export type AboutHeroOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutHeroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutHeroWhereInput | AboutHeroWhereInput[]
    OR?: AboutHeroWhereInput[]
    NOT?: AboutHeroWhereInput | AboutHeroWhereInput[]
    image?: StringFilter<"AboutHero"> | string
    title?: StringFilter<"AboutHero"> | string
    subtitle?: StringFilter<"AboutHero"> | string
    description?: StringFilter<"AboutHero"> | string
    status?: EnumContentStatusFilter<"AboutHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutHero"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutHero"> | Date | string
    updatedAt?: DateTimeFilter<"AboutHero"> | Date | string
  }, "id">

  export type AboutHeroOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutHeroCountOrderByAggregateInput
    _max?: AboutHeroMaxOrderByAggregateInput
    _min?: AboutHeroMinOrderByAggregateInput
  }

  export type AboutHeroScalarWhereWithAggregatesInput = {
    AND?: AboutHeroScalarWhereWithAggregatesInput | AboutHeroScalarWhereWithAggregatesInput[]
    OR?: AboutHeroScalarWhereWithAggregatesInput[]
    NOT?: AboutHeroScalarWhereWithAggregatesInput | AboutHeroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutHero"> | string
    image?: StringWithAggregatesFilter<"AboutHero"> | string
    title?: StringWithAggregatesFilter<"AboutHero"> | string
    subtitle?: StringWithAggregatesFilter<"AboutHero"> | string
    description?: StringWithAggregatesFilter<"AboutHero"> | string
    status?: EnumContentStatusWithAggregatesFilter<"AboutHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AboutHero"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AboutHero"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutHero"> | Date | string
  }

  export type AboutCTAWhereInput = {
    AND?: AboutCTAWhereInput | AboutCTAWhereInput[]
    OR?: AboutCTAWhereInput[]
    NOT?: AboutCTAWhereInput | AboutCTAWhereInput[]
    id?: StringFilter<"AboutCTA"> | string
    badge?: StringFilter<"AboutCTA"> | string
    heading?: StringFilter<"AboutCTA"> | string
    headingHighlight?: StringFilter<"AboutCTA"> | string
    description?: StringFilter<"AboutCTA"> | string
    button1Text?: StringFilter<"AboutCTA"> | string
    button1Link?: StringFilter<"AboutCTA"> | string
    button2Text?: StringFilter<"AboutCTA"> | string
    button2Link?: StringFilter<"AboutCTA"> | string
    footerText?: StringFilter<"AboutCTA"> | string
    status?: EnumContentStatusFilter<"AboutCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutCTA"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutCTA"> | Date | string
    updatedAt?: DateTimeFilter<"AboutCTA"> | Date | string
  }

  export type AboutCTAOrderByWithRelationInput = {
    id?: SortOrder
    badge?: SortOrder
    heading?: SortOrder
    headingHighlight?: SortOrder
    description?: SortOrder
    button1Text?: SortOrder
    button1Link?: SortOrder
    button2Text?: SortOrder
    button2Link?: SortOrder
    footerText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCTAWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AboutCTAWhereInput | AboutCTAWhereInput[]
    OR?: AboutCTAWhereInput[]
    NOT?: AboutCTAWhereInput | AboutCTAWhereInput[]
    badge?: StringFilter<"AboutCTA"> | string
    heading?: StringFilter<"AboutCTA"> | string
    headingHighlight?: StringFilter<"AboutCTA"> | string
    description?: StringFilter<"AboutCTA"> | string
    button1Text?: StringFilter<"AboutCTA"> | string
    button1Link?: StringFilter<"AboutCTA"> | string
    button2Text?: StringFilter<"AboutCTA"> | string
    button2Link?: StringFilter<"AboutCTA"> | string
    footerText?: StringFilter<"AboutCTA"> | string
    status?: EnumContentStatusFilter<"AboutCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"AboutCTA"> | Date | string | null
    createdAt?: DateTimeFilter<"AboutCTA"> | Date | string
    updatedAt?: DateTimeFilter<"AboutCTA"> | Date | string
  }, "id">

  export type AboutCTAOrderByWithAggregationInput = {
    id?: SortOrder
    badge?: SortOrder
    heading?: SortOrder
    headingHighlight?: SortOrder
    description?: SortOrder
    button1Text?: SortOrder
    button1Link?: SortOrder
    button2Text?: SortOrder
    button2Link?: SortOrder
    footerText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutCTACountOrderByAggregateInput
    _max?: AboutCTAMaxOrderByAggregateInput
    _min?: AboutCTAMinOrderByAggregateInput
  }

  export type AboutCTAScalarWhereWithAggregatesInput = {
    AND?: AboutCTAScalarWhereWithAggregatesInput | AboutCTAScalarWhereWithAggregatesInput[]
    OR?: AboutCTAScalarWhereWithAggregatesInput[]
    NOT?: AboutCTAScalarWhereWithAggregatesInput | AboutCTAScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AboutCTA"> | string
    badge?: StringWithAggregatesFilter<"AboutCTA"> | string
    heading?: StringWithAggregatesFilter<"AboutCTA"> | string
    headingHighlight?: StringWithAggregatesFilter<"AboutCTA"> | string
    description?: StringWithAggregatesFilter<"AboutCTA"> | string
    button1Text?: StringWithAggregatesFilter<"AboutCTA"> | string
    button1Link?: StringWithAggregatesFilter<"AboutCTA"> | string
    button2Text?: StringWithAggregatesFilter<"AboutCTA"> | string
    button2Link?: StringWithAggregatesFilter<"AboutCTA"> | string
    footerText?: StringWithAggregatesFilter<"AboutCTA"> | string
    status?: EnumContentStatusWithAggregatesFilter<"AboutCTA"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AboutCTA"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AboutCTA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AboutCTA"> | Date | string
  }

  export type ContactHeroWhereInput = {
    AND?: ContactHeroWhereInput | ContactHeroWhereInput[]
    OR?: ContactHeroWhereInput[]
    NOT?: ContactHeroWhereInput | ContactHeroWhereInput[]
    id?: StringFilter<"ContactHero"> | string
    image?: StringFilter<"ContactHero"> | string
    title?: StringFilter<"ContactHero"> | string
    subtitle?: StringFilter<"ContactHero"> | string
    description?: StringFilter<"ContactHero"> | string
    status?: EnumContentStatusFilter<"ContactHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ContactHero"> | Date | string | null
    createdAt?: DateTimeFilter<"ContactHero"> | Date | string
    updatedAt?: DateTimeFilter<"ContactHero"> | Date | string
  }

  export type ContactHeroOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactHeroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactHeroWhereInput | ContactHeroWhereInput[]
    OR?: ContactHeroWhereInput[]
    NOT?: ContactHeroWhereInput | ContactHeroWhereInput[]
    image?: StringFilter<"ContactHero"> | string
    title?: StringFilter<"ContactHero"> | string
    subtitle?: StringFilter<"ContactHero"> | string
    description?: StringFilter<"ContactHero"> | string
    status?: EnumContentStatusFilter<"ContactHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ContactHero"> | Date | string | null
    createdAt?: DateTimeFilter<"ContactHero"> | Date | string
    updatedAt?: DateTimeFilter<"ContactHero"> | Date | string
  }, "id">

  export type ContactHeroOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactHeroCountOrderByAggregateInput
    _max?: ContactHeroMaxOrderByAggregateInput
    _min?: ContactHeroMinOrderByAggregateInput
  }

  export type ContactHeroScalarWhereWithAggregatesInput = {
    AND?: ContactHeroScalarWhereWithAggregatesInput | ContactHeroScalarWhereWithAggregatesInput[]
    OR?: ContactHeroScalarWhereWithAggregatesInput[]
    NOT?: ContactHeroScalarWhereWithAggregatesInput | ContactHeroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactHero"> | string
    image?: StringWithAggregatesFilter<"ContactHero"> | string
    title?: StringWithAggregatesFilter<"ContactHero"> | string
    subtitle?: StringWithAggregatesFilter<"ContactHero"> | string
    description?: StringWithAggregatesFilter<"ContactHero"> | string
    status?: EnumContentStatusWithAggregatesFilter<"ContactHero"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ContactHero"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactHero"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactHero"> | Date | string
  }

  export type ContactInfoWhereInput = {
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    id?: StringFilter<"ContactInfo"> | string
    email?: StringFilter<"ContactInfo"> | string
    phone?: StringFilter<"ContactInfo"> | string
    whatsapp?: StringFilter<"ContactInfo"> | string
    office?: StringFilter<"ContactInfo"> | string
    businessHours?: JsonFilter<"ContactInfo">
    quickResponse?: StringFilter<"ContactInfo"> | string
    status?: EnumContentStatusFilter<"ContactInfo"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ContactInfo"> | Date | string | null
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfo"> | Date | string
  }

  export type ContactInfoOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    office?: SortOrder
    businessHours?: SortOrder
    quickResponse?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    email?: StringFilter<"ContactInfo"> | string
    phone?: StringFilter<"ContactInfo"> | string
    whatsapp?: StringFilter<"ContactInfo"> | string
    office?: StringFilter<"ContactInfo"> | string
    businessHours?: JsonFilter<"ContactInfo">
    quickResponse?: StringFilter<"ContactInfo"> | string
    status?: EnumContentStatusFilter<"ContactInfo"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableFilter<"ContactInfo"> | Date | string | null
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfo"> | Date | string
  }, "id">

  export type ContactInfoOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    office?: SortOrder
    businessHours?: SortOrder
    quickResponse?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactInfoCountOrderByAggregateInput
    _max?: ContactInfoMaxOrderByAggregateInput
    _min?: ContactInfoMinOrderByAggregateInput
  }

  export type ContactInfoScalarWhereWithAggregatesInput = {
    AND?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    OR?: ContactInfoScalarWhereWithAggregatesInput[]
    NOT?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactInfo"> | string
    email?: StringWithAggregatesFilter<"ContactInfo"> | string
    phone?: StringWithAggregatesFilter<"ContactInfo"> | string
    whatsapp?: StringWithAggregatesFilter<"ContactInfo"> | string
    office?: StringWithAggregatesFilter<"ContactInfo"> | string
    businessHours?: JsonWithAggregatesFilter<"ContactInfo">
    quickResponse?: StringWithAggregatesFilter<"ContactInfo"> | string
    status?: EnumContentStatusWithAggregatesFilter<"ContactInfo"> | $Enums.ContentStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ContactInfo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactInfo"> | Date | string
  }

  export type ContactResourceWhereInput = {
    AND?: ContactResourceWhereInput | ContactResourceWhereInput[]
    OR?: ContactResourceWhereInput[]
    NOT?: ContactResourceWhereInput | ContactResourceWhereInput[]
    id?: StringFilter<"ContactResource"> | string
    title?: StringFilter<"ContactResource"> | string
    description?: StringFilter<"ContactResource"> | string
    icon?: StringFilter<"ContactResource"> | string
    linkText?: StringFilter<"ContactResource"> | string
    linkUrl?: StringFilter<"ContactResource"> | string
    isExternal?: BoolFilter<"ContactResource"> | boolean
    displayOrder?: IntFilter<"ContactResource"> | number
    active?: BoolFilter<"ContactResource"> | boolean
    createdAt?: DateTimeFilter<"ContactResource"> | Date | string
    updatedAt?: DateTimeFilter<"ContactResource"> | Date | string
  }

  export type ContactResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    linkText?: SortOrder
    linkUrl?: SortOrder
    isExternal?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactResourceWhereInput | ContactResourceWhereInput[]
    OR?: ContactResourceWhereInput[]
    NOT?: ContactResourceWhereInput | ContactResourceWhereInput[]
    title?: StringFilter<"ContactResource"> | string
    description?: StringFilter<"ContactResource"> | string
    icon?: StringFilter<"ContactResource"> | string
    linkText?: StringFilter<"ContactResource"> | string
    linkUrl?: StringFilter<"ContactResource"> | string
    isExternal?: BoolFilter<"ContactResource"> | boolean
    displayOrder?: IntFilter<"ContactResource"> | number
    active?: BoolFilter<"ContactResource"> | boolean
    createdAt?: DateTimeFilter<"ContactResource"> | Date | string
    updatedAt?: DateTimeFilter<"ContactResource"> | Date | string
  }, "id">

  export type ContactResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    linkText?: SortOrder
    linkUrl?: SortOrder
    isExternal?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactResourceCountOrderByAggregateInput
    _avg?: ContactResourceAvgOrderByAggregateInput
    _max?: ContactResourceMaxOrderByAggregateInput
    _min?: ContactResourceMinOrderByAggregateInput
    _sum?: ContactResourceSumOrderByAggregateInput
  }

  export type ContactResourceScalarWhereWithAggregatesInput = {
    AND?: ContactResourceScalarWhereWithAggregatesInput | ContactResourceScalarWhereWithAggregatesInput[]
    OR?: ContactResourceScalarWhereWithAggregatesInput[]
    NOT?: ContactResourceScalarWhereWithAggregatesInput | ContactResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactResource"> | string
    title?: StringWithAggregatesFilter<"ContactResource"> | string
    description?: StringWithAggregatesFilter<"ContactResource"> | string
    icon?: StringWithAggregatesFilter<"ContactResource"> | string
    linkText?: StringWithAggregatesFilter<"ContactResource"> | string
    linkUrl?: StringWithAggregatesFilter<"ContactResource"> | string
    isExternal?: BoolWithAggregatesFilter<"ContactResource"> | boolean
    displayOrder?: IntWithAggregatesFilter<"ContactResource"> | number
    active?: BoolWithAggregatesFilter<"ContactResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContactResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactResource"> | Date | string
  }

  export type DestinationCreateInput = {
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutDestinationInput
    favorites?: UserFavoriteCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutDestinationNestedInput
    favorites?: UserFavoriteUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationCreateManyInput = {
    id?: number
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destination?: DestinationCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    packageId?: number | null
    destinationId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateInput = {
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableIntFieldUpdateOperationsInput | number | null
    destinationId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    packageId?: number | null
    destinationId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableIntFieldUpdateOperationsInput | number | null
    destinationId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInquiryCreateInput = {
    name: string
    email: string
    subject: string
    message: string
    status?: $Enums.InquiryStatus
    responseNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInquiryUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    status?: $Enums.InquiryStatus
    responseNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInquiryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInquiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInquiryCreateManyInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    status?: $Enums.InquiryStatus
    responseNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInquiryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInquiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionCreateInput = {
    email: string
    status?: $Enums.SubscriptionStatus
    subscribedAt?: Date | string
    unsubscribedAt?: Date | string | null
  }

  export type NewsletterSubscriptionUncheckedCreateInput = {
    id?: number
    email: string
    status?: $Enums.SubscriptionStatus
    subscribedAt?: Date | string
    unsubscribedAt?: Date | string | null
  }

  export type NewsletterSubscriptionUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriptionCreateManyInput = {
    id?: number
    email: string
    status?: $Enums.SubscriptionStatus
    subscribedAt?: Date | string
    unsubscribedAt?: Date | string | null
  }

  export type NewsletterSubscriptionUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    customPackages?: CustomPackageCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    customPackages?: CustomPackageUncheckedCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    customPackages?: CustomPackageUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    customPackages?: CustomPackageUncheckedUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateInput = {
    createdAt?: Date | string
    destination: DestinationCreateNestedOneWithoutFavoritesInput
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    id?: number
    userId: string
    destinationId: number
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutFavoritesNestedInput
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    destinationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    id?: number
    userId: string
    destinationId: number
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    destinationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateInput = {
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPackageInput
    bundleItems?: PackageBundleItemCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPackageInput
    bundleItems?: PackageBundleItemUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPackageNestedInput
    bundleItems?: PackageBundleItemUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPackageNestedInput
    bundleItems?: PackageBundleItemUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageCreateManyInput = {
    id?: number
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageCreateInput = {
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomPackagesInput
  }

  export type CustomPackageUncheckedCreateInput = {
    id?: number
    userId: string
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPackageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomPackagesNestedInput
  }

  export type CustomPackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageCreateManyInput = {
    id?: number
    userId: string
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPackageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageBundleCreateInput = {
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPackageBundlesInput
    packages?: PackageBundleItemCreateNestedManyWithoutBundleInput
  }

  export type PackageBundleUncheckedCreateInput = {
    id?: number
    userId: string
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    packages?: PackageBundleItemUncheckedCreateNestedManyWithoutBundleInput
  }

  export type PackageBundleUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPackageBundlesNestedInput
    packages?: PackageBundleItemUpdateManyWithoutBundleNestedInput
  }

  export type PackageBundleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackageBundleItemUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type PackageBundleCreateManyInput = {
    id?: number
    userId: string
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageBundleUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageBundleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageBundleItemCreateInput = {
    notes?: string | null
    bundle: PackageBundleCreateNestedOneWithoutPackagesInput
    package: PackageCreateNestedOneWithoutBundleItemsInput
  }

  export type PackageBundleItemUncheckedCreateInput = {
    id?: number
    bundleId: number
    packageId: number
    notes?: string | null
  }

  export type PackageBundleItemUpdateInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bundle?: PackageBundleUpdateOneRequiredWithoutPackagesNestedInput
    package?: PackageUpdateOneRequiredWithoutBundleItemsNestedInput
  }

  export type PackageBundleItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bundleId?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageBundleItemCreateManyInput = {
    id?: number
    bundleId: number
    packageId: number
    notes?: string | null
  }

  export type PackageBundleItemUpdateManyMutationInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageBundleItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bundleId?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CMSImageCreateInput = {
    id?: string
    filename: string
    url: string
    altText?: string | null
    category?: string | null
    width: number
    height: number
    fileSize: number
    format: string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSImageUncheckedCreateInput = {
    id?: string
    filename: string
    url: string
    altText?: string | null
    category?: string | null
    width: number
    height: number
    fileSize: number
    format: string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    fileSize?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    fileSize?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSImageCreateManyInput = {
    id?: string
    filename: string
    url: string
    altText?: string | null
    category?: string | null
    width: number
    height: number
    fileSize: number
    format: string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    fileSize?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    fileSize?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    usedIn?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlideCreateInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    image: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSlideUncheckedCreateInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    image: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSlideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlideCreateManyInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    image: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSlideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSDestinationCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    region: string
    country?: string
    description: string
    shortDesc?: string | null
    heroImage: string
    gallery: JsonNullValueInput | InputJsonValue
    history?: string | null
    geography?: string | null
    climate?: string | null
    wildlife?: string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: string | null
    featured?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSDestinationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    region: string
    country?: string
    description: string
    shortDesc?: string | null
    heroImage: string
    gallery: JsonNullValueInput | InputJsonValue
    history?: string | null
    geography?: string | null
    climate?: string | null
    wildlife?: string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: string | null
    featured?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSDestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    heroImage?: StringFieldUpdateOperationsInput | string
    gallery?: JsonNullValueInput | InputJsonValue
    history?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    climate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlife?: NullableStringFieldUpdateOperationsInput | string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSDestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    heroImage?: StringFieldUpdateOperationsInput | string
    gallery?: JsonNullValueInput | InputJsonValue
    history?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    climate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlife?: NullableStringFieldUpdateOperationsInput | string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSDestinationCreateManyInput = {
    id?: string
    name: string
    slug: string
    category: string
    region: string
    country?: string
    description: string
    shortDesc?: string | null
    heroImage: string
    gallery: JsonNullValueInput | InputJsonValue
    history?: string | null
    geography?: string | null
    climate?: string | null
    wildlife?: string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: string | null
    featured?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CMSDestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    heroImage?: StringFieldUpdateOperationsInput | string
    gallery?: JsonNullValueInput | InputJsonValue
    history?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    climate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlife?: NullableStringFieldUpdateOperationsInput | string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSDestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    heroImage?: StringFieldUpdateOperationsInput | string
    gallery?: JsonNullValueInput | InputJsonValue
    history?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    climate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlife?: NullableStringFieldUpdateOperationsInput | string | null
    keyWildlife?: NullableJsonNullValueInput | InputJsonValue
    flora?: NullableJsonNullValueInput | InputJsonValue
    cultural?: NullableJsonNullValueInput | InputJsonValue
    bestTime?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SiteSettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SiteSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteSettingsCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SiteSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMemberCreateInput = {
    id?: string
    name: string
    role: string
    bio: string
    image: string
    years: string
    specialties: JsonNullValueInput | InputJsonValue
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    bio: string
    image: string
    years: string
    specialties: JsonNullValueInput | InputJsonValue
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    years?: StringFieldUpdateOperationsInput | string
    specialties?: JsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    years?: StringFieldUpdateOperationsInput | string
    specialties?: JsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    name: string
    role: string
    bio: string
    image: string
    years: string
    specialties: JsonNullValueInput | InputJsonValue
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    years?: StringFieldUpdateOperationsInput | string
    specialties?: JsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    years?: StringFieldUpdateOperationsInput | string
    specialties?: JsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateManyInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSAuditLogCreateInput = {
    id?: string
    userId: string
    userName?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type CMSAuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    userName?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type CMSAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSAuditLogCreateManyInput = {
    id?: string
    userId: string
    userName?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type CMSAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CMSAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceSectionCreateInput = {
    id?: string
    heading: string
    title: string
    description: string
    image: string
    stat1Value: string
    stat1Label: string
    stat2Value: string
    stat2Label: string
    badgeText: string
    backgroundText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceSectionUncheckedCreateInput = {
    id?: string
    heading: string
    title: string
    description: string
    image: string
    stat1Value: string
    stat1Label: string
    stat2Value: string
    stat2Label: string
    badgeText: string
    backgroundText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    stat1Value?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Value?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    badgeText?: StringFieldUpdateOperationsInput | string
    backgroundText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    stat1Value?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Value?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    badgeText?: StringFieldUpdateOperationsInput | string
    backgroundText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceSectionCreateManyInput = {
    id?: string
    heading: string
    title: string
    description: string
    image: string
    stat1Value: string
    stat1Label: string
    stat2Value: string
    stat2Label: string
    badgeText: string
    backgroundText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    stat1Value?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Value?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    badgeText?: StringFieldUpdateOperationsInput | string
    backgroundText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    stat1Value?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Value?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    badgeText?: StringFieldUpdateOperationsInput | string
    backgroundText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourGuideSectionCreateInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    mapImage: string
    buttonText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourGuideSectionUncheckedCreateInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    mapImage: string
    buttonText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourGuideSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapImage?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourGuideSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapImage?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourGuideSectionCreateManyInput = {
    id?: string
    title: string
    subtitle: string
    description: string
    mapImage: string
    buttonText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourGuideSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapImage?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourGuideSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapImage?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSectionCreateInput = {
    id?: string
    title: string
    description: string
    videoUrl: string
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoSectionUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    videoUrl: string
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSectionCreateManyInput = {
    id?: string
    title: string
    description: string
    videoUrl: string
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagesHeroCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackagesHeroUncheckedCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackagesHeroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagesHeroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagesHeroCreateManyInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackagesHeroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagesHeroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsHeroCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsHeroUncheckedCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsHeroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsHeroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsHeroCreateManyInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsHeroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsHeroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsCTACreateInput = {
    id?: string
    title: string
    description: string
    buttonText: string
    buttonLink: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsCTAUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    buttonText: string
    buttonLink: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsCTAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsCTAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsCTACreateManyInput = {
    id?: string
    title: string
    description: string
    buttonText: string
    buttonLink: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationsCTAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationsCTAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStorySectionCreateInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    image: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStorySectionUncheckedCreateInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    image: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStorySectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStorySectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStorySectionCreateManyInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    image: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStorySectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStorySectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCommunitySectionCreateInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    feature1Title: string
    feature1Description: string
    feature2Title: string
    feature2Description: string
    feature3Title: string
    feature3Description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCommunitySectionUncheckedCreateInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    feature1Title: string
    feature1Description: string
    feature2Title: string
    feature2Description: string
    feature3Title: string
    feature3Description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCommunitySectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    feature1Title?: StringFieldUpdateOperationsInput | string
    feature1Description?: StringFieldUpdateOperationsInput | string
    feature2Title?: StringFieldUpdateOperationsInput | string
    feature2Description?: StringFieldUpdateOperationsInput | string
    feature3Title?: StringFieldUpdateOperationsInput | string
    feature3Description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCommunitySectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    feature1Title?: StringFieldUpdateOperationsInput | string
    feature1Description?: StringFieldUpdateOperationsInput | string
    feature2Title?: StringFieldUpdateOperationsInput | string
    feature2Description?: StringFieldUpdateOperationsInput | string
    feature3Title?: StringFieldUpdateOperationsInput | string
    feature3Description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCommunitySectionCreateManyInput = {
    id?: string
    heading: string
    title: string
    titleHighlight: string
    paragraph1: string
    paragraph2: string
    buttonText: string
    buttonLink: string
    feature1Title: string
    feature1Description: string
    feature2Title: string
    feature2Description: string
    feature3Title: string
    feature3Description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCommunitySectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    feature1Title?: StringFieldUpdateOperationsInput | string
    feature1Description?: StringFieldUpdateOperationsInput | string
    feature2Title?: StringFieldUpdateOperationsInput | string
    feature2Description?: StringFieldUpdateOperationsInput | string
    feature3Title?: StringFieldUpdateOperationsInput | string
    feature3Description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCommunitySectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleHighlight?: StringFieldUpdateOperationsInput | string
    paragraph1?: StringFieldUpdateOperationsInput | string
    paragraph2?: StringFieldUpdateOperationsInput | string
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    feature1Title?: StringFieldUpdateOperationsInput | string
    feature1Description?: StringFieldUpdateOperationsInput | string
    feature2Title?: StringFieldUpdateOperationsInput | string
    feature2Description?: StringFieldUpdateOperationsInput | string
    feature3Title?: StringFieldUpdateOperationsInput | string
    feature3Description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStatsCreateInput = {
    id?: string
    stat1Number: string
    stat1Label: string
    stat2Number: string
    stat2Label: string
    stat3Number: string
    stat3Label: string
    stat4Number: string
    stat4Label: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStatsUncheckedCreateInput = {
    id?: string
    stat1Number: string
    stat1Label: string
    stat2Number: string
    stat2Label: string
    stat3Number: string
    stat3Label: string
    stat4Number: string
    stat4Label: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stat1Number?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Number?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    stat3Number?: StringFieldUpdateOperationsInput | string
    stat3Label?: StringFieldUpdateOperationsInput | string
    stat4Number?: StringFieldUpdateOperationsInput | string
    stat4Label?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stat1Number?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Number?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    stat3Number?: StringFieldUpdateOperationsInput | string
    stat3Label?: StringFieldUpdateOperationsInput | string
    stat4Number?: StringFieldUpdateOperationsInput | string
    stat4Label?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStatsCreateManyInput = {
    id?: string
    stat1Number: string
    stat1Label: string
    stat2Number: string
    stat2Label: string
    stat3Number: string
    stat3Label: string
    stat4Number: string
    stat4Label: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stat1Number?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Number?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    stat3Number?: StringFieldUpdateOperationsInput | string
    stat3Label?: StringFieldUpdateOperationsInput | string
    stat4Number?: StringFieldUpdateOperationsInput | string
    stat4Label?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stat1Number?: StringFieldUpdateOperationsInput | string
    stat1Label?: StringFieldUpdateOperationsInput | string
    stat2Number?: StringFieldUpdateOperationsInput | string
    stat2Label?: StringFieldUpdateOperationsInput | string
    stat3Number?: StringFieldUpdateOperationsInput | string
    stat3Label?: StringFieldUpdateOperationsInput | string
    stat4Number?: StringFieldUpdateOperationsInput | string
    stat4Label?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutValueCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutValueUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutValueCreateManyInput = {
    id?: string
    title: string
    description: string
    icon: string
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutHeroCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutHeroUncheckedCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutHeroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutHeroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutHeroCreateManyInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutHeroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutHeroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCTACreateInput = {
    id?: string
    badge: string
    heading: string
    headingHighlight: string
    description: string
    button1Text: string
    button1Link: string
    button2Text: string
    button2Link: string
    footerText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCTAUncheckedCreateInput = {
    id?: string
    badge: string
    heading: string
    headingHighlight: string
    description: string
    button1Text: string
    button1Link: string
    button2Text: string
    button2Link: string
    footerText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCTAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    headingHighlight?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    button1Text?: StringFieldUpdateOperationsInput | string
    button1Link?: StringFieldUpdateOperationsInput | string
    button2Text?: StringFieldUpdateOperationsInput | string
    button2Link?: StringFieldUpdateOperationsInput | string
    footerText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCTAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    headingHighlight?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    button1Text?: StringFieldUpdateOperationsInput | string
    button1Link?: StringFieldUpdateOperationsInput | string
    button2Text?: StringFieldUpdateOperationsInput | string
    button2Link?: StringFieldUpdateOperationsInput | string
    footerText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCTACreateManyInput = {
    id?: string
    badge: string
    heading: string
    headingHighlight: string
    description: string
    button1Text: string
    button1Link: string
    button2Text: string
    button2Link: string
    footerText: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutCTAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    headingHighlight?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    button1Text?: StringFieldUpdateOperationsInput | string
    button1Link?: StringFieldUpdateOperationsInput | string
    button2Text?: StringFieldUpdateOperationsInput | string
    button2Link?: StringFieldUpdateOperationsInput | string
    footerText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutCTAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    heading?: StringFieldUpdateOperationsInput | string
    headingHighlight?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    button1Text?: StringFieldUpdateOperationsInput | string
    button1Link?: StringFieldUpdateOperationsInput | string
    button2Text?: StringFieldUpdateOperationsInput | string
    button2Link?: StringFieldUpdateOperationsInput | string
    footerText?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactHeroCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactHeroUncheckedCreateInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactHeroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactHeroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactHeroCreateManyInput = {
    id?: string
    image: string
    title: string
    subtitle: string
    description: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactHeroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactHeroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoCreateInput = {
    id?: string
    email: string
    phone: string
    whatsapp: string
    office: string
    businessHours: JsonNullValueInput | InputJsonValue
    quickResponse: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoUncheckedCreateInput = {
    id?: string
    email: string
    phone: string
    whatsapp: string
    office: string
    businessHours: JsonNullValueInput | InputJsonValue
    quickResponse: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    businessHours?: JsonNullValueInput | InputJsonValue
    quickResponse?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    businessHours?: JsonNullValueInput | InputJsonValue
    quickResponse?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoCreateManyInput = {
    id?: string
    email: string
    phone: string
    whatsapp: string
    office: string
    businessHours: JsonNullValueInput | InputJsonValue
    quickResponse: string
    status?: $Enums.ContentStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    businessHours?: JsonNullValueInput | InputJsonValue
    quickResponse?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    businessHours?: JsonNullValueInput | InputJsonValue
    quickResponse?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactResourceCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    linkText: string
    linkUrl: string
    isExternal?: boolean
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactResourceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    linkText: string
    linkUrl: string
    isExternal?: boolean
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    linkText?: StringFieldUpdateOperationsInput | string
    linkUrl?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    linkText?: StringFieldUpdateOperationsInput | string
    linkUrl?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactResourceCreateManyInput = {
    id?: string
    title: string
    description: string
    icon: string
    linkText: string
    linkUrl: string
    isExternal?: boolean
    displayOrder?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    linkText?: StringFieldUpdateOperationsInput | string
    linkUrl?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    linkText?: StringFieldUpdateOperationsInput | string
    linkUrl?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    country?: SortOrder
    region?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    description?: SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    featured?: SortOrder
    historyTitle?: SortOrder
    historyContent?: SortOrder
    geographyDescription?: SortOrder
    geographyClimate?: SortOrder
    wildlifeDescription?: SortOrder
    wildlifeMammals?: SortOrder
    wildlifeBirds?: SortOrder
    wildlifeFlora?: SortOrder
    cultureDescription?: SortOrder
    cultureExperiences?: SortOrder
    bestTimeDescription?: SortOrder
    drySeasonTitle?: SortOrder
    drySeasonDescription?: SortOrder
    wetSeasonTitle?: SortOrder
    wetSeasonDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
  }

  export type DestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    country?: SortOrder
    region?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    description?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    historyTitle?: SortOrder
    geographyDescription?: SortOrder
    geographyClimate?: SortOrder
    wildlifeDescription?: SortOrder
    cultureDescription?: SortOrder
    bestTimeDescription?: SortOrder
    drySeasonTitle?: SortOrder
    drySeasonDescription?: SortOrder
    wetSeasonTitle?: SortOrder
    wetSeasonDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    country?: SortOrder
    region?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    description?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    historyTitle?: SortOrder
    geographyDescription?: SortOrder
    geographyClimate?: SortOrder
    wildlifeDescription?: SortOrder
    cultureDescription?: SortOrder
    bestTimeDescription?: SortOrder
    drySeasonTitle?: SortOrder
    drySeasonDescription?: SortOrder
    wetSeasonTitle?: SortOrder
    wetSeasonDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    groupSize?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type DestinationNullableScalarRelationFilter = {
    is?: DestinationWhereInput | null
    isNot?: DestinationWhereInput | null
  }

  export type PackageNullableScalarRelationFilter = {
    is?: PackageWhereInput | null
    isNot?: PackageWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    confirmationNumber?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    packageId?: SortOrder
    destinationId?: SortOrder
    bookingType?: SortOrder
    numberOfTravelers?: SortOrder
    specialRequests?: SortOrder
    travelDateFrom?: SortOrder
    travelDateTo?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    paymentIntentId?: SortOrder
    stripeCustomerId?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    destinationId?: SortOrder
    numberOfTravelers?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    confirmationNumber?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    packageId?: SortOrder
    destinationId?: SortOrder
    bookingType?: SortOrder
    numberOfTravelers?: SortOrder
    specialRequests?: SortOrder
    travelDateFrom?: SortOrder
    travelDateTo?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    paymentIntentId?: SortOrder
    stripeCustomerId?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    confirmationNumber?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    packageId?: SortOrder
    destinationId?: SortOrder
    bookingType?: SortOrder
    numberOfTravelers?: SortOrder
    specialRequests?: SortOrder
    travelDateFrom?: SortOrder
    travelDateTo?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    paymentIntentId?: SortOrder
    stripeCustomerId?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    destinationId?: SortOrder
    numberOfTravelers?: SortOrder
    pricePerPerson?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type ContactInquiryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responseNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInquiryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactInquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responseNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInquiryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responseNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInquirySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NewsletterSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    status?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
  }

  export type NewsletterSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NewsletterSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    status?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
  }

  export type NewsletterSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    status?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
  }

  export type NewsletterSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CustomPackageListRelationFilter = {
    every?: CustomPackageWhereInput
    some?: CustomPackageWhereInput
    none?: CustomPackageWhereInput
  }

  export type PackageBundleListRelationFilter = {
    every?: PackageBundleWhereInput
    some?: PackageBundleWhereInput
    none?: PackageBundleWhereInput
  }

  export type CustomPackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageBundleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationScalarRelationFilter = {
    is?: DestinationWhereInput
    isNot?: DestinationWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserFavoriteUserIdDestinationIdCompoundUniqueInput = {
    userId: string
    destinationId: number
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteAvgOrderByAggregateInput = {
    id?: SortOrder
    destinationId?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteSumOrderByAggregateInput = {
    id?: SortOrder
    destinationId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }

  export type PackageBundleItemListRelationFilter = {
    every?: PackageBundleItemWhereInput
    some?: PackageBundleItemWhereInput
    none?: PackageBundleItemWhereInput
  }

  export type PackageBundleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    image?: SortOrder
    images?: SortOrder
    gallery2Images?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    included?: SortOrder
    excluded?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    difficulty?: SortOrder
    featured?: SortOrder
    popular?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    displayOrder?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    image?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    difficulty?: SortOrder
    featured?: SortOrder
    popular?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    image?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    difficulty?: SortOrder
    featured?: SortOrder
    popular?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    minTravelers?: SortOrder
    maxTravelers?: SortOrder
    displayOrder?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumCustomPackageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPackageStatus | EnumCustomPackageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPackageStatusFilter<$PrismaModel> | $Enums.CustomPackageStatus
  }

  export type CustomPackageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    destinations?: SortOrder
    duration?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPackageAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfPeople?: SortOrder
    budget?: SortOrder
    quotedPrice?: SortOrder
  }

  export type CustomPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPackageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPackageSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfPeople?: SortOrder
    budget?: SortOrder
    quotedPrice?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumCustomPackageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPackageStatus | EnumCustomPackageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPackageStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomPackageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPackageStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomPackageStatusFilter<$PrismaModel>
  }

  export type PackageBundleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageBundleAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfPeople?: SortOrder
    quotedPrice?: SortOrder
  }

  export type PackageBundleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageBundleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    numberOfPeople?: SortOrder
    travelDate?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    quotedPrice?: SortOrder
    quoteNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageBundleSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfPeople?: SortOrder
    quotedPrice?: SortOrder
  }

  export type PackageBundleScalarRelationFilter = {
    is?: PackageBundleWhereInput
    isNot?: PackageBundleWhereInput
  }

  export type PackageScalarRelationFilter = {
    is?: PackageWhereInput
    isNot?: PackageWhereInput
  }

  export type PackageBundleItemBundleIdPackageIdCompoundUniqueInput = {
    bundleId: number
    packageId: number
  }

  export type PackageBundleItemCountOrderByAggregateInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
    notes?: SortOrder
  }

  export type PackageBundleItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
  }

  export type PackageBundleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
    notes?: SortOrder
  }

  export type PackageBundleItemMinOrderByAggregateInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
    notes?: SortOrder
  }

  export type PackageBundleItemSumOrderByAggregateInput = {
    id?: SortOrder
    bundleId?: SortOrder
    packageId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CMSImageCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    category?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    usedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSImageAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }

  export type CMSImageMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    category?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSImageMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    category?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSImageSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type HeroSlideCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    image?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlideAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type HeroSlideMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    image?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlideMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    image?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlideSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type CMSDestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    region?: SortOrder
    country?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    heroImage?: SortOrder
    gallery?: SortOrder
    history?: SortOrder
    geography?: SortOrder
    climate?: SortOrder
    wildlife?: SortOrder
    keyWildlife?: SortOrder
    flora?: SortOrder
    cultural?: SortOrder
    bestTime?: SortOrder
    featured?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSDestinationAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type CMSDestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    region?: SortOrder
    country?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    heroImage?: SortOrder
    history?: SortOrder
    geography?: SortOrder
    climate?: SortOrder
    wildlife?: SortOrder
    bestTime?: SortOrder
    featured?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSDestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    region?: SortOrder
    country?: SortOrder
    description?: SortOrder
    shortDesc?: SortOrder
    heroImage?: SortOrder
    history?: SortOrder
    geography?: SortOrder
    climate?: SortOrder
    wildlife?: SortOrder
    bestTime?: SortOrder
    featured?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CMSDestinationSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SiteSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SiteSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SiteSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    years?: SortOrder
    specialties?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    years?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    years?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type CMSAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type CMSAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type CMSAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type ExperienceSectionCountOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    stat1Value?: SortOrder
    stat1Label?: SortOrder
    stat2Value?: SortOrder
    stat2Label?: SortOrder
    badgeText?: SortOrder
    backgroundText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    stat1Value?: SortOrder
    stat1Label?: SortOrder
    stat2Value?: SortOrder
    stat2Label?: SortOrder
    badgeText?: SortOrder
    backgroundText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceSectionMinOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    stat1Value?: SortOrder
    stat1Label?: SortOrder
    stat2Value?: SortOrder
    stat2Label?: SortOrder
    badgeText?: SortOrder
    backgroundText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type TourGuideSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    mapImage?: SortOrder
    buttonText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourGuideSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    mapImage?: SortOrder
    buttonText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourGuideSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    mapImage?: SortOrder
    buttonText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackagesHeroCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackagesHeroMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackagesHeroMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsHeroCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsHeroMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsHeroMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsCTACountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsCTAMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationsCTAMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStorySectionCountOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    image?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStorySectionMaxOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    image?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStorySectionMinOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    image?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCommunitySectionCountOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    feature1Title?: SortOrder
    feature1Description?: SortOrder
    feature2Title?: SortOrder
    feature2Description?: SortOrder
    feature3Title?: SortOrder
    feature3Description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCommunitySectionMaxOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    feature1Title?: SortOrder
    feature1Description?: SortOrder
    feature2Title?: SortOrder
    feature2Description?: SortOrder
    feature3Title?: SortOrder
    feature3Description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCommunitySectionMinOrderByAggregateInput = {
    id?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    titleHighlight?: SortOrder
    paragraph1?: SortOrder
    paragraph2?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    feature1Title?: SortOrder
    feature1Description?: SortOrder
    feature2Title?: SortOrder
    feature2Description?: SortOrder
    feature3Title?: SortOrder
    feature3Description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStatsCountOrderByAggregateInput = {
    id?: SortOrder
    stat1Number?: SortOrder
    stat1Label?: SortOrder
    stat2Number?: SortOrder
    stat2Label?: SortOrder
    stat3Number?: SortOrder
    stat3Label?: SortOrder
    stat4Number?: SortOrder
    stat4Label?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    stat1Number?: SortOrder
    stat1Label?: SortOrder
    stat2Number?: SortOrder
    stat2Label?: SortOrder
    stat3Number?: SortOrder
    stat3Label?: SortOrder
    stat4Number?: SortOrder
    stat4Label?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutStatsMinOrderByAggregateInput = {
    id?: SortOrder
    stat1Number?: SortOrder
    stat1Label?: SortOrder
    stat2Number?: SortOrder
    stat2Label?: SortOrder
    stat3Number?: SortOrder
    stat3Label?: SortOrder
    stat4Number?: SortOrder
    stat4Label?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutValueCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutValueAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AboutValueMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutValueMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutValueSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AboutHeroCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutHeroMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutHeroMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCTACountOrderByAggregateInput = {
    id?: SortOrder
    badge?: SortOrder
    heading?: SortOrder
    headingHighlight?: SortOrder
    description?: SortOrder
    button1Text?: SortOrder
    button1Link?: SortOrder
    button2Text?: SortOrder
    button2Link?: SortOrder
    footerText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCTAMaxOrderByAggregateInput = {
    id?: SortOrder
    badge?: SortOrder
    heading?: SortOrder
    headingHighlight?: SortOrder
    description?: SortOrder
    button1Text?: SortOrder
    button1Link?: SortOrder
    button2Text?: SortOrder
    button2Link?: SortOrder
    footerText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutCTAMinOrderByAggregateInput = {
    id?: SortOrder
    badge?: SortOrder
    heading?: SortOrder
    headingHighlight?: SortOrder
    description?: SortOrder
    button1Text?: SortOrder
    button1Link?: SortOrder
    button2Text?: SortOrder
    button2Link?: SortOrder
    footerText?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactHeroCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactHeroMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactHeroMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    office?: SortOrder
    businessHours?: SortOrder
    quickResponse?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    office?: SortOrder
    quickResponse?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    office?: SortOrder
    quickResponse?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    linkText?: SortOrder
    linkUrl?: SortOrder
    isExternal?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactResourceAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ContactResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    linkText?: SortOrder
    linkUrl?: SortOrder
    isExternal?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    linkText?: SortOrder
    linkUrl?: SortOrder
    isExternal?: SortOrder
    displayOrder?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactResourceSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type DestinationCreateimagesInput = {
    set: string[]
  }

  export type DestinationCreategallery2ImagesInput = {
    set: string[]
  }

  export type DestinationCreatehistoryContentInput = {
    set: string[]
  }

  export type DestinationCreatewildlifeMammalsInput = {
    set: string[]
  }

  export type DestinationCreatewildlifeBirdsInput = {
    set: string[]
  }

  export type DestinationCreatewildlifeFloraInput = {
    set: string[]
  }

  export type DestinationCreatecultureExperiencesInput = {
    set: string[]
  }

  export type BookingCreateNestedManyWithoutDestinationInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutDestinationInput = {
    create?: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput> | UserFavoriteCreateWithoutDestinationInput[] | UserFavoriteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutDestinationInput | UserFavoriteCreateOrConnectWithoutDestinationInput[]
    createMany?: UserFavoriteCreateManyDestinationInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput> | UserFavoriteCreateWithoutDestinationInput[] | UserFavoriteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutDestinationInput | UserFavoriteCreateOrConnectWithoutDestinationInput[]
    createMany?: UserFavoriteCreateManyDestinationInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DestinationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DestinationUpdategallery2ImagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DestinationUpdatehistoryContentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DestinationUpdatewildlifeMammalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DestinationUpdatewildlifeBirdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DestinationUpdatewildlifeFloraInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DestinationUpdatecultureExperiencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookingUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDestinationInput | BookingUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDestinationInput | BookingUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDestinationInput | BookingUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput> | UserFavoriteCreateWithoutDestinationInput[] | UserFavoriteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutDestinationInput | UserFavoriteCreateOrConnectWithoutDestinationInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutDestinationInput | UserFavoriteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: UserFavoriteCreateManyDestinationInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutDestinationInput | UserFavoriteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutDestinationInput | UserFavoriteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDestinationInput | BookingUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDestinationInput | BookingUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDestinationInput | BookingUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput> | UserFavoriteCreateWithoutDestinationInput[] | UserFavoriteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutDestinationInput | UserFavoriteCreateOrConnectWithoutDestinationInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutDestinationInput | UserFavoriteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: UserFavoriteCreateManyDestinationInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutDestinationInput | UserFavoriteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutDestinationInput | UserFavoriteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type DestinationCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DestinationCreateWithoutBookingsInput, DestinationUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsInput
    connect?: DestinationWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBookingsInput
    connect?: PackageWhereUniqueInput
  }

  export type EnumBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingType
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type DestinationUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DestinationCreateWithoutBookingsInput, DestinationUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsInput
    upsert?: DestinationUpsertWithoutBookingsInput
    disconnect?: DestinationWhereInput | boolean
    delete?: DestinationWhereInput | boolean
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutBookingsInput, DestinationUpdateWithoutBookingsInput>, DestinationUncheckedUpdateWithoutBookingsInput>
  }

  export type PackageUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBookingsInput
    upsert?: PackageUpsertWithoutBookingsInput
    disconnect?: PackageWhereInput | boolean
    delete?: PackageWhereInput | boolean
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutBookingsInput, PackageUpdateWithoutBookingsInput>, PackageUncheckedUpdateWithoutBookingsInput>
  }

  export type EnumInquiryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InquiryStatus
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type CustomPackageCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput> | CustomPackageCreateWithoutUserInput[] | CustomPackageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPackageCreateOrConnectWithoutUserInput | CustomPackageCreateOrConnectWithoutUserInput[]
    createMany?: CustomPackageCreateManyUserInputEnvelope
    connect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
  }

  export type PackageBundleCreateNestedManyWithoutUserInput = {
    create?: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput> | PackageBundleCreateWithoutUserInput[] | PackageBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PackageBundleCreateOrConnectWithoutUserInput | PackageBundleCreateOrConnectWithoutUserInput[]
    createMany?: PackageBundleCreateManyUserInputEnvelope
    connect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type CustomPackageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput> | CustomPackageCreateWithoutUserInput[] | CustomPackageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPackageCreateOrConnectWithoutUserInput | CustomPackageCreateOrConnectWithoutUserInput[]
    createMany?: CustomPackageCreateManyUserInputEnvelope
    connect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
  }

  export type PackageBundleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput> | PackageBundleCreateWithoutUserInput[] | PackageBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PackageBundleCreateOrConnectWithoutUserInput | PackageBundleCreateOrConnectWithoutUserInput[]
    createMany?: PackageBundleCreateManyUserInputEnvelope
    connect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
  }

  export type UserFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type CustomPackageUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput> | CustomPackageCreateWithoutUserInput[] | CustomPackageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPackageCreateOrConnectWithoutUserInput | CustomPackageCreateOrConnectWithoutUserInput[]
    upsert?: CustomPackageUpsertWithWhereUniqueWithoutUserInput | CustomPackageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomPackageCreateManyUserInputEnvelope
    set?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    disconnect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    delete?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    connect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    update?: CustomPackageUpdateWithWhereUniqueWithoutUserInput | CustomPackageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomPackageUpdateManyWithWhereWithoutUserInput | CustomPackageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomPackageScalarWhereInput | CustomPackageScalarWhereInput[]
  }

  export type PackageBundleUpdateManyWithoutUserNestedInput = {
    create?: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput> | PackageBundleCreateWithoutUserInput[] | PackageBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PackageBundleCreateOrConnectWithoutUserInput | PackageBundleCreateOrConnectWithoutUserInput[]
    upsert?: PackageBundleUpsertWithWhereUniqueWithoutUserInput | PackageBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PackageBundleCreateManyUserInputEnvelope
    set?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    disconnect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    delete?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    connect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    update?: PackageBundleUpdateWithWhereUniqueWithoutUserInput | PackageBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PackageBundleUpdateManyWithWhereWithoutUserInput | PackageBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PackageBundleScalarWhereInput | PackageBundleScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type CustomPackageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput> | CustomPackageCreateWithoutUserInput[] | CustomPackageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPackageCreateOrConnectWithoutUserInput | CustomPackageCreateOrConnectWithoutUserInput[]
    upsert?: CustomPackageUpsertWithWhereUniqueWithoutUserInput | CustomPackageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomPackageCreateManyUserInputEnvelope
    set?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    disconnect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    delete?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    connect?: CustomPackageWhereUniqueInput | CustomPackageWhereUniqueInput[]
    update?: CustomPackageUpdateWithWhereUniqueWithoutUserInput | CustomPackageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomPackageUpdateManyWithWhereWithoutUserInput | CustomPackageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomPackageScalarWhereInput | CustomPackageScalarWhereInput[]
  }

  export type PackageBundleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput> | PackageBundleCreateWithoutUserInput[] | PackageBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PackageBundleCreateOrConnectWithoutUserInput | PackageBundleCreateOrConnectWithoutUserInput[]
    upsert?: PackageBundleUpsertWithWhereUniqueWithoutUserInput | PackageBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PackageBundleCreateManyUserInputEnvelope
    set?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    disconnect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    delete?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    connect?: PackageBundleWhereUniqueInput | PackageBundleWhereUniqueInput[]
    update?: PackageBundleUpdateWithWhereUniqueWithoutUserInput | PackageBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PackageBundleUpdateManyWithWhereWithoutUserInput | PackageBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PackageBundleScalarWhereInput | PackageBundleScalarWhereInput[]
  }

  export type DestinationCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<DestinationCreateWithoutFavoritesInput, DestinationUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutFavoritesInput
    connect?: DestinationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type DestinationUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<DestinationCreateWithoutFavoritesInput, DestinationUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutFavoritesInput
    upsert?: DestinationUpsertWithoutFavoritesInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutFavoritesInput, DestinationUpdateWithoutFavoritesInput>, DestinationUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type PackageCreateimagesInput = {
    set: string[]
  }

  export type PackageCreategallery2ImagesInput = {
    set: string[]
  }

  export type PackageCreatehighlightsInput = {
    set: string[]
  }

  export type PackageCreateincludedInput = {
    set: string[]
  }

  export type PackageCreateexcludedInput = {
    set: string[]
  }

  export type BookingCreateNestedManyWithoutPackageInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackageBundleItemCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput> | PackageBundleItemCreateWithoutPackageInput[] | PackageBundleItemUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutPackageInput | PackageBundleItemCreateOrConnectWithoutPackageInput[]
    createMany?: PackageBundleItemCreateManyPackageInputEnvelope
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackageBundleItemUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput> | PackageBundleItemCreateWithoutPackageInput[] | PackageBundleItemUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutPackageInput | PackageBundleItemCreateOrConnectWithoutPackageInput[]
    createMany?: PackageBundleItemCreateManyPackageInputEnvelope
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
  }

  export type PackageUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PackageUpdategallery2ImagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PackageUpdatehighlightsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PackageUpdateincludedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PackageUpdateexcludedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumDifficultyLevelFieldUpdateOperationsInput = {
    set?: $Enums.DifficultyLevel
  }

  export type BookingUpdateManyWithoutPackageNestedInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPackageInput | BookingUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPackageInput | BookingUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPackageInput | BookingUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackageBundleItemUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput> | PackageBundleItemCreateWithoutPackageInput[] | PackageBundleItemUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutPackageInput | PackageBundleItemCreateOrConnectWithoutPackageInput[]
    upsert?: PackageBundleItemUpsertWithWhereUniqueWithoutPackageInput | PackageBundleItemUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageBundleItemCreateManyPackageInputEnvelope
    set?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    disconnect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    delete?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    update?: PackageBundleItemUpdateWithWhereUniqueWithoutPackageInput | PackageBundleItemUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageBundleItemUpdateManyWithWhereWithoutPackageInput | PackageBundleItemUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPackageInput | BookingUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPackageInput | BookingUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPackageInput | BookingUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackageBundleItemUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput> | PackageBundleItemCreateWithoutPackageInput[] | PackageBundleItemUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutPackageInput | PackageBundleItemCreateOrConnectWithoutPackageInput[]
    upsert?: PackageBundleItemUpsertWithWhereUniqueWithoutPackageInput | PackageBundleItemUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageBundleItemCreateManyPackageInputEnvelope
    set?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    disconnect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    delete?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    update?: PackageBundleItemUpdateWithWhereUniqueWithoutPackageInput | PackageBundleItemUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageBundleItemUpdateManyWithWhereWithoutPackageInput | PackageBundleItemUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCustomPackagesInput = {
    create?: XOR<UserCreateWithoutCustomPackagesInput, UserUncheckedCreateWithoutCustomPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPackagesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCustomPackageStatusFieldUpdateOperationsInput = {
    set?: $Enums.CustomPackageStatus
  }

  export type UserUpdateOneRequiredWithoutCustomPackagesNestedInput = {
    create?: XOR<UserCreateWithoutCustomPackagesInput, UserUncheckedCreateWithoutCustomPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPackagesInput
    upsert?: UserUpsertWithoutCustomPackagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomPackagesInput, UserUpdateWithoutCustomPackagesInput>, UserUncheckedUpdateWithoutCustomPackagesInput>
  }

  export type UserCreateNestedOneWithoutPackageBundlesInput = {
    create?: XOR<UserCreateWithoutPackageBundlesInput, UserUncheckedCreateWithoutPackageBundlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPackageBundlesInput
    connect?: UserWhereUniqueInput
  }

  export type PackageBundleItemCreateNestedManyWithoutBundleInput = {
    create?: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput> | PackageBundleItemCreateWithoutBundleInput[] | PackageBundleItemUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutBundleInput | PackageBundleItemCreateOrConnectWithoutBundleInput[]
    createMany?: PackageBundleItemCreateManyBundleInputEnvelope
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
  }

  export type PackageBundleItemUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput> | PackageBundleItemCreateWithoutBundleInput[] | PackageBundleItemUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutBundleInput | PackageBundleItemCreateOrConnectWithoutBundleInput[]
    createMany?: PackageBundleItemCreateManyBundleInputEnvelope
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPackageBundlesNestedInput = {
    create?: XOR<UserCreateWithoutPackageBundlesInput, UserUncheckedCreateWithoutPackageBundlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPackageBundlesInput
    upsert?: UserUpsertWithoutPackageBundlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPackageBundlesInput, UserUpdateWithoutPackageBundlesInput>, UserUncheckedUpdateWithoutPackageBundlesInput>
  }

  export type PackageBundleItemUpdateManyWithoutBundleNestedInput = {
    create?: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput> | PackageBundleItemCreateWithoutBundleInput[] | PackageBundleItemUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutBundleInput | PackageBundleItemCreateOrConnectWithoutBundleInput[]
    upsert?: PackageBundleItemUpsertWithWhereUniqueWithoutBundleInput | PackageBundleItemUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: PackageBundleItemCreateManyBundleInputEnvelope
    set?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    disconnect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    delete?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    update?: PackageBundleItemUpdateWithWhereUniqueWithoutBundleInput | PackageBundleItemUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: PackageBundleItemUpdateManyWithWhereWithoutBundleInput | PackageBundleItemUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
  }

  export type PackageBundleItemUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput> | PackageBundleItemCreateWithoutBundleInput[] | PackageBundleItemUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: PackageBundleItemCreateOrConnectWithoutBundleInput | PackageBundleItemCreateOrConnectWithoutBundleInput[]
    upsert?: PackageBundleItemUpsertWithWhereUniqueWithoutBundleInput | PackageBundleItemUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: PackageBundleItemCreateManyBundleInputEnvelope
    set?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    disconnect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    delete?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    connect?: PackageBundleItemWhereUniqueInput | PackageBundleItemWhereUniqueInput[]
    update?: PackageBundleItemUpdateWithWhereUniqueWithoutBundleInput | PackageBundleItemUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: PackageBundleItemUpdateManyWithWhereWithoutBundleInput | PackageBundleItemUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
  }

  export type PackageBundleCreateNestedOneWithoutPackagesInput = {
    create?: XOR<PackageBundleCreateWithoutPackagesInput, PackageBundleUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: PackageBundleCreateOrConnectWithoutPackagesInput
    connect?: PackageBundleWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutBundleItemsInput = {
    create?: XOR<PackageCreateWithoutBundleItemsInput, PackageUncheckedCreateWithoutBundleItemsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBundleItemsInput
    connect?: PackageWhereUniqueInput
  }

  export type PackageBundleUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<PackageBundleCreateWithoutPackagesInput, PackageBundleUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: PackageBundleCreateOrConnectWithoutPackagesInput
    upsert?: PackageBundleUpsertWithoutPackagesInput
    connect?: PackageBundleWhereUniqueInput
    update?: XOR<XOR<PackageBundleUpdateToOneWithWhereWithoutPackagesInput, PackageBundleUpdateWithoutPackagesInput>, PackageBundleUncheckedUpdateWithoutPackagesInput>
  }

  export type PackageUpdateOneRequiredWithoutBundleItemsNestedInput = {
    create?: XOR<PackageCreateWithoutBundleItemsInput, PackageUncheckedCreateWithoutBundleItemsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBundleItemsInput
    upsert?: PackageUpsertWithoutBundleItemsInput
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutBundleItemsInput, PackageUpdateWithoutBundleItemsInput>, PackageUncheckedUpdateWithoutBundleItemsInput>
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumCustomPackageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPackageStatus | EnumCustomPackageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPackageStatusFilter<$PrismaModel> | $Enums.CustomPackageStatus
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumCustomPackageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPackageStatus | EnumCustomPackageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPackageStatus[] | ListEnumCustomPackageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPackageStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomPackageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPackageStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomPackageStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type BookingCreateWithoutDestinationInput = {
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    package?: PackageCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutDestinationInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    packageId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput>
  }

  export type BookingCreateManyDestinationInputEnvelope = {
    data: BookingCreateManyDestinationInput | BookingCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutDestinationInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteUncheckedCreateWithoutDestinationInput = {
    id?: number
    userId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutDestinationInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput>
  }

  export type UserFavoriteCreateManyDestinationInputEnvelope = {
    data: UserFavoriteCreateManyDestinationInput | UserFavoriteCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDestinationInput, BookingUncheckedUpdateWithoutDestinationInput>
    create: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDestinationInput, BookingUncheckedUpdateWithoutDestinationInput>
  }

  export type BookingUpdateManyWithWhereWithoutDestinationInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDestinationInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    confirmationNumber?: StringFilter<"Booking"> | string
    userId?: StringNullableFilter<"Booking"> | string | null
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringFilter<"Booking"> | string
    country?: StringNullableFilter<"Booking"> | string | null
    packageId?: IntNullableFilter<"Booking"> | number | null
    destinationId?: IntNullableFilter<"Booking"> | number | null
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    numberOfTravelers?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    travelDateFrom?: DateTimeFilter<"Booking"> | Date | string
    travelDateTo?: DateTimeFilter<"Booking"> | Date | string
    pricePerPerson?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    paymentReference?: StringNullableFilter<"Booking"> | string | null
    paymentIntentId?: StringNullableFilter<"Booking"> | string | null
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    adminNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutDestinationInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutDestinationInput, UserFavoriteUncheckedUpdateWithoutDestinationInput>
    create: XOR<UserFavoriteCreateWithoutDestinationInput, UserFavoriteUncheckedCreateWithoutDestinationInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutDestinationInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutDestinationInput, UserFavoriteUncheckedUpdateWithoutDestinationInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutDestinationInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutDestinationInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    id?: IntFilter<"UserFavorite"> | number
    userId?: StringFilter<"UserFavorite"> | string
    destinationId?: IntFilter<"UserFavorite"> | number
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type DestinationCreateWithoutBookingsInput = {
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutBookingsInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutBookingsInput, DestinationUncheckedCreateWithoutBookingsInput>
  }

  export type PackageCreateWithoutBookingsInput = {
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bundleItems?: PackageBundleItemCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bundleItems?: PackageBundleItemUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutBookingsInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
  }

  export type DestinationUpsertWithoutBookingsInput = {
    update: XOR<DestinationUpdateWithoutBookingsInput, DestinationUncheckedUpdateWithoutBookingsInput>
    create: XOR<DestinationCreateWithoutBookingsInput, DestinationUncheckedCreateWithoutBookingsInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutBookingsInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutBookingsInput, DestinationUncheckedUpdateWithoutBookingsInput>
  }

  export type DestinationUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type PackageUpsertWithoutBookingsInput = {
    update: XOR<PackageUpdateWithoutBookingsInput, PackageUncheckedUpdateWithoutBookingsInput>
    create: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutBookingsInput, PackageUncheckedUpdateWithoutBookingsInput>
  }

  export type PackageUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bundleItems?: PackageBundleItemUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bundleItems?: PackageBundleItemUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type UserFavoriteCreateWithoutUserInput = {
    createdAt?: Date | string
    destination: DestinationCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteUncheckedCreateWithoutUserInput = {
    id?: number
    destinationId: number
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateManyUserInputEnvelope = {
    data: UserFavoriteCreateManyUserInput | UserFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomPackageCreateWithoutUserInput = {
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPackageUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPackageCreateOrConnectWithoutUserInput = {
    where: CustomPackageWhereUniqueInput
    create: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput>
  }

  export type CustomPackageCreateManyUserInputEnvelope = {
    data: CustomPackageCreateManyUserInput | CustomPackageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PackageBundleCreateWithoutUserInput = {
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    packages?: PackageBundleItemCreateNestedManyWithoutBundleInput
  }

  export type PackageBundleUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    packages?: PackageBundleItemUncheckedCreateNestedManyWithoutBundleInput
  }

  export type PackageBundleCreateOrConnectWithoutUserInput = {
    where: PackageBundleWhereUniqueInput
    create: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput>
  }

  export type PackageBundleCreateManyUserInputEnvelope = {
    data: PackageBundleCreateManyUserInput | PackageBundleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type CustomPackageUpsertWithWhereUniqueWithoutUserInput = {
    where: CustomPackageWhereUniqueInput
    update: XOR<CustomPackageUpdateWithoutUserInput, CustomPackageUncheckedUpdateWithoutUserInput>
    create: XOR<CustomPackageCreateWithoutUserInput, CustomPackageUncheckedCreateWithoutUserInput>
  }

  export type CustomPackageUpdateWithWhereUniqueWithoutUserInput = {
    where: CustomPackageWhereUniqueInput
    data: XOR<CustomPackageUpdateWithoutUserInput, CustomPackageUncheckedUpdateWithoutUserInput>
  }

  export type CustomPackageUpdateManyWithWhereWithoutUserInput = {
    where: CustomPackageScalarWhereInput
    data: XOR<CustomPackageUpdateManyMutationInput, CustomPackageUncheckedUpdateManyWithoutUserInput>
  }

  export type CustomPackageScalarWhereInput = {
    AND?: CustomPackageScalarWhereInput | CustomPackageScalarWhereInput[]
    OR?: CustomPackageScalarWhereInput[]
    NOT?: CustomPackageScalarWhereInput | CustomPackageScalarWhereInput[]
    id?: IntFilter<"CustomPackage"> | number
    userId?: StringFilter<"CustomPackage"> | string
    name?: StringFilter<"CustomPackage"> | string
    contactName?: StringFilter<"CustomPackage"> | string
    email?: StringFilter<"CustomPackage"> | string
    phone?: StringFilter<"CustomPackage"> | string
    destinations?: JsonFilter<"CustomPackage">
    duration?: StringNullableFilter<"CustomPackage"> | string | null
    numberOfPeople?: IntFilter<"CustomPackage"> | number
    travelDate?: DateTimeNullableFilter<"CustomPackage"> | Date | string | null
    specialRequests?: StringNullableFilter<"CustomPackage"> | string | null
    budget?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFilter<"CustomPackage"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"CustomPackage"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"CustomPackage"> | string | null
    createdAt?: DateTimeFilter<"CustomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPackage"> | Date | string
  }

  export type PackageBundleUpsertWithWhereUniqueWithoutUserInput = {
    where: PackageBundleWhereUniqueInput
    update: XOR<PackageBundleUpdateWithoutUserInput, PackageBundleUncheckedUpdateWithoutUserInput>
    create: XOR<PackageBundleCreateWithoutUserInput, PackageBundleUncheckedCreateWithoutUserInput>
  }

  export type PackageBundleUpdateWithWhereUniqueWithoutUserInput = {
    where: PackageBundleWhereUniqueInput
    data: XOR<PackageBundleUpdateWithoutUserInput, PackageBundleUncheckedUpdateWithoutUserInput>
  }

  export type PackageBundleUpdateManyWithWhereWithoutUserInput = {
    where: PackageBundleScalarWhereInput
    data: XOR<PackageBundleUpdateManyMutationInput, PackageBundleUncheckedUpdateManyWithoutUserInput>
  }

  export type PackageBundleScalarWhereInput = {
    AND?: PackageBundleScalarWhereInput | PackageBundleScalarWhereInput[]
    OR?: PackageBundleScalarWhereInput[]
    NOT?: PackageBundleScalarWhereInput | PackageBundleScalarWhereInput[]
    id?: IntFilter<"PackageBundle"> | number
    userId?: StringFilter<"PackageBundle"> | string
    name?: StringNullableFilter<"PackageBundle"> | string | null
    numberOfPeople?: IntFilter<"PackageBundle"> | number
    travelDate?: DateTimeNullableFilter<"PackageBundle"> | Date | string | null
    specialRequests?: StringNullableFilter<"PackageBundle"> | string | null
    status?: EnumCustomPackageStatusFilter<"PackageBundle"> | $Enums.CustomPackageStatus
    quotedPrice?: DecimalNullableFilter<"PackageBundle"> | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: StringNullableFilter<"PackageBundle"> | string | null
    createdAt?: DateTimeFilter<"PackageBundle"> | Date | string
    updatedAt?: DateTimeFilter<"PackageBundle"> | Date | string
  }

  export type DestinationCreateWithoutFavoritesInput = {
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutFavoritesInput = {
    id?: number
    name: string
    category: string
    country?: string
    region?: string | null
    price: Decimal | DecimalJsLike | number | string
    rating?: number
    duration: string
    groupSize: number
    minTravelers?: number | null
    maxTravelers?: number | null
    description: string
    image: string
    images?: DestinationCreateimagesInput | string[]
    gallery2Images?: DestinationCreategallery2ImagesInput | string[]
    featured?: boolean
    historyTitle?: string | null
    historyContent?: DestinationCreatehistoryContentInput | string[]
    geographyDescription?: string | null
    geographyClimate?: string | null
    wildlifeDescription?: string | null
    wildlifeMammals?: DestinationCreatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationCreatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationCreatewildlifeFloraInput | string[]
    cultureDescription?: string | null
    cultureExperiences?: DestinationCreatecultureExperiencesInput | string[]
    bestTimeDescription?: string | null
    drySeasonTitle?: string | null
    drySeasonDescription?: string | null
    wetSeasonTitle?: string | null
    wetSeasonDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutFavoritesInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutFavoritesInput, DestinationUncheckedCreateWithoutFavoritesInput>
  }

  export type UserCreateWithoutFavoritesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customPackages?: CustomPackageCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customPackages?: CustomPackageUncheckedCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type DestinationUpsertWithoutFavoritesInput = {
    update: XOR<DestinationUpdateWithoutFavoritesInput, DestinationUncheckedUpdateWithoutFavoritesInput>
    create: XOR<DestinationCreateWithoutFavoritesInput, DestinationUncheckedCreateWithoutFavoritesInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutFavoritesInput, DestinationUncheckedUpdateWithoutFavoritesInput>
  }

  export type DestinationUpdateWithoutFavoritesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: IntFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    minTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    maxTravelers?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    images?: DestinationUpdateimagesInput | string[]
    gallery2Images?: DestinationUpdategallery2ImagesInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    historyTitle?: NullableStringFieldUpdateOperationsInput | string | null
    historyContent?: DestinationUpdatehistoryContentInput | string[]
    geographyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    geographyClimate?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wildlifeMammals?: DestinationUpdatewildlifeMammalsInput | string[]
    wildlifeBirds?: DestinationUpdatewildlifeBirdsInput | string[]
    wildlifeFlora?: DestinationUpdatewildlifeFloraInput | string[]
    cultureDescription?: NullableStringFieldUpdateOperationsInput | string | null
    cultureExperiences?: DestinationUpdatecultureExperiencesInput | string[]
    bestTimeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    drySeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    wetSeasonDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customPackages?: CustomPackageUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customPackages?: CustomPackageUncheckedUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingCreateWithoutPackageInput = {
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destination?: DestinationCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPackageInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    destinationId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPackageInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput>
  }

  export type BookingCreateManyPackageInputEnvelope = {
    data: BookingCreateManyPackageInput | BookingCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type PackageBundleItemCreateWithoutPackageInput = {
    notes?: string | null
    bundle: PackageBundleCreateNestedOneWithoutPackagesInput
  }

  export type PackageBundleItemUncheckedCreateWithoutPackageInput = {
    id?: number
    bundleId: number
    notes?: string | null
  }

  export type PackageBundleItemCreateOrConnectWithoutPackageInput = {
    where: PackageBundleItemWhereUniqueInput
    create: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput>
  }

  export type PackageBundleItemCreateManyPackageInputEnvelope = {
    data: PackageBundleItemCreateManyPackageInput | PackageBundleItemCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutPackageInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPackageInput, BookingUncheckedUpdateWithoutPackageInput>
    create: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPackageInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPackageInput, BookingUncheckedUpdateWithoutPackageInput>
  }

  export type BookingUpdateManyWithWhereWithoutPackageInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackageBundleItemUpsertWithWhereUniqueWithoutPackageInput = {
    where: PackageBundleItemWhereUniqueInput
    update: XOR<PackageBundleItemUpdateWithoutPackageInput, PackageBundleItemUncheckedUpdateWithoutPackageInput>
    create: XOR<PackageBundleItemCreateWithoutPackageInput, PackageBundleItemUncheckedCreateWithoutPackageInput>
  }

  export type PackageBundleItemUpdateWithWhereUniqueWithoutPackageInput = {
    where: PackageBundleItemWhereUniqueInput
    data: XOR<PackageBundleItemUpdateWithoutPackageInput, PackageBundleItemUncheckedUpdateWithoutPackageInput>
  }

  export type PackageBundleItemUpdateManyWithWhereWithoutPackageInput = {
    where: PackageBundleItemScalarWhereInput
    data: XOR<PackageBundleItemUpdateManyMutationInput, PackageBundleItemUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackageBundleItemScalarWhereInput = {
    AND?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
    OR?: PackageBundleItemScalarWhereInput[]
    NOT?: PackageBundleItemScalarWhereInput | PackageBundleItemScalarWhereInput[]
    id?: IntFilter<"PackageBundleItem"> | number
    bundleId?: IntFilter<"PackageBundleItem"> | number
    packageId?: IntFilter<"PackageBundleItem"> | number
    notes?: StringNullableFilter<"PackageBundleItem"> | string | null
  }

  export type UserCreateWithoutCustomPackagesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomPackagesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    packageBundles?: PackageBundleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomPackagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomPackagesInput, UserUncheckedCreateWithoutCustomPackagesInput>
  }

  export type UserUpsertWithoutCustomPackagesInput = {
    update: XOR<UserUpdateWithoutCustomPackagesInput, UserUncheckedUpdateWithoutCustomPackagesInput>
    create: XOR<UserCreateWithoutCustomPackagesInput, UserUncheckedCreateWithoutCustomPackagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomPackagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomPackagesInput, UserUncheckedUpdateWithoutCustomPackagesInput>
  }

  export type UserUpdateWithoutCustomPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    packageBundles?: PackageBundleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPackageBundlesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    customPackages?: CustomPackageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPackageBundlesInput = {
    id: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    customPackages?: CustomPackageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPackageBundlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPackageBundlesInput, UserUncheckedCreateWithoutPackageBundlesInput>
  }

  export type PackageBundleItemCreateWithoutBundleInput = {
    notes?: string | null
    package: PackageCreateNestedOneWithoutBundleItemsInput
  }

  export type PackageBundleItemUncheckedCreateWithoutBundleInput = {
    id?: number
    packageId: number
    notes?: string | null
  }

  export type PackageBundleItemCreateOrConnectWithoutBundleInput = {
    where: PackageBundleItemWhereUniqueInput
    create: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput>
  }

  export type PackageBundleItemCreateManyBundleInputEnvelope = {
    data: PackageBundleItemCreateManyBundleInput | PackageBundleItemCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPackageBundlesInput = {
    update: XOR<UserUpdateWithoutPackageBundlesInput, UserUncheckedUpdateWithoutPackageBundlesInput>
    create: XOR<UserCreateWithoutPackageBundlesInput, UserUncheckedCreateWithoutPackageBundlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPackageBundlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPackageBundlesInput, UserUncheckedUpdateWithoutPackageBundlesInput>
  }

  export type UserUpdateWithoutPackageBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    customPackages?: CustomPackageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPackageBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    customPackages?: CustomPackageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PackageBundleItemUpsertWithWhereUniqueWithoutBundleInput = {
    where: PackageBundleItemWhereUniqueInput
    update: XOR<PackageBundleItemUpdateWithoutBundleInput, PackageBundleItemUncheckedUpdateWithoutBundleInput>
    create: XOR<PackageBundleItemCreateWithoutBundleInput, PackageBundleItemUncheckedCreateWithoutBundleInput>
  }

  export type PackageBundleItemUpdateWithWhereUniqueWithoutBundleInput = {
    where: PackageBundleItemWhereUniqueInput
    data: XOR<PackageBundleItemUpdateWithoutBundleInput, PackageBundleItemUncheckedUpdateWithoutBundleInput>
  }

  export type PackageBundleItemUpdateManyWithWhereWithoutBundleInput = {
    where: PackageBundleItemScalarWhereInput
    data: XOR<PackageBundleItemUpdateManyMutationInput, PackageBundleItemUncheckedUpdateManyWithoutBundleInput>
  }

  export type PackageBundleCreateWithoutPackagesInput = {
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPackageBundlesInput
  }

  export type PackageBundleUncheckedCreateWithoutPackagesInput = {
    id?: number
    userId: string
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageBundleCreateOrConnectWithoutPackagesInput = {
    where: PackageBundleWhereUniqueInput
    create: XOR<PackageBundleCreateWithoutPackagesInput, PackageBundleUncheckedCreateWithoutPackagesInput>
  }

  export type PackageCreateWithoutBundleItemsInput = {
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutBundleItemsInput = {
    id?: number
    name: string
    slug: string
    category: string
    duration: string
    price: Decimal | DecimalJsLike | number | string
    description: string
    shortDesc?: string | null
    image: string
    images?: PackageCreateimagesInput | string[]
    gallery2Images?: PackageCreategallery2ImagesInput | string[]
    highlights?: PackageCreatehighlightsInput | string[]
    itinerary: JsonNullValueInput | InputJsonValue
    included?: PackageCreateincludedInput | string[]
    excluded?: PackageCreateexcludedInput | string[]
    minTravelers: number
    maxTravelers: number
    difficulty?: $Enums.DifficultyLevel
    featured?: boolean
    popular?: boolean
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutBundleItemsInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutBundleItemsInput, PackageUncheckedCreateWithoutBundleItemsInput>
  }

  export type PackageBundleUpsertWithoutPackagesInput = {
    update: XOR<PackageBundleUpdateWithoutPackagesInput, PackageBundleUncheckedUpdateWithoutPackagesInput>
    create: XOR<PackageBundleCreateWithoutPackagesInput, PackageBundleUncheckedCreateWithoutPackagesInput>
    where?: PackageBundleWhereInput
  }

  export type PackageBundleUpdateToOneWithWhereWithoutPackagesInput = {
    where?: PackageBundleWhereInput
    data: XOR<PackageBundleUpdateWithoutPackagesInput, PackageBundleUncheckedUpdateWithoutPackagesInput>
  }

  export type PackageBundleUpdateWithoutPackagesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPackageBundlesNestedInput
  }

  export type PackageBundleUncheckedUpdateWithoutPackagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUpsertWithoutBundleItemsInput = {
    update: XOR<PackageUpdateWithoutBundleItemsInput, PackageUncheckedUpdateWithoutBundleItemsInput>
    create: XOR<PackageCreateWithoutBundleItemsInput, PackageUncheckedCreateWithoutBundleItemsInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutBundleItemsInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutBundleItemsInput, PackageUncheckedUpdateWithoutBundleItemsInput>
  }

  export type PackageUpdateWithoutBundleItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutBundleItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    shortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    images?: PackageUpdateimagesInput | string[]
    gallery2Images?: PackageUpdategallery2ImagesInput | string[]
    highlights?: PackageUpdatehighlightsInput | string[]
    itinerary?: JsonNullValueInput | InputJsonValue
    included?: PackageUpdateincludedInput | string[]
    excluded?: PackageUpdateexcludedInput | string[]
    minTravelers?: IntFieldUpdateOperationsInput | number
    maxTravelers?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    featured?: BoolFieldUpdateOperationsInput | boolean
    popular?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type BookingCreateManyDestinationInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    packageId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFavoriteCreateManyDestinationInput = {
    id?: number
    userId: string
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutDestinationInput = {
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: PackageUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutDestinationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyUserInput = {
    id?: number
    destinationId: number
    createdAt?: Date | string
  }

  export type CustomPackageCreateManyUserInput = {
    id?: number
    name: string
    contactName: string
    email: string
    phone: string
    destinations: JsonNullValueInput | InputJsonValue
    duration?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageBundleCreateManyUserInput = {
    id?: number
    name?: string | null
    numberOfPeople: number
    travelDate?: Date | string | null
    specialRequests?: string | null
    status?: $Enums.CustomPackageStatus
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    quoteNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFavoriteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPackageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    destinations?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageBundleUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackageBundleItemUpdateManyWithoutBundleNestedInput
  }

  export type PackageBundleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackageBundleItemUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type PackageBundleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfPeople?: IntFieldUpdateOperationsInput | number
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomPackageStatusFieldUpdateOperationsInput | $Enums.CustomPackageStatus
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyPackageInput = {
    id?: number
    confirmationNumber?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    country?: string | null
    destinationId?: number | null
    bookingType?: $Enums.BookingType
    numberOfTravelers: number
    specialRequests?: string | null
    travelDateFrom: Date | string
    travelDateTo: Date | string
    pricePerPerson: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentReference?: string | null
    paymentIntentId?: string | null
    stripeCustomerId?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageBundleItemCreateManyPackageInput = {
    id?: number
    bundleId: number
    notes?: string | null
  }

  export type BookingUpdateWithoutPackageInput = {
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    confirmationNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    numberOfTravelers?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    travelDateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    travelDateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    pricePerPerson?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageBundleItemUpdateWithoutPackageInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bundle?: PackageBundleUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type PackageBundleItemUncheckedUpdateWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    bundleId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageBundleItemUncheckedUpdateManyWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    bundleId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageBundleItemCreateManyBundleInput = {
    id?: number
    packageId: number
    notes?: string | null
  }

  export type PackageBundleItemUpdateWithoutBundleInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    package?: PackageUpdateOneRequiredWithoutBundleItemsNestedInput
  }

  export type PackageBundleItemUncheckedUpdateWithoutBundleInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageBundleItemUncheckedUpdateManyWithoutBundleInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}